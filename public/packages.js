(function () {
  "use strict";

  function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
      e &&
        typeof e !== "string" &&
        !Array.isArray(e) &&
        Object.keys(e).forEach(function (k) {
          if (k !== "default" && !(k in n)) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(
              n,
              k,
              d.get
                ? d
                : {
                    enumerable: true,
                    get: function () {
                      return e[k];
                    },
                  },
            );
          }
        });
    });
    return Object.freeze(n);
  }

  function getDefaultExportFromCjs(x) {
    return x &&
      x.__esModule &&
      Object.prototype.hasOwnProperty.call(x, "default")
      ? x["default"]
      : x;
  }

  var jsxRuntime = { exports: {} };

  var reactJsxRuntime_production = {};

  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredReactJsxRuntime_production;

  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production)
      return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: void 0 !== config ? config : null,
        props: maybeKey,
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
  }

  var hasRequiredJsxRuntime;

  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;

    {
      jsxRuntime.exports = requireReactJsxRuntime_production();
    }
    return jsxRuntime.exports;
  }

  var jsxRuntimeExports = requireJsxRuntime();

  var react = { exports: {} };

  var react_production = {};

  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredReact_production;

  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
        isMounted: function () {
          return false;
        },
        enqueueForceUpdate: function () {},
        enqueueReplaceState: function () {},
        enqueueSetState: function () {},
      },
      assign = Object.assign,
      emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if (
        "object" !== typeof partialState &&
        "function" !== typeof partialState &&
        null != partialState
      )
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables.",
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = (PureComponent.prototype =
      new ComponentDummy());
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop() {}
    var ReactSharedInternals = { H: null, A: null, T: null, S: null },
      hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: void 0 !== refProp ? refProp : null,
        props: props,
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return (
        "$" +
        key.replace(/[=:]/g, function (match) {
          return escaperLookup[match];
        })
      );
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element &&
        null !== element &&
        null != element.key
        ? escape("" + element.key)
        : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (
            ("string" === typeof thenable.status
              ? thenable.then(noop, noop)
              : ((thenable.status = "pending"),
                thenable.then(
                  function (fulfilledValue) {
                    "pending" === thenable.status &&
                      ((thenable.status = "fulfilled"),
                      (thenable.value = fulfilledValue));
                  },
                  function (error) {
                    "pending" === thenable.status &&
                      ((thenable.status = "rejected"),
                      (thenable.reason = error));
                  },
                )),
            thenable.status)
          ) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return (
                  (invokeCallback = children._init),
                  mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback,
                  )
                );
            }
        }
      if (invokeCallback)
        return (
          (callback = callback(children)),
          (invokeCallback =
            "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
          isArrayImpl(callback)
            ? ((escapedPrefix = ""),
              null != invokeCallback &&
                (escapedPrefix =
                  invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") +
                  "/"),
              mapIntoArray(callback, array, escapedPrefix, "", function (c) {
                return c;
              }))
            : null != callback &&
              (isValidElement(callback) &&
                (callback = cloneAndReplaceKey(
                  callback,
                  escapedPrefix +
                    (null == callback.key ||
                    (children && children.key === callback.key)
                      ? ""
                      : ("" + callback.key).replace(
                          userProvidedKeyEscapeRegex,
                          "$&/",
                        ) + "/") +
                    invokeCallback,
                )),
              array.push(callback)),
          1
        );
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          ((nameSoFar = children[i]),
            (type = nextNamePrefix + getElementKey(nameSoFar, i)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback,
            )));
      else if (((i = getIteratorFn(children)), "function" === typeof i))
        for (
          children = i.call(children), i = 0;
          !(nameSoFar = children.next()).done;
        )
          ((nameSoFar = nameSoFar.value),
            (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback,
            )));
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback,
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " +
            ("[object Object]" === array
              ? "object with keys {" + Object.keys(children).join(", ") + "}"
              : array) +
            "). If you meant to render a collection of children, use an array instead.",
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function (moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              ((payload._status = 1), (payload._result = moduleObject));
          },
          function (error) {
            if (0 === payload._status || -1 === payload._status)
              ((payload._status = 2), (payload._result = error));
          },
        );
        -1 === payload._status &&
          ((payload._status = 0), (payload._result = ctor));
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: true,
                  cancelable: true,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error,
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      Children = {
        map: mapChildren,
        forEach: function (children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function () {
              forEachFunc.apply(this, arguments);
            },
            forEachContext,
          );
        },
        count: function (children) {
          var n = 0;
          mapChildren(children, function () {
            n++;
          });
          return n;
        },
        toArray: function (children) {
          return (
            mapChildren(children, function (child) {
              return child;
            }) || []
          );
        },
        only: function (children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child.",
            );
          return children;
        },
      };
    react_production.Activity = REACT_ACTIVITY_TYPE;
    react_production.Children = Children;
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE;
    react_production.Profiler = REACT_PROFILER_TYPE;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE;
    react_production.Suspense = REACT_SUSPENSE_TYPE;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      ReactSharedInternals;
    react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (size) {
        return ReactSharedInternals.H.useMemoCache(size);
      },
    };
    react_production.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    react_production.cacheSignal = function () {
      return null;
    };
    react_production.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " +
            element +
            ".",
        );
      var props = assign({}, element.props),
        key = element.key;
      if (null != config)
        for (propName in (void 0 !== config.key && (key = "" + config.key),
        config))
          !hasOwnProperty.call(config, propName) ||
            "key" === propName ||
            "__self" === propName ||
            "__source" === propName ||
            ("ref" === propName && void 0 === config.ref) ||
            (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    react_production.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue,
      };
      return defaultValue;
    };
    react_production.createElement = function (type, config, children) {
      var propName,
        props = {},
        key = null;
      if (null != config)
        for (propName in (void 0 !== config.key && (key = "" + config.key),
        config))
          hasOwnProperty.call(config, propName) &&
            "key" !== propName &&
            "__self" !== propName &&
            "__source" !== propName &&
            (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (
          var childArray = Array(childrenLength), i = 0;
          i < childrenLength;
          i++
        )
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in ((childrenLength = type.defaultProps), childrenLength))
          void 0 === props[propName] &&
            (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, props);
    };
    react_production.createRef = function () {
      return { current: null };
    };
    react_production.forwardRef = function (render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer,
      };
    };
    react_production.memo = function (type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare,
      };
    };
    react_production.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue &&
          null !== returnValue &&
          "function" === typeof returnValue.then &&
          returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        (null !== prevTransition &&
          null !== currentTransition.types &&
          (prevTransition.types = currentTransition.types),
          (ReactSharedInternals.T = prevTransition));
      }
    };
    react_production.unstable_useCacheRefresh = function () {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    react_production.use = function (usable) {
      return ReactSharedInternals.H.use(usable);
    };
    react_production.useActionState = function (
      action,
      initialState,
      permalink,
    ) {
      return ReactSharedInternals.H.useActionState(
        action,
        initialState,
        permalink,
      );
    };
    react_production.useCallback = function (callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    react_production.useContext = function (Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    react_production.useDebugValue = function () {};
    react_production.useDeferredValue = function (value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    react_production.useEffect = function (create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    react_production.useEffectEvent = function (callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    react_production.useId = function () {
      return ReactSharedInternals.H.useId();
    };
    react_production.useImperativeHandle = function (ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    react_production.useInsertionEffect = function (create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    react_production.useLayoutEffect = function (create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    react_production.useMemo = function (create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    react_production.useOptimistic = function (passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    react_production.useReducer = function (reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    react_production.useRef = function (initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    react_production.useState = function (initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    react_production.useSyncExternalStore = function (
      subscribe,
      getSnapshot,
      getServerSnapshot,
    ) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot,
      );
    };
    react_production.useTransition = function () {
      return ReactSharedInternals.H.useTransition();
    };
    react_production.version = "19.2.3";
    return react_production;
  }

  var hasRequiredReact;

  function requireReact() {
    if (hasRequiredReact) return react.exports;
    hasRequiredReact = 1;

    {
      react.exports = requireReact_production();
    }
    return react.exports;
  }

  var reactExports = requireReact();
  var React = /*@__PURE__*/ getDefaultExportFromCjs(reactExports);

  var React$1 = /*#__PURE__*/ _mergeNamespaces(
    {
      __proto__: null,
      default: React,
    },
    [reactExports],
  );

  var client = { exports: {} };

  var reactDomClient_production = {};

  var scheduler = { exports: {} };

  var scheduler_production = {};

  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredScheduler_production;

  function requireScheduler_production() {
    if (hasRequiredScheduler_production) return scheduler_production;
    hasRequiredScheduler_production = 1;
    (function (exports$1) {
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = (index - 1) >>> 1,
            parent = heap[parentIndex];
          if (0 < compare(parent, node))
            ((heap[parentIndex] = node),
              (heap[index] = parent),
              (index = parentIndex));
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0],
          last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (
            var index = 0, length = heap.length, halfLength = length >>> 1;
            index < halfLength;
          ) {
            var leftIndex = 2 * (index + 1) - 1,
              left = heap[leftIndex],
              rightIndex = leftIndex + 1,
              right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left)
                ? ((heap[index] = right),
                  (heap[rightIndex] = last),
                  (index = rightIndex))
                : ((heap[index] = left),
                  (heap[leftIndex] = last),
                  (index = leftIndex));
            else if (rightIndex < length && 0 > compare(right, last))
              ((heap[index] = right),
                (heap[rightIndex] = last),
                (index = rightIndex));
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports$1.unstable_now = void 0;
      if (
        "object" === typeof performance &&
        "function" === typeof performance.now
      ) {
        var localPerformance = performance;
        exports$1.unstable_now = function () {
          return localPerformance.now();
        };
      } else {
        var localDate = Date,
          initialTime = localDate.now();
        exports$1.unstable_now = function () {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [],
        timerQueue = [],
        taskIdCounter = 1,
        currentTask = null,
        currentPriorityLevel = 3,
        isPerformingWork = false,
        isHostCallbackScheduled = false,
        isHostTimeoutScheduled = false,
        needsPaint = false,
        localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
        localClearTimeout =
          "function" === typeof clearTimeout ? clearTimeout : null,
        localSetImmediate =
          "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            (pop(timerQueue),
              (timer.sortIndex = timer.expirationTime),
              push(taskQueue, timer));
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            ((isHostCallbackScheduled = true),
              isMessageLoopRunning ||
                ((isMessageLoopRunning = true),
                schedulePerformWorkUntilDeadline()));
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer &&
              requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime,
              );
          }
      }
      var isMessageLoopRunning = false,
        taskTimeoutID = -1,
        frameInterval = 5,
        startTime = -1;
      function shouldYieldToHost() {
        return needsPaint
          ? true
          : exports$1.unstable_now() - startTime < frameInterval
            ? false
            : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports$1.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = !1;
              isHostTimeoutScheduled &&
                ((isHostTimeoutScheduled = !1),
                localClearTimeout(taskTimeoutID),
                (taskTimeoutID = -1));
              isPerformingWork = !0;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (
                    currentTask = peek(taskQueue);
                    null !== currentTask &&
                    !(
                      currentTask.expirationTime > currentTime &&
                      shouldYieldToHost()
                    );
                  ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime,
                      );
                      currentTime = exports$1.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = !0;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = !0;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer &&
                      requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime,
                      );
                    hasMoreWork = !1;
                  }
                }
                break a;
              } finally {
                ((currentTask = null),
                  (currentPriorityLevel = previousPriorityLevel),
                  (isPerformingWork = !1));
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork
              ? schedulePerformWorkUntilDeadline()
              : (isMessageLoopRunning = false);
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function () {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(),
          port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function () {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function () {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function () {
          callback(exports$1.unstable_now());
        }, ms);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function (task) {
        task.callback = null;
      };
      exports$1.unstable_forceFrameRate = function (fps) {
        0 > fps || 125 < fps
          ? console.error(
              "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
            )
          : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
      };
      exports$1.unstable_getCurrentPriorityLevel = function () {
        return currentPriorityLevel;
      };
      exports$1.unstable_next = function (eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_requestPaint = function () {
        needsPaint = true;
      };
      exports$1.unstable_runWithPriority = function (
        priorityLevel,
        eventHandler,
      ) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_scheduleCallback = function (
        priorityLevel,
        callback,
        options,
      ) {
        var currentTime = exports$1.unstable_now();
        "object" === typeof options && null !== options
          ? ((options = options.delay),
            (options =
              "number" === typeof options && 0 < options
                ? currentTime + options
                : currentTime))
          : (options = currentTime);
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback: callback,
          priorityLevel: priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1,
        };
        options > currentTime
          ? ((priorityLevel.sortIndex = options),
            push(timerQueue, priorityLevel),
            null === peek(taskQueue) &&
              priorityLevel === peek(timerQueue) &&
              (isHostTimeoutScheduled
                ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
                : (isHostTimeoutScheduled = true),
              requestHostTimeout(handleTimeout, options - currentTime)))
          : ((priorityLevel.sortIndex = timeout),
            push(taskQueue, priorityLevel),
            isHostCallbackScheduled ||
              isPerformingWork ||
              ((isHostCallbackScheduled = true),
              isMessageLoopRunning ||
                ((isMessageLoopRunning = true),
                schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports$1.unstable_shouldYield = shouldYieldToHost;
      exports$1.unstable_wrapCallback = function (callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function () {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    return scheduler_production;
  }

  var hasRequiredScheduler;

  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;

    {
      scheduler.exports = requireScheduler_production();
    }
    return scheduler.exports;
  }

  var reactDom = { exports: {} };

  var reactDom_production = {};

  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredReactDom_production;

  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var React = requireReact();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return (
        "Minified React error #" +
        code +
        "; visit " +
        url +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      );
    }
    function noop() {}
    var Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop,
        },
        p: 0,
        findDOMNode: null,
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation,
      };
    }
    var ReactSharedInternals =
      React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      Internals;
    reactDom_production.createPortal = function (children, container) {
      var key =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (
        !container ||
        (1 !== container.nodeType &&
          9 !== container.nodeType &&
          11 !== container.nodeType)
      )
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    reactDom_production.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))
          return fn();
      } finally {
        ((ReactSharedInternals.T = previousTransition),
          (Internals.p = previousUpdatePriority),
          Internals.d.f());
      }
    };
    reactDom_production.preconnect = function (href, options) {
      "string" === typeof href &&
        (options
          ? ((options = options.crossOrigin),
            (options =
              "string" === typeof options
                ? "use-credentials" === options
                  ? options
                  : ""
                : void 0))
          : (options = null),
        Internals.d.C(href, options));
    };
    reactDom_production.prefetchDNS = function (href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function (href, options) {
      if (
        "string" === typeof href &&
        options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity =
            "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority =
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0;
        "style" === as
          ? Internals.d.S(
              href,
              "string" === typeof options.precedence
                ? options.precedence
                : void 0,
              {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority,
              },
            )
          : "script" === as &&
            Internals.d.X(href, {
              crossOrigin: crossOrigin,
              integrity: integrity,
              fetchPriority: fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            });
      }
    };
    reactDom_production.preinitModule = function (href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin,
            );
            Internals.d.M(href, {
              crossOrigin: crossOrigin,
              integrity:
                "string" === typeof options.integrity
                  ? options.integrity
                  : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            });
          }
        } else null == options && Internals.d.M(href);
    };
    reactDom_production.preload = function (href, options) {
      if (
        "string" === typeof href &&
        "object" === typeof options &&
        null !== options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority:
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0,
          referrerPolicy:
            "string" === typeof options.referrerPolicy
              ? options.referrerPolicy
              : void 0,
          imageSrcSet:
            "string" === typeof options.imageSrcSet
              ? options.imageSrcSet
              : void 0,
          imageSizes:
            "string" === typeof options.imageSizes
              ? options.imageSizes
              : void 0,
          media: "string" === typeof options.media ? options.media : void 0,
        });
      }
    };
    reactDom_production.preloadModule = function (href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin,
          );
          Internals.d.m(href, {
            as:
              "string" === typeof options.as && "script" !== options.as
                ? options.as
                : void 0,
            crossOrigin: crossOrigin,
            integrity:
              "string" === typeof options.integrity
                ? options.integrity
                : void 0,
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    reactDom_production.useFormState = function (
      action,
      initialState,
      permalink,
    ) {
      return ReactSharedInternals.H.useFormState(
        action,
        initialState,
        permalink,
      );
    };
    reactDom_production.useFormStatus = function () {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.2.3";
    return reactDom_production;
  }

  var hasRequiredReactDom;

  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom.exports;
    hasRequiredReactDom = 1;

    function checkDCE() {
      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
      if (
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function"
      ) {
        return;
      }
      try {
        // Verify that the code above has been dead code eliminated (DCE'd).
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        // DevTools shouldn't crash React, no matter what.
        // We should still report in case we break this code.
        console.error(err);
      }
    }

    {
      // DCE check should happen before ReactDOM bundle executes so that
      // DevTools can report bad minification during injection.
      checkDCE();
      reactDom.exports = requireReactDom_production();
    }
    return reactDom.exports;
  }

  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredReactDomClient_production;

  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var Scheduler = requireScheduler(),
      React = requireReact(),
      ReactDOM = requireReactDom();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return (
        "Minified React error #" +
        code +
        "; visit " +
        url +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      );
    }
    function isValidContainer(node) {
      return !(
        !node ||
        (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
      );
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          ((node = fiber),
            0 !== (node.flags & 4098) && (nearestMounted = node.return),
            (fiber = node.return));
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState &&
          ((fiber = fiber.alternate),
          null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState &&
          ((fiber = fiber.alternate),
          null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return (assertIsMounted(parentA), fiber);
            if (parentB === b) return (assertIsMounted(parentA), alternate);
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b.return) ((a = parentA), (b = parentB));
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    var assign = Object.assign,
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    var isArrayImpl = Array.isArray,
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      ReactDOMSharedInternals =
        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null,
      },
      valueStack = [],
      index = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor) {
      0 > index ||
        ((cursor.current = valueStack[index]),
        (valueStack[index] = null),
        index--);
    }
    function push(cursor, value) {
      index++;
      valueStack[index] = cursor.current;
      cursor.current = value;
    }
    var contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement)
            ? (fiber = fiber.namespaceURI)
              ? getOwnHostContext(fiber)
              : 0
            : 0;
          break;
        default:
          if (
            ((fiber = nextRootInstance.tagName),
            (nextRootInstance = nextRootInstance.namespaceURI))
          )
            ((nextRootInstance = getOwnHostContext(nextRootInstance)),
              (fiber = getChildHostContextProd(nextRootInstance, fiber)));
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(
        context,
        fiber.type,
      );
      context !== JSCompiler_inline_result &&
        (push(contextFiberStackCursor, fiber),
        push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber &&
        (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber &&
        (pop(hostTransitionProviderCursor),
        (HostTransitionContext._currentValue = sharedNotPendingObject));
    }
    var prefix, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          },
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" },
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            namePropDescriptor = RunInRootFrame = 0;
            RunInRootFrame < sampleLines.length &&
            !sampleLines[RunInRootFrame].includes(
              "DetermineComponentFrameRoot",
            );
          )
            RunInRootFrame++;
          for (
            ;
            namePropDescriptor < controlLines.length &&
            !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot",
            );
          )
            namePropDescriptor++;
          if (
            RunInRootFrame === sampleLines.length ||
            namePropDescriptor === controlLines.length
          )
            for (
              RunInRootFrame = sampleLines.length - 1,
                namePropDescriptor = controlLines.length - 1;
              1 <= RunInRootFrame &&
              0 <= namePropDescriptor &&
              sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];
            )
              namePropDescriptor--;
          for (
            ;
            1 <= RunInRootFrame && 0 <= namePropDescriptor;
            RunInRootFrame--, namePropDescriptor--
          )
            if (
              sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]
            ) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (
                    (RunInRootFrame--,
                    namePropDescriptor--,
                    0 > namePropDescriptor ||
                      sampleLines[RunInRootFrame] !==
                        controlLines[namePropDescriptor])
                  ) {
                    var frame =
                      "\n" +
                      sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName &&
                      frame.includes("<anonymous>") &&
                      (frame = frame.replace("<anonymous>", fn.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        ((reentry = false),
          (Error.prepareStackTrace = previousPrepareStackTrace));
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(previousPrepareStackTrace)
        : "";
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber
            ? describeBuiltInComponentFrame("Suspense Fallback")
            : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "",
          previous = null;
        do
          ((info += describeFiber(workInProgress, previous)),
            (previous = workInProgress),
            (workInProgress = workInProgress.return));
        while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 &&
        unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {}
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
    }
    var nextTransitionUpdateLane = 256,
      nextTransitionDeferredLane = 262144,
      nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes
        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
          0 !== pendingLanes
            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
            : ((pingedLanes &= nonIdlePendingLanes),
              0 !== pingedLanes
                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                : rootHasPendingCommit ||
                  ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
                  0 !== rootHasPendingCommit &&
                    (nextLanes =
                      getHighestPriorityLanes(rootHasPendingCommit)))))
        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
          0 !== nonIdlePendingLanes
            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
            : 0 !== pingedLanes
              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
              : rootHasPendingCommit ||
                ((rootHasPendingCommit = pendingLanes & ~root),
                0 !== rootHasPendingCommit &&
                  (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes
        ? 0
        : 0 !== wipLanes &&
            wipLanes !== nextLanes &&
            0 === (wipLanes & suspendedLanes) &&
            ((suspendedLanes = nextLanes & -nextLanes),
            (rootHasPendingCommit = wipLanes & -wipLanes),
            suspendedLanes >= rootHasPendingCommit ||
              (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
          ? wipLanes
          : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return (
        0 ===
        (root.pendingLanes &
          ~(root.suspendedLanes & ~root.pingedLanes) &
          renderLanes)
      );
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane &&
        ((root.suspendedLanes = 0),
        (root.pingedLanes = 0),
        (root.warmLanes = 0));
    }
    function markRootFinished(
      root,
      finishedLanes,
      remainingLanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
    ) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (
        remainingLanes = previouslyPendingLanes & ~remainingLanes;
        0 < remainingLanes;
      ) {
        var index$7 = 31 - clz32(remainingLanes),
          lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (
            hiddenUpdates[index$7] = null, index$7 = 0;
            index$7 < hiddenUpdatesForLane.length;
            index$7++
          ) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes &&
        0 === updatedLanes &&
        0 !== root.tag &&
        (root.suspendedLanes |=
          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] =
        root.entanglements[spawnedLaneIndex] |
        1073741824 |
        (entangledLanes & 261930);
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
      for (root = root.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes),
          lane = 1 << index$8;
        (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
          (root[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root, renderLanes) {
      var renderLane = renderLanes & -renderLanes;
      renderLane =
        0 !== (renderLane & 42)
          ? 1
          : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
        ? 0
        : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes
        ? 8 < lanes
          ? 0 !== (lanes & 134217727)
            ? 32
            : 268435456
          : 8
        : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority
        ? 32
        : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ((ReactDOMSharedInternals.p = priority), fn());
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (
          (targetInst =
            parentNode[internalContainerInstanceKey] ||
            parentNode[internalInstanceKey])
        ) {
          parentNode = targetInst.alternate;
          if (
            null !== targetInst.child ||
            (null !== parentNode && null !== parentNode.child)
          )
            for (
              targetNode = getParentHydrationBoundary(targetNode);
              null !== targetNode;
            ) {
              if ((parentNode = targetNode[internalInstanceKey]))
                return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (
        (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
      ) {
        var tag = node.tag;
        if (
          5 === tag ||
          6 === tag ||
          13 === tag ||
          31 === tag ||
          26 === tag ||
          27 === tag ||
          3 === tag
        )
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
        return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources ||
        (resources = root[internalRootNodeResourcesKey] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    var allNativeEvents = new Set(),
      registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (
        registrationName = 0;
        registrationName < dependencies.length;
        registrationName++
      )
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$",
      ),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return (validatedAttributeNameCache[attributeName] = true);
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node.removeAttribute(name);
                return;
              }
          }
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (
        (elem = elem.nodeName) &&
        "input" === elem.toLowerCase() &&
        ("checkbox" === type || "radio" === type)
      );
    }
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField,
      );
      if (
        !node.hasOwnProperty(valueField) &&
        "undefined" !== typeof descriptor &&
        "function" === typeof descriptor.get &&
        "function" === typeof descriptor.set
      ) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            currentValue = "" + value;
            set.call(this, value);
          },
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable,
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          },
        };
      }
    }
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(
          node,
          valueField,
          "" + node[valueField],
        );
      }
    }
    function updateValueIfChanged(node) {
      if (!node) return false;
      var tracker = node._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node &&
        (value = isCheckable(node)
          ? node.checked
            ? "true"
            : "false"
          : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function (ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        },
      );
    }
    function updateInput(
      element,
      value,
      defaultValue,
      lastDefaultValue,
      checked,
      defaultChecked,
      type,
      name,
    ) {
      element.name = "";
      null != type &&
      "function" !== typeof type &&
      "symbol" !== typeof type &&
      "boolean" !== typeof type
        ? (element.type = type)
        : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if ((0 === value && "" === element.value) || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) &&
            (element.value = "" + getToStringValue(value));
      else
        ("submit" !== type && "reset" !== type) ||
          element.removeAttribute("value");
      null != value
        ? setDefaultValue(element, type, getToStringValue(value))
        : null != defaultValue
          ? setDefaultValue(element, type, getToStringValue(defaultValue))
          : null != lastDefaultValue && element.removeAttribute("value");
      null == checked &&
        null != defaultChecked &&
        (element.defaultChecked = !!defaultChecked);
      null != checked &&
        (element.checked =
          checked &&
          "function" !== typeof checked &&
          "symbol" !== typeof checked);
      null != name &&
      "function" !== typeof name &&
      "symbol" !== typeof name &&
      "boolean" !== typeof name
        ? (element.name = "" + getToStringValue(name))
        : element.removeAttribute("name");
    }
    function initInput(
      element,
      value,
      defaultValue,
      checked,
      defaultChecked,
      type,
      name,
      isHydrating,
    ) {
      null != type &&
        "function" !== typeof type &&
        "symbol" !== typeof type &&
        "boolean" !== typeof type &&
        (element.type = type);
      if (null != value || null != defaultValue) {
        if (
          !(
            ("submit" !== type && "reset" !== type) ||
            (void 0 !== value && null !== value)
          )
        ) {
          track(element);
          return;
        }
        defaultValue =
          null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked =
        "function" !== typeof checked &&
        "symbol" !== typeof checked &&
        !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name &&
        "function" !== typeof name &&
        "symbol" !== typeof name &&
        "boolean" !== typeof name &&
        (element.name = name);
      track(element);
    }
    function setDefaultValue(node, type, value) {
      ("number" === type && getActiveElement(node.ownerDocument) === node) ||
        node.defaultValue === "" + value ||
        (node.defaultValue = "" + value);
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0; propValue < node.length; propValue++)
          ((i = multiple.hasOwnProperty("$" + node[propValue].value)),
            node[propValue].selected !== i && (node[propValue].selected = i),
            i &&
              setDefaultSelected &&
              (node[propValue].defaultSelected = true));
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = true;
            setDefaultSelected && (node[i].defaultSelected = true);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (
        null != value &&
        ((value = "" + getToStringValue(value)),
        value !== element.value && (element.value = value),
        null == defaultValue)
      ) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue =
        null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue &&
        "" !== children &&
        null !== children &&
        (element.value = children);
      track(element);
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          3 === firstChild.nodeType
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " ",
      ),
    );
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value
        ? isCustomProperty
          ? style.setProperty(styleName, "")
          : "float" === styleName
            ? (style.cssFloat = "")
            : (style[styleName] = "")
        : isCustomProperty
          ? style.setProperty(styleName, value)
          : "number" !== typeof value ||
              0 === value ||
              unitlessNumbers.has(styleName)
            ? "float" === styleName
              ? (style.cssFloat = value)
              : (style[styleName] = ("" + value).trim())
            : (style[styleName] = value + "px");
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node = node.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) ||
            (null != styles && styles.hasOwnProperty(styleName)) ||
            (0 === styleName.indexOf("--")
              ? node.setProperty(styleName, "")
              : "float" === styleName
                ? (node.cssFloat = "")
                : (node[styleName] = ""));
        for (var styleName$16 in styles)
          ((styleName = styles[styleName$16]),
            styles.hasOwnProperty(styleName$16) &&
              prevStyles[styleName$16] !== styleName &&
              setValueForStyle(node, styleName$16, styleName));
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) &&
            setValueForStyle(node, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"],
      ]),
      isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url)
        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
        : url;
    }
    function noop$1() {}
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement &&
        (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null,
      restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (
          ((target = internalInstance.stateNode), internalInstance.type)
        ) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance,
                  ) +
                  '"][type="radio"]',
              );
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              ) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name,
                  );
                }
              }
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              )
                ((otherNode = props[internalInstance]),
                  otherNode.form === target.form &&
                    updateValueIfChanged(otherNode));
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            ((internalInstance = props.value),
              null != internalInstance &&
                updateOptions(
                  target,
                  !!props.multiple,
                  internalInstance,
                  false,
                ));
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (
          ((isInsideEventHandler = false),
          null !== restoreTarget || null !== restoreQueue)
        )
          if (
            (flushSyncWork$1(),
            restoreTarget &&
              ((a = restoreTarget),
              (fn = restoreQueue),
              (restoreQueue = restoreTarget = null),
              restoreStateOfTarget(a),
              fn))
          )
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) ||
            ((inst = inst.type),
            (props = !(
              "button" === inst ||
              "input" === inst ||
              "select" === inst ||
              "textarea" === inst
            )));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode),
        );
      return stateNode;
    }
    var canUseDOM = !(
        "undefined" === typeof window ||
        "undefined" === typeof window.document ||
        "undefined" === typeof window.document.createElement
      ),
      passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function () {
            passiveBrowserEventsSupported = !0;
          },
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var root = null,
      startText = null,
      fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (
        start = 0;
        start < startLength && startValue[start] === endValue[start];
        start++
      );
      var minEnd = startLength - start;
      for (
        end = 1;
        end <= minEnd &&
        startValue[startLength - end] === endValue[endLength - end];
        end++
      );
      return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent
        ? ((nativeEvent = nativeEvent.charCode),
          0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
        : (nativeEvent = keyCode);
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(
        reactName,
        reactEventType,
        targetInst,
        nativeEvent,
        nativeEventTarget,
      ) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) &&
            ((reactName = Interface[propName]),
            (this[propName] = reactName
              ? reactName(nativeEvent)
              : nativeEvent[propName]));
        this.isDefaultPrevented = (
          null != nativeEvent.defaultPrevented
            ? nativeEvent.defaultPrevented
            : false === nativeEvent.returnValue
        )
          ? functionThatReturnsTrue
          : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event &&
            (event.preventDefault
              ? event.preventDefault()
              : "unknown" !== typeof event.returnValue &&
                (event.returnValue = false),
            (this.isDefaultPrevented = functionThatReturnsTrue));
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event &&
            (event.stopPropagation
              ? event.stopPropagation()
              : "unknown" !== typeof event.cancelBubble &&
                (event.cancelBubble = true),
            (this.isPropagationStopped = functionThatReturnsTrue));
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue,
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0,
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget
            ? event.fromElement === event.srcElement
              ? event.toElement
              : event.fromElement
            : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent &&
            (lastMouseEvent && "mousemove" === event.type
              ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                (lastMovementY = event.screenY - lastMouseEvent.screenY))
              : (lastMovementY = lastMovementX = 0),
            (lastMouseEvent = event));
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        },
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0,
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event
            ? event.clipboardData
            : window.clipboardData;
        },
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
      SyntheticCompositionEvent = createSyntheticEvent(
        CompositionEventInterface,
      ),
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified",
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta",
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey",
      };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState
        ? nativeEvent.getModifierState(keyArg)
        : (keyArg = modifierKeyToProp[keyArg])
          ? !!nativeEvent[keyArg]
          : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type
            ? ((nativeEvent = getEventCharCode(nativeEvent)),
              13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
            : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
              ? translateToKey[nativeEvent.keyCode] || "Unidentified"
              : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type
            ? event.keyCode
            : 0;
        },
        which: function (event) {
          return "keypress" === event.type
            ? getEventCharCode(event)
            : "keydown" === event.type || "keyup" === event.type
              ? event.keyCode
              : 0;
        },
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0,
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState,
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0,
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event
            ? event.deltaX
            : "wheelDeltaX" in event
              ? -event.wheelDeltaX
              : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event
            ? event.deltaY
            : "wheelDeltaY" in event
              ? -event.wheelDeltaY
              : "wheelDelta" in event
                ? -event.wheelDelta
                : 0;
        },
        deltaZ: 0,
        deltaMode: 0,
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0,
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM &&
      "documentMode" in document &&
      (documentMode = document.documentMode);
    var canUseTextInputEvent =
        canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData =
        canUseDOM &&
        (!canUseCompositionEvent ||
          (documentMode && 8 < documentMode && 11 >= documentMode)),
      SPACEBAR_CHAR = String.fromCharCode(32),
      hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent
        ? nativeEvent.data
        : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return (
            (domEventName = nativeEvent.data),
            domEventName === SPACEBAR_CHAR && hasSpaceKeypress
              ? null
              : domEventName
          );
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName ||
          (!canUseCompositionEvent &&
            isFallbackCompositionEnd(domEventName, nativeEvent))
          ? ((domEventName = getData()),
            (fallbackText = startText = root = null),
            (isComposing = false),
            domEventName)
          : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(
              nativeEvent.ctrlKey ||
              nativeEvent.altKey ||
              nativeEvent.metaKey
            ) ||
            (nativeEvent.ctrlKey && nativeEvent.altKey)
          ) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale
            ? null
            : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true,
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName
        ? !!supportedInputTypes[elem.type]
        : "textarea" === nodeName
          ? true
          : false;
    }
    function createAndAccumulateChangeEvent(
      dispatchQueue,
      inst,
      nativeEvent,
      target,
    ) {
      restoreTarget
        ? restoreQueue
          ? restoreQueue.push(target)
          : (restoreQueue = [target])
        : (restoreTarget = target);
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length &&
        ((nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target,
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null,
      activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM) {
      var JSCompiler_inline_result$jscomp$286;
      if (canUseDOM) {
        var isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          var element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 =
            "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported =
        JSCompiler_inline_result$jscomp$286 &&
        (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 &&
        (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
        (activeElementInst$1 = activeElement$1 = null));
    }
    function handlePropertyChange(nativeEvent) {
      if (
        "value" === nativeEvent.propertyName &&
        getInstIfValueChanged(activeElementInst$1)
      ) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent),
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(
      domEventName,
      target,
      targetInst,
    ) {
      "focusin" === domEventName
        ? (stopWatchingForValueChange(),
          (activeElement$1 = target),
          (activeElementInst$1 = targetInst),
          activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
        : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (
        "selectionchange" === domEventName ||
        "keyup" === domEventName ||
        "keydown" === domEventName
      )
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if (
        "object" !== typeof objA ||
        null === objA ||
        "object" !== typeof objB ||
        null === objB
      )
        return false;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (
          !hasOwnProperty.call(objB, currentKey) ||
          !objectIs(objA[currentKey], objB[currentKey])
        )
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset)
            return { node: node, offset: offset - root };
          root = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode
        ? outerNode === innerNode
          ? true
          : outerNode && 3 === outerNode.nodeType
            ? false
            : innerNode && 3 === innerNode.nodeType
              ? containsNode(outerNode, innerNode.parentNode)
              : "contains" in outerNode
                ? outerNode.contains(innerNode)
                : outerNode.compareDocumentPosition
                  ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                  : false
        : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo =
        null != containerInfo &&
        null != containerInfo.ownerDocument &&
        null != containerInfo.ownerDocument.defaultView
          ? containerInfo.ownerDocument.defaultView
          : window;
      for (
        var element = getActiveElement(containerInfo.document);
        element instanceof containerInfo.HTMLIFrameElement;
      ) {
        try {
          var JSCompiler_inline_result =
            "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return (
        nodeName &&
        (("input" === nodeName &&
          ("text" === elem.type ||
            "search" === elem.type ||
            "tel" === elem.type ||
            "url" === elem.type ||
            "password" === elem.type)) ||
          "textarea" === nodeName ||
          "true" === elem.contentEditable)
      );
    }
    var skipSelectionChangeEvent =
        canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = false;
    function constructSelectEvent(
      dispatchQueue,
      nativeEvent,
      nativeEventTarget,
    ) {
      var doc =
        nativeEventTarget.window === nativeEventTarget
          ? nativeEventTarget.document
          : 9 === nativeEventTarget.nodeType
            ? nativeEventTarget
            : nativeEventTarget.ownerDocument;
      mouseDown ||
        null == activeElement ||
        activeElement !== getActiveElement(doc) ||
        ((doc = activeElement),
        "selectionStart" in doc && hasSelectionCapabilities(doc)
          ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
          : ((doc = (
              (doc.ownerDocument && doc.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (doc = {
              anchorNode: doc.anchorNode,
              anchorOffset: doc.anchorOffset,
              focusNode: doc.focusNode,
              focusOffset: doc.focusOffset,
            })),
        (lastSelection && shallowEqual(lastSelection, doc)) ||
          ((lastSelection = doc),
          (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
          0 < doc.length &&
            ((nativeEvent = new SyntheticEvent(
              "onSelect",
              "select",
              null,
              nativeEvent,
              nativeEventTarget,
            )),
            dispatchQueue.push({ event: nativeEvent, listeners: doc }),
            (nativeEvent.target = activeElement))));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd"),
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM &&
      ((style = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete vendorPrefixes.animationend.animation,
        delete vendorPrefixes.animationiteration.animation,
        delete vendorPrefixes.animationstart.animation),
      "TransitionEvent" in window ||
        delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents =
        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " ",
        );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: true,
                  cancelable: true,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error,
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (
        var endIndex = concurrentQueuesIndex,
          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
        i < endIndex;
      ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        ((parent.childLanes |= lane),
          (alternate = parent.alternate),
          null !== alternate && (alternate.childLanes |= lane),
          22 === parent.tag &&
            ((sourceFiber = parent.stateNode),
            null === sourceFiber ||
              sourceFiber._visibility & 1 ||
              (isHidden = true)),
          (sourceFiber = parent),
          (parent = parent.return));
      return 3 === sourceFiber.tag
        ? ((parent = sourceFiber.stateNode),
          isHidden &&
            null !== update &&
            ((isHidden = 31 - clz32(lane)),
            (sourceFiber = parent.hiddenUpdates),
            (alternate = sourceFiber[isHidden]),
            null === alternate
              ? (sourceFiber[isHidden] = [update])
              : alternate.push(update),
            (update.lane = lane | 536870912)),
          parent)
        : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw (
          (nestedUpdateCount = 0),
          (rootWithNestedUpdates = null),
          Error(formatProdErrorMessage(185))
        );
      for (var parent = sourceFiber.return; null !== parent; )
        ((sourceFiber = parent), (parent = sourceFiber.return));
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress
        ? ((workInProgress = createFiberImplClass(
            current.tag,
            pendingProps,
            current.key,
            current.mode,
          )),
          (workInProgress.elementType = current.elementType),
          (workInProgress.type = current.type),
          (workInProgress.stateNode = current.stateNode),
          (workInProgress.alternate = current),
          (current.alternate = workInProgress))
        : ((workInProgress.pendingProps = pendingProps),
          (workInProgress.type = current.type),
          (workInProgress.flags = 0),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null));
      workInProgress.flags = current.flags & 65011712;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies =
        null === pendingProps
          ? null
          : {
              lanes: pendingProps.lanes,
              firstContext: pendingProps.firstContext,
            };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 65011714;
      var current = workInProgress.alternate;
      null === current
        ? ((workInProgress.childLanes = 0),
          (workInProgress.lanes = renderLanes),
          (workInProgress.child = null),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.memoizedProps = null),
          (workInProgress.memoizedState = null),
          (workInProgress.updateQueue = null),
          (workInProgress.dependencies = null),
          (workInProgress.stateNode = null))
        : ((workInProgress.childLanes = current.childLanes),
          (workInProgress.lanes = current.lanes),
          (workInProgress.child = current.child),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.memoizedProps = current.memoizedProps),
          (workInProgress.memoizedState = current.memoizedState),
          (workInProgress.updateQueue = current.updateQueue),
          (workInProgress.type = current.type),
          (renderLanes = current.dependencies),
          (workInProgress.dependencies =
            null === renderLanes
              ? null
              : {
                  lanes: renderLanes.lanes,
                  firstContext: renderLanes.firstContext,
                }));
      return workInProgress;
    }
    function createFiberFromTypeAndProps(
      type,
      key,
      pendingProps,
      owner,
      mode,
      lanes,
    ) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current,
        )
          ? 26
          : "html" === type || "head" === type || "body" === type
            ? 27
            : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return (
              (type = createFiberImplClass(31, pendingProps, key, mode)),
              (type.elementType = REACT_ACTIVITY_TYPE),
              (type.lanes = lanes),
              type
            );
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(
              pendingProps.children,
              mode,
              lanes,
              key,
            );
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return (
              (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
              (type.elementType = REACT_PROFILER_TYPE),
              (type.lanes = lanes),
              type
            );
          case REACT_SUSPENSE_TYPE:
            return (
              (type = createFiberImplClass(13, pendingProps, key, mode)),
              (type.elementType = REACT_SUSPENSE_TYPE),
              (type.lanes = lanes),
              type
            );
          case REACT_SUSPENSE_LIST_TYPE:
            return (
              (type = createFiberImplClass(19, pendingProps, key, mode)),
              (type.elementType = REACT_SUSPENSE_LIST_TYPE),
              (type.lanes = lanes),
              type
            );
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(
                130,
                null === type ? "null" : typeof type,
                "",
              ),
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode,
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation,
      };
      return mode;
    }
    var CapturedStacks = new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source),
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source),
      };
    }
    var forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "";
    function pushTreeFork(workInProgress, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - (baseLength % 5);
        length = (
          baseIdWithLeadingBit &
          ((1 << numberOfOverflowBits) - 1)
        ).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId =
          (1 << (32 - clz32(totalChildren) + baseLength)) |
          (index << baseLength) |
          baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else
        ((treeContextId =
          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
          (treeContextOverflow = workInProgress));
    }
    function pushMaterializedTreeId(workInProgress) {
      null !== workInProgress.return &&
        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider; )
        ((treeForkProvider = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null),
          (treeForkCount = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null));
      for (; workInProgress === treeContextProvider; )
        ((treeContextProvider = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextOverflow = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextId = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null));
    }
    function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress;
    }
    var hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = false,
      hydrationErrors = null,
      rootOrSingletonContext = false,
      HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1]
            ? "text"
            : "HTML",
          "",
        ),
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode,
        type = fiber.type,
        props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true,
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          (listenToNonDelegatedEvent("invalid", instance),
            initTextarea(
              instance,
              props.value,
              props.defaultValue,
              props.children,
            ));
      }
      type = props.children;
      ("string" !== typeof type &&
        "number" !== typeof type &&
        "bigint" !== typeof type) ||
      instance.textContent === "" + type ||
      true === props.suppressHydrationWarning ||
      checkForUnmatchedText(instance.textContent, type)
        ? (null != props.popover &&
            (listenToNonDelegatedEvent("beforetoggle", instance),
            listenToNonDelegatedEvent("toggle", instance)),
          null != props.onScroll &&
            listenToNonDelegatedEvent("scroll", instance),
          null != props.onScrollEnd &&
            listenToNonDelegatedEvent("scrollend", instance),
          null != props.onClick && (instance.onclick = noop$1),
          (instance = true))
        : (instance = false);
      instance || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating)
        return (popToNextHostParent(fiber), (isHydrating = true), false);
      var tag = fiber.tag,
        JSCompiler_temp;
      if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
        if ((JSCompiler_temp = 5 === tag))
          ((JSCompiler_temp = fiber.type),
            (JSCompiler_temp =
              !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
              shouldSetTextContent(fiber.type, fiber.memoizedProps)));
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp &&
        nextHydratableInstance &&
        throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance =
          getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance =
          getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag
          ? ((tag = nextHydratableInstance),
            isSingletonScope(fiber.type)
              ? ((fiber = previousHydratableOnEnteringScopedSingleton),
                (previousHydratableOnEnteringScopedSingleton = null),
                (nextHydratableInstance = fiber))
              : (nextHydratableInstance = tag))
          : (nextHydratableInstance = hydrationParentFiber
              ? getNextHydratable(fiber.stateNode.nextSibling)
              : null);
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors &&
        (null === workInProgressRootRecoverableErrors
          ? (workInProgressRootRecoverableErrors = queuedErrors)
          : workInProgressRootRecoverableErrors.push.apply(
              workInProgressRootRecoverableErrors,
              queuedErrors,
            ),
        (hydrationErrors = null));
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors
        ? (hydrationErrors = [error])
        : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null),
      currentlyRenderingFiber$1 = null,
      lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(
      parent,
      renderLanes,
      propagationRoot,
    ) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes
          ? ((parent.childLanes |= renderLanes),
            null !== alternate && (alternate.childLanes |= renderLanes))
          : null !== alternate &&
            (alternate.childLanes & renderLanes) !== renderLanes &&
            (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(
      workInProgress,
      contexts,
      renderLanes,
      forcePropagateEntireTree,
    ) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes,
                  workInProgress,
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(
            nextFiber,
            renderLanes,
            workInProgress,
          );
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(
      current,
      workInProgress,
      renderLanes,
      forcePropagateEntireTree,
    ) {
      current = null;
      for (
        var parent = workInProgress, isInsidePropagationBailout = false;
        null !== parent;
      ) {
        if (!isInsidePropagationBailout)
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) ||
              (null !== current
                ? current.push(context)
                : (current = [context]));
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !==
            parent.memoizedState.memoizedState &&
            (null !== current
              ? current.push(HostTransitionContext)
              : (current = [HostTransitionContext]));
        }
        parent = parent.return;
      }
      null !== current &&
        propagateContextChanges(
          workInProgress,
          current,
          renderLanes,
          forcePropagateEntireTree,
        );
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (
        currentDependencies = currentDependencies.firstContext;
        null !== currentDependencies;
      ) {
        if (
          !objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue,
          )
        )
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber$1 = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context: context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal =
        "undefined" !== typeof AbortController
          ? AbortController
          : function () {
              var listeners = [],
                signal = (this.signal = {
                  aborted: false,
                  addEventListener: function (type, listener) {
                    listeners.push(listener);
                  },
                });
              this.abort = function () {
                signal.aborted = true;
                listeners.forEach(function (listener) {
                  return listener();
                });
              };
            },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
      };
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0,
      };
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount &&
        scheduleCallback$2(NormalPriority, function () {
          cache.controller.abort();
        });
    }
    var currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = (currentEntangledListeners = []);
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          },
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (
        0 === --currentEntangledPendingCount &&
        null !== currentEntangledListeners
      ) {
        null !== currentEntangledActionThenable &&
          (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          },
        };
      thenable.then(
        function () {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function (error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        },
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      globalMostRecentTransitionTime = now();
      "object" === typeof returnValue &&
        null !== returnValue &&
        "function" === typeof returnValue.then &&
        entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish &&
        prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender
        ? cacheResumedFromPreviousRender
        : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool
        ? push(resumedCache, resumedCache.current)
        : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool
        ? null
        : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460)),
      SuspenseyCommitException = Error(formatProdErrorMessage(474)),
      SuspenseActionException = Error(formatProdErrorMessage(542)),
      noopSuspenseyCommitThenable = { then: function () {} };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState, thenable, index) {
      index = thenableState[index];
      void 0 === index
        ? thenableState.push(thenable)
        : index !== thenable &&
          (thenable.then(noop$1, noop$1), (thenable = index));
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            (thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState
          );
        default:
          if ("string" === typeof thenable.status)
            thenable.then(noop$1, noop$1);
          else {
            thenableState = workInProgressRoot;
            if (
              null !== thenableState &&
              100 < thenableState.shellSuspendCounter
            )
              throw Error(formatProdErrorMessage(482));
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(
              function (fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function (error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              },
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw (
                (thenableState = thenable.reason),
                checkIfUseWrappedInAsyncCatch(thenableState),
                thenableState
              );
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        var init = lazyType._init;
        return init(lazyType._payload);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw ((suspendedThenable = x), SuspenseException);
        throw x;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (
        rejectedReason === SuspenseException ||
        rejectedReason === SuspenseActionException
      )
        throw Error(formatProdErrorMessage(483));
    }
    var thenableState$1 = null,
      thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber
            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
            : returnFiber,
        ),
      );
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions
            ? ((returnFiber.deletions = [childToDelete]),
              (returnFiber.flags |= 16))
            : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          (deleteChild(returnFiber, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling));
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          (null !== currentFirstChild.key
            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
            : existingChildren.set(currentFirstChild.index, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling));
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return ((newFiber.flags |= 1048576), lastPlacedIndex);
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return (
            (newIndex = newIndex.index),
            newIndex < lastPlacedIndex
              ? ((newFiber.flags |= 67108866), lastPlacedIndex)
              : newIndex
          );
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects &&
          null === newFiber.alternate &&
          (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return (
            (current = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes,
            )),
            (current.return = returnFiber),
            current
          );
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key,
          );
        if (
          null !== current &&
          (current.elementType === elementType ||
            ("object" === typeof elementType &&
              null !== elementType &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              resolveLazy(elementType) === current.type))
        )
          return (
            (current = useFiber(current, element.props)),
            coerceRef(current, element),
            (current.return = returnFiber),
            current
          );
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes,
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (
          null === current ||
          4 !== current.tag ||
          current.stateNode.containerInfo !== portal.containerInfo ||
          current.stateNode.implementation !== portal.implementation
        )
          return (
            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
            (current.return = returnFiber),
            current
          );
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return (
            (current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key,
            )),
            (current.return = returnFiber),
            current
          );
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes,
            )),
            (newChild.return = returnFiber),
            newChild
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes,
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                lanes
              );
            case REACT_PORTAL_TYPE:
              return (
                (newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes,
                )),
                (newChild.return = returnFiber),
                newChild
              );
            case REACT_LAZY_TYPE:
              return (
                (newChild = resolveLazy(newChild)),
                createChild(returnFiber, newChild, lanes)
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null,
              )),
              (newChild.return = returnFiber),
              newChild
            );
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return null !== key
            ? null
            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key
                ? updateElement(returnFiber, oldFiber, newChild, lanes)
                : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key
                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                : null;
            case REACT_LAZY_TYPE:
              return (
                (newChild = resolveLazy(newChild)),
                updateSlot(returnFiber, oldFiber, newChild, lanes)
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key
              ? null
              : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes,
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChild,
        lanes,
      ) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (existingChildren =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key,
                  ) || null),
                updateElement(returnFiber, existingChildren, newChild, lanes)
              );
            case REACT_PORTAL_TYPE:
              return (
                (existingChildren =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key,
                  ) || null),
                updatePortal(returnFiber, existingChildren, newChild, lanes)
              );
            case REACT_LAZY_TYPE:
              return (
                (newChild = resolveLazy(newChild)),
                updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                )
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (existingChildren = existingChildren.get(newIdx) || null),
              updateFragment(
                returnFiber,
                existingChildren,
                newChild,
                lanes,
                null,
              )
            );
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes,
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes,
      ) {
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null;
          null !== oldFiber && newIdx < newChildren.length;
          newIdx++
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes,
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            ((oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
              null !== oldFiber &&
                ((currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx,
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber)));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          newIdx < newChildren.length;
          newIdx++
        )
          ((nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes,
          )),
            null !== nextOldFiber &&
              (shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key,
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx,
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber)));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes,
      ) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null,
            step = newChildren.next();
          null !== oldFiber && !step.done;
          newIdx++, step = newChildren.next()
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            ((step = createChild(returnFiber, step.value, lanes)),
              null !== step &&
                ((currentFirstChild = placeChild(
                  step,
                  currentFirstChild,
                  newIdx,
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = step)
                  : (previousNewFiber.sibling = step),
                (previousNewFiber = step)));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          !step.done;
          newIdx++, step = newChildren.next()
        )
          ((step = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            step.value,
            lanes,
          )),
            null !== step &&
              (shouldTrackSideEffects &&
                null !== step.alternate &&
                oldFiber.delete(null === step.key ? newIdx : step.key),
              (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
              null === previousNewFiber
                ? (resultingFirstChild = step)
                : (previousNewFiber.sibling = step),
              (previousNewFiber = step)));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      ) {
        "object" === typeof newChild &&
          null !== newChild &&
          newChild.type === REACT_FRAGMENT_TYPE &&
          null === newChild.key &&
          (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling,
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children,
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (
                      currentFirstChild.elementType === key ||
                      ("object" === typeof key &&
                        null !== key &&
                        key.$$typeof === REACT_LAZY_TYPE &&
                        resolveLazy(key) === currentFirstChild.type)
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling,
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE
                  ? ((lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key,
                    )),
                    (lanes.return = returnFiber),
                    (returnFiber = lanes))
                  : ((lanes = createFiberFromTypeAndProps(
                      newChild.type,
                      newChild.key,
                      newChild.props,
                      null,
                      returnFiber.mode,
                      lanes,
                    )),
                    coerceRef(lanes, newChild),
                    (lanes.return = returnFiber),
                    (returnFiber = lanes));
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (
                      4 === currentFirstChild.tag &&
                      currentFirstChild.stateNode.containerInfo ===
                        newChild.containerInfo &&
                      currentFirstChild.stateNode.implementation ===
                        newChild.implementation
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling,
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        newChild.children || [],
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes,
                );
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return (
                (newChild = resolveLazy(newChild)),
                reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes,
                )
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key)
              throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes,
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
          ? ((newChild = "" + newChild),
            null !== currentFirstChild && 6 === currentFirstChild.tag
              ? (deleteRemainingChildren(
                  returnFiber,
                  currentFirstChild.sibling,
                ),
                (lanes = useFiber(currentFirstChild, newChild)),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : (deleteRemainingChildren(returnFiber, currentFirstChild),
                (lanes = createFiberFromText(
                  newChild,
                  returnFiber.mode,
                  lanes,
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes)),
            placeSingleChild(returnFiber))
          : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true),
      mountChildFibers = createChildReconciler(false),
      hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null,
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current &&
        (workInProgress.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null,
        });
    }
    function createUpdate(lane) {
      return { lane: lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending
          ? (update.next = update)
          : ((update.next = pending.next), (pending.next = update));
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (
        null !== current &&
        ((current = current.updateQueue), queue === current)
      ) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null,
            };
            null === newLast
              ? (newFirst = newLast = clone)
              : (newLast = newLast.next = clone);
            queue = queue.next;
          } while (null !== queue);
          null === newLast
            ? (newFirst = newLast = capturedUpdate)
            : (newLast = newLast.next = capturedUpdate);
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks,
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress
        ? (queue.firstBaseUpdate = capturedUpdate)
        : (workInProgress.next = capturedUpdate);
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(
      workInProgress$jscomp$0,
      props,
      instance$jscomp$0,
      renderLanes,
    ) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate
          ? (firstBaseUpdate = firstPendingUpdate)
          : (lastBaseUpdate.next = firstPendingUpdate);
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current &&
          ((current = current.updateQueue),
          (pendingQueue = current.lastBaseUpdate),
          pendingQueue !== lastBaseUpdate &&
            (null === pendingQueue
              ? (current.firstBaseUpdate = firstPendingUpdate)
              : (pendingQueue.next = firstPendingUpdate),
            (current.lastBaseUpdate = lastPendingUpdate)));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (
            isHiddenUpdate
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            0 !== updateLane &&
              updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction = true);
            null !== current &&
              (current = current.next =
                {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null,
                });
            a: {
              var workInProgress = workInProgress$jscomp$0,
                update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress = update.payload;
                  if ("function" === typeof workInProgress) {
                    newState = workInProgress.call(
                      instance,
                      newState,
                      updateLane,
                    );
                    break a;
                  }
                  newState = workInProgress;
                  break a;
                case 3:
                  workInProgress.flags = (workInProgress.flags & -65537) | 128;
                case 0:
                  workInProgress = update.payload;
                  updateLane =
                    "function" === typeof workInProgress
                      ? workInProgress.call(instance, newState, updateLane)
                      : workInProgress;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane &&
              ((workInProgress$jscomp$0.flags |= 64),
              isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
              (isHiddenUpdate = queue.callbacks),
              null === isHiddenUpdate
                ? (queue.callbacks = [updateLane])
                : isHiddenUpdate.push(updateLane));
          } else
            ((isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null,
            }),
              null === current
                ? ((firstPendingUpdate = current = isHiddenUpdate),
                  (lastPendingUpdate = newState))
                : (current = current.next = isHiddenUpdate),
              (lastBaseUpdate |= updateLane));
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
              break;
            else
              ((isHiddenUpdate = pendingQueue),
                (pendingQueue = isHiddenUpdate.next),
                (isHiddenUpdate.next = null),
                (queue.lastBaseUpdate = isHiddenUpdate),
                (queue.shared.pending = null));
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (
          updateQueue.callbacks = null, updateQueue = 0;
          updateQueue < callbacks.length;
          updateQueue++
        )
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary &&
        (null === current || null !== currentTreeHiddenStackCursor.current
          ? (shellBoundary = handler)
          : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag
        ? (push(suspenseStackCursor, suspenseStackCursor.current),
          push(suspenseHandlerStackCursor, fiber),
          null === shellBoundary && (shellBoundary = fiber))
        : reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (
            null !== state &&
            ((state = state.dehydrated),
            null === state ||
              isSuspenseInstancePending(state) ||
              isSuspenseInstanceFallback(state))
          )
            return node;
        } else if (
          19 === node.tag &&
          ("forwards" === node.memoizedProps.revealOrder ||
            "backwards" === node.memoizedProps.revealOrder ||
            "unstable_legacy-backwards" === node.memoizedProps.revealOrder ||
            "together" === node.memoizedProps.revealOrder)
        ) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    var renderLanes = 0,
      currentlyRenderingFiber = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = false,
      didScheduleRenderPhaseUpdateDuringThisPass = false,
      shouldDoubleInvokeUserFnsInHooksDEV = false,
      localIdCounter = 0,
      thenableIndexCounter = 0,
      thenableState = null,
      globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
      return true;
    }
    function renderWithHooks(
      current,
      workInProgress,
      Component,
      props,
      secondArg,
      nextRenderLanes,
    ) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress;
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H =
        null === current || null === current.memoizedState
          ? HooksDispatcherOnMount
          : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass &&
        (nextRenderLanes = renderWithHooksAgain(
          workInProgress,
          Component,
          props,
          secondArg,
        ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks =
        null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current ||
        didReceiveUpdate ||
        ((current = current.dependencies),
        null !== current &&
          checkIfContextChanged(current) &&
          (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable =
        "function" === typeof maybeThenable.then
          ? useThenable(maybeThenable)
          : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !==
        dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (
          workInProgress = workInProgress.memoizedState;
          null !== workInProgress;
        ) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      };
      null === workInProgressHook
        ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
        : (workInProgressHook = workInProgressHook.next = hook);
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook =
          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook =
        null === workInProgressHook
          ? currentlyRenderingFiber.memoizedState
          : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        ((workInProgressHook = nextWorkInProgressHook),
          (currentHook = nextCurrentHook));
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null,
        };
        null === workInProgressHook
          ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
              nextCurrentHook)
          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber;
      null ===
        (null === workInProgressHook
          ? index.memoizedState
          : workInProgressHook.next) &&
        ((index = index.alternate),
        (ReactSharedInternals.H =
          null === index || null === index.memoizedState
            ? HooksDispatcherOnMount
            : HooksDispatcherOnUpdate));
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current &&
          ((current = current.updateQueue),
          null !== current &&
            ((current = current.memoCache),
            null != current &&
              (memoCache = {
                data: current.data.map(function (array) {
                  return array.slice();
                }),
                index: 0,
              })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue &&
        ((updateQueue = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = updateQueue));
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (
          updateQueue = memoCache.data[memoCache.index] = Array(size),
            current = 0;
          current < size;
          current++
        )
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = (baseFirst = null),
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (
            updateLane !== update.lane
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              (null !== newBaseQueueLast &&
                (newBaseQueueLast = newBaseQueueLast.next =
                  {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null,
                  }),
                updateLane === currentEntangledLane &&
                  (didReadFromEntangledAsyncAction$60 = true));
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane &&
                (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              ((updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null,
              }),
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                    (baseFirst = pendingQueue))
                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                (currentlyRenderingFiber.lanes |= revertLane),
                (workInProgressRootSkippedLanes |= revertLane));
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV &&
              reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState
              ? update.eagerState
              : reducer(pendingQueue, updateLane);
          } else
            ((revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null,
            }),
              null === newBaseQueueLast
                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                  (baseFirst = pendingQueue))
                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
              (currentlyRenderingFiber.lanes |= updateLane),
              (workInProgressRootSkippedLanes |= updateLane));
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast
          ? (baseFirst = pendingQueue)
          : (newBaseQueueLast.next = newBaseQueueFirst);
        if (
          !objectIs(pendingQueue, hook.memoizedState) &&
          ((didReceiveUpdate = true),
          didReadFromEntangledAsyncAction$60 &&
            ((reducer = currentEntangledActionThenable), null !== reducer))
        )
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
        do
          ((newState = reducer(newState, update.action)),
            (update = update.next));
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot,
    ) {
      var fiber = currentlyRenderingFiber,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot,
      );
      snapshotChanged &&
        ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true));
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe,
      ]);
      if (
        hook.getSnapshot !== getSnapshot ||
        snapshotChanged ||
        (null !== workInProgressHook &&
          workInProgressHook.memoizedState.tag & 1)
      ) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot,
          ),
          null,
        );
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 ||
          0 !== (renderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot
        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = getSnapshot),
          (getSnapshot.stores = [fiber]))
        : ((renderedSnapshot = getSnapshot.stores),
          null === renderedSnapshot
            ? (getSnapshot.stores = [fiber])
            : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState,
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer,
      );
    }
    function dispatchActionState(
      fiber,
      actionQueue,
      setPendingState,
      setState,
      payload,
    ) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          },
        };
        null !== ReactSharedInternals.T
          ? setPendingState(true)
          : (actionNode.isTransition = false);
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState
          ? ((actionNode.next = actionQueue.pending = actionNode),
            runActionStateAction(actionQueue, actionNode))
          : ((actionNode.next = setPendingState.next),
            (actionQueue.pending = setPendingState.next = actionNode));
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          (null !== prevTransition &&
            null !== currentTransition.types &&
            (prevTransition.types = currentTransition.types),
            (ReactSharedInternals.T = prevTransition));
        }
      } else
        try {
          ((prevTransition = action(prevState, payload)),
            handleActionReturnValue(actionQueue, node, prevTransition));
        } catch (error$66) {
          onActionError(actionQueue, node, error$66);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
        ? returnValue.then(
            function (nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function (error) {
              return onActionError(actionQueue, node, error);
            },
          )
        : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode &&
        ((nextState = actionNode.next),
        nextState === actionNode
          ? (actionQueue.pending = null)
          : ((nextState = nextState.next),
            (actionNode.next = nextState),
            runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          ((actionNode.status = "rejected"),
            (actionNode.reason = error),
            notifyActionListeners(actionNode),
            (actionNode = actionNode.next));
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 =
                    nextHydratableInstance;
                  for (
                    var inRootOrSingleton = rootOrSingletonContext;
                    8 !== JSCompiler_inline_result$jscomp$0.nodeType;
                  ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling,
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 =
                    "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                      ? JSCompiler_inline_result$jscomp$0
                      : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling,
                  );
                  JSCompiler_inline_result =
                    "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp,
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result,
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue,
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null,
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState,
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer,
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (
        "object" === typeof currentStateHook &&
        null !== currentStateHook &&
        "function" === typeof currentStateHook.then
      )
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue,
        dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState &&
        ((currentlyRenderingFiber.flags |= 2048),
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null,
        ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst &&
        ((inst = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = inst));
      create = inst.lastEffect;
      null === create
        ? (inst.lastEffect = tag.next = tag)
        : ((deps = create.next),
          (create.next = tag),
          (tag.next = deps),
          (inst.lastEffect = tag));
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps,
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook &&
      null !== deps &&
      areHookInputsEqual(deps, currentHook.memoizedState.deps)
        ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
        : ((currentlyRenderingFiber.flags |= fiberFlags),
          (hook.memoizedState = pushSimpleEffect(
            1 | hookFlags,
            inst,
            create,
            deps,
          )));
    }
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        ((componentUpdateQueue = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
          (componentUpdateQueue.events = [payload]));
      else {
        var events = componentUpdateQueue.events;
        null === events
          ? (componentUpdateQueue.events = [payload])
          : events.push(payload);
      }
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref: ref, nextImpl: callback });
      return function () {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return (
          (create = create()),
          (ref.current = create),
          function () {
            ref.current = null;
          }
        );
    }
    function updateImperativeHandle(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(
        4,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps,
      );
    }
    function mountDebugValue() {}
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (
        void 0 === initialValue ||
        (0 !== (renderLanes & 1073741824) &&
          0 === (workInProgressRootRenderLanes & 261930))
      )
        return (hook.memoizedState = value);
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return (
          (hook = mountDeferredValueImpl(hook, value, initialValue)),
          objectIs(hook, prevValue) || (didReceiveUpdate = true),
          hook
        );
      if (
        0 === (renderLanes & 42) ||
        (0 !== (renderLanes & 1073741824) &&
          0 === (workInProgressRootRenderLanes & 261930))
      )
        return ((didReceiveUpdate = true), (hook.memoizedState = value));
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(
      fiber,
      queue,
      pendingState,
      finishedState,
      callback,
    ) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p =
        0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        if (
          null !== returnValue &&
          "object" === typeof returnValue &&
          "function" === typeof returnValue.then
        ) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState,
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber),
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber),
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function () {}, status: "rejected", reason: error },
          requestUpdateLane(),
        );
      } finally {
        ((ReactDOMSharedInternals.p = previousPriority),
          null !== prevTransition &&
            null !== currentTransition.types &&
            (prevTransition.types = currentTransition.types),
          (ReactSharedInternals.T = prevTransition));
      }
    }
    function noop() {}
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action
          ? noop
          : function () {
              requestFormReset$1(formFiber);
              return action(formData);
            },
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject,
        },
        next: null,
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState,
        },
        next: null,
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next &&
        (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane(),
      );
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 &&
              (scheduleUpdateOnFiber(root$69, provider, lane),
              entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane: lane,
        revertLane: 0,
        gesture: null,
        action: action,
        hasEagerState: false,
        eagerState: null,
        next: null,
      };
      isRenderPhaseUpdate(fiber)
        ? enqueueRenderPhaseUpdate(queue, action)
        : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
          null !== action &&
            (scheduleUpdateOnFiber(action, fiber, lane),
            entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        gesture: null,
        action: action,
        hasEagerState: false,
        eagerState: null,
        next: null,
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (
          0 === fiber.lanes &&
          (null === alternate || 0 === alternate.lanes) &&
          ((alternate = queue.lastRenderedReducer), null !== alternate)
        )
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return (
                enqueueUpdate$1(fiber, queue, update, 0),
                null === workInProgressRoot &&
                  finishQueueingConcurrentUpdates(),
                !1
              );
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return (
            scheduleUpdateOnFiber(action, fiber, lane),
            entangleTransitionUpdate(action, queue, lane),
            true
          );
      }
      return false;
    }
    function dispatchOptimisticSetState(
      fiber,
      throwIfDuringRender,
      queue,
      action,
    ) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action: action,
        hasEagerState: false,
        eagerState: null,
        next: null,
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        ((throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2,
        )),
          null !== throwIfDuringRender &&
            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return (
        fiber === currentlyRenderingFiber ||
        (null !== alternate && alternate === currentlyRenderingFiber)
      );
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass =
        didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext: readContext,
      use: use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError,
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
        readContext: readContext,
        use: use,
        useCallback: function (callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps,
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function (ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps,
          );
        },
        useLayoutEffect: function (create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function (create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function (nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function (reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState,
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer,
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function (initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return (hook.memoizedState = initialValue);
        },
        useState: function (initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue,
            dispatch = dispatchSetState.bind(
              null,
              currentlyRenderingFiber,
              queue,
            );
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function (value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function () {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false,
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function (
          subscribe,
          getSnapshot,
          getServerSnapshot,
        ) {
          var fiber = currentlyRenderingFiber,
            hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) ||
              pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe,
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot,
            ),
            null,
          );
          return getServerSnapshot;
        },
        useId: function () {
          var hook = mountWorkInProgressHook(),
            identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result =
              (
                idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
              ).toString(32) + JSCompiler_inline_result;
            identifierPrefix =
              "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result &&
              (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            ((JSCompiler_inline_result = globalClientIdCounter++),
              (identifierPrefix =
                "_" +
                identifierPrefix +
                "r_" +
                JSCompiler_inline_result.toString(32) +
                "_"));
          return (hook.memoizedState = identifierPrefix);
        },
        useHostTransitionStatus: useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function (passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null,
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue,
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache: useMemoCache,
        useCacheRefresh: function () {
          return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber,
          ));
        },
        useEffectEvent: function (callback) {
          var hook = mountWorkInProgressHook(),
            ref = { impl: callback };
          hook.memoizedState = ref;
          return function () {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        },
      },
      HooksDispatcherOnUpdate = {
        readContext: readContext,
        use: use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function () {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function (value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue,
          );
        },
        useTransition: function () {
          var booleanOrThenable = updateReducer(basicStateReducer)[0],
            start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable
              ? booleanOrThenable
              : useThenable(booleanOrThenable),
            start,
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus: useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function (passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache: useMemoCache,
        useCacheRefresh: updateRefresh,
      };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext: readContext,
      use: use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function () {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function (value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook
          ? mountDeferredValueImpl(hook, value, initialValue)
          : updateDeferredValueImpl(
              hook,
              currentHook.memoizedState,
              value,
              initialValue,
            );
      },
      useTransition: function () {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable
            ? booleanOrThenable
            : useThenable(booleanOrThenable),
          start,
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus: useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function (passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache: useMemoCache,
      useCacheRefresh: updateRefresh,
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      nextProps,
    ) {
      ctor = workInProgress.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps =
        null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
          ? ctor
          : assign({}, ctor, getDerivedStateFromProps);
      workInProgress.memoizedState = getDerivedStateFromProps;
      0 === workInProgress.lanes &&
        (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function (inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(),
          update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload &&
          (scheduleUpdateOnFiber(payload, inst, lane),
          entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function (inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(),
          update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload &&
          (scheduleUpdateOnFiber(payload, inst, lane),
          entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function (inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(),
          update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback &&
          (scheduleUpdateOnFiber(callback, inst, lane),
          entangleTransitions(callback, inst, lane));
      },
    };
    function checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextContext,
    ) {
      workInProgress = workInProgress.stateNode;
      return "function" === typeof workInProgress.shouldComponentUpdate
        ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
        : ctor.prototype && ctor.prototype.isPureReactComponent
          ? !shallowEqual(oldProps, newProps) ||
            !shallowEqual(oldState, newState)
          : true;
    }
    function callComponentWillReceiveProps(
      workInProgress,
      instance,
      newProps,
      nextContext,
    ) {
      workInProgress = instance.state;
      "function" === typeof instance.componentWillReceiveProps &&
        instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress &&
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null,
        );
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if ((Component = Component.defaultProps)) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] &&
            (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        var onUncaughtError = root.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function () {
          throw e$74;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null,
        });
      } catch (e$75) {
        setTimeout(function () {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function () {
        logUncaughtError(root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          logCaughtError(root, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst &&
        "function" === typeof inst.componentDidCatch &&
        (update.callback = function () {
          logCaughtError(root, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError &&
            (null === legacyErrorBoundariesThatAlreadyFailed
              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
              : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : "",
          });
        });
    }
    function throwException(
      root,
      returnFiber,
      sourceFiber,
      value,
      rootRenderLanes,
    ) {
      sourceFiber.flags |= 32768;
      if (
        null !== value &&
        "object" === typeof value &&
        "function" === typeof value.then
      ) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber &&
          propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true,
          );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return (
                null === shellBoundary
                  ? renderDidSuspendDelayIfPossible()
                  : null === sourceFiber.alternate &&
                    0 === workInProgressRootExitStatus &&
                    (workInProgressRootExitStatus = 3),
                (sourceFiber.flags &= -257),
                (sourceFiber.flags |= 65536),
                (sourceFiber.lanes = rootRenderLanes),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? (sourceFiber.updateQueue = new Set([value]))
                      : returnFiber.add(value),
                    attachPingListener(root, value, rootRenderLanes)),
                false
              );
            case 22:
              return (
                (sourceFiber.flags |= 65536),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? ((returnFiber = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([value]),
                        }),
                        (sourceFiber.updateQueue = returnFiber))
                      : ((sourceFiber = returnFiber.retryQueue),
                        null === sourceFiber
                          ? (returnFiber.retryQueue = new Set([value]))
                          : sourceFiber.add(value)),
                    attachPingListener(root, value, rootRenderLanes)),
                false
              );
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return (
          (returnFiber = suspenseHandlerStackCursor.current),
          null !== returnFiber
            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
              (returnFiber.flags |= 65536),
              (returnFiber.lanes = rootRenderLanes),
              value !== HydrationMismatchException &&
                ((root = Error(formatProdErrorMessage(422), { cause: value })),
                queueHydrationError(
                  createCapturedValueAtFiber(root, sourceFiber),
                )))
            : (value !== HydrationMismatchException &&
                ((returnFiber = Error(formatProdErrorMessage(423), {
                  cause: value,
                })),
                queueHydrationError(
                  createCapturedValueAtFiber(returnFiber, sourceFiber),
                )),
              (root = root.current.alternate),
              (root.flags |= 65536),
              (rootRenderLanes &= -rootRenderLanes),
              (root.lanes |= rootRenderLanes),
              (value = createCapturedValueAtFiber(value, sourceFiber)),
              (rootRenderLanes = createRootErrorUpdate(
                root.stateNode,
                value,
                rootRenderLanes,
              )),
              enqueueCapturedUpdate(root, rootRenderLanes),
              4 !== workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 2)),
          false
        );
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors
        ? (workInProgressRootConcurrentErrors = [wrapperError])
        : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return (
              (sourceFiber.flags |= 65536),
              (root = rootRenderLanes & -rootRenderLanes),
              (sourceFiber.lanes |= root),
              (root = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root,
              )),
              enqueueCapturedUpdate(sourceFiber, root),
              false
            );
          case 1:
            if (
              ((returnFiber = sourceFiber.type),
              (wrapperError = sourceFiber.stateNode),
              0 === (sourceFiber.flags & 128) &&
                ("function" === typeof returnFiber.getDerivedStateFromError ||
                  (null !== wrapperError &&
                    "function" === typeof wrapperError.componentDidCatch &&
                    (null === legacyErrorBoundariesThatAlreadyFailed ||
                      !legacyErrorBoundariesThatAlreadyFailed.has(
                        wrapperError,
                      )))))
            )
              return (
                (sourceFiber.flags |= 65536),
                (rootRenderLanes &= -rootRenderLanes),
                (sourceFiber.lanes |= rootRenderLanes),
                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value,
                ),
                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                false
              );
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
      didReceiveUpdate = false;
    function reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderLanes,
    ) {
      workInProgress.child =
        null === current
          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
          : reconcileChildFibers(
              workInProgress,
              current.child,
              nextChildren,
              renderLanes,
            );
    }
    function updateForwardRef(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    ) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      nextProps = renderWithHooks(
        current,
        workInProgress,
        Component,
        propsWithoutRef,
        ref,
        renderLanes,
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    ) {
      if (null === current) {
        var type = Component.type;
        if (
          "function" === typeof type &&
          !shouldConstruct(type) &&
          void 0 === type.defaultProps &&
          null === Component.compare
        )
          return (
            (workInProgress.tag = 15),
            (workInProgress.type = type),
            updateSimpleMemoComponent(
              current,
              workInProgress,
              type,
              nextProps,
              renderLanes,
            )
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress,
          workInProgress.mode,
          renderLanes,
        );
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return (workInProgress.child = current);
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (
          Component(prevProps, nextProps) &&
          current.ref === workInProgress.ref
        )
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes,
          );
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return (workInProgress.child = current);
    }
    function updateSimpleMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    ) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (
          shallowEqual(prevProps, nextProps) &&
          current.ref === workInProgress.ref
        )
          if (
            ((didReceiveUpdate = false),
            (workInProgress.pendingProps = nextProps = prevProps),
            checkScheduledUpdateOrContext(current, renderLanes))
          )
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return (
              (workInProgress.lanes = current.lanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
      }
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        nextProps,
        renderLanes,
      );
    }
    function updateOffscreenComponent(
      current,
      workInProgress,
      renderLanes,
      nextProps,
    ) {
      var nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
      null === current &&
        null === workInProgress.stateNode &&
        (workInProgress.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress.flags & 128)) {
          prevState =
            null !== prevState
              ? prevState.baseLanes | renderLanes
              : renderLanes;
          if (null !== current) {
            nextProps = workInProgress.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              ((nextChildren =
                nextChildren | nextProps.lanes | nextProps.childLanes),
                (nextProps = nextProps.sibling));
            nextProps = nextChildren & ~prevState;
          } else ((nextProps = 0), (workInProgress.child = null));
          return deferHiddenOffscreenComponent(
            current,
            workInProgress,
            prevState,
            renderLanes,
            nextProps,
          );
        }
        if (0 !== (renderLanes & 536870912))
          ((workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
            null !== current &&
              pushTransition(
                workInProgress,
                null !== prevState ? prevState.cachePool : null,
              ),
            null !== prevState
              ? pushHiddenContext(workInProgress, prevState)
              : reuseHiddenContextOnStack(),
            pushOffscreenSuspenseHandler(workInProgress));
        else
          return (
            (nextProps = workInProgress.lanes = 536870912),
            deferHiddenOffscreenComponent(
              current,
              workInProgress,
              null !== prevState
                ? prevState.baseLanes | renderLanes
                : renderLanes,
              renderLanes,
              nextProps,
            )
          );
      } else
        null !== prevState
          ? (pushTransition(workInProgress, prevState.cachePool),
            pushHiddenContext(workInProgress, prevState),
            reuseSuspenseHandlerOnStack(),
            (workInProgress.memoizedState = null))
          : (null !== current && pushTransition(workInProgress, null),
            reuseHiddenContextOnStack(),
            reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function bailoutOffscreenComponent(current, workInProgress) {
      (null !== current && 22 === current.tag) ||
        null !== workInProgress.stateNode ||
        (workInProgress.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        });
      return workInProgress.sibling;
    }
    function deferHiddenOffscreenComponent(
      current,
      workInProgress,
      nextBaseLanes,
      renderLanes,
      remainingChildLanes,
    ) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result =
        null === JSCompiler_inline_result
          ? null
          : {
              parent: CacheContext._currentValue,
              pool: JSCompiler_inline_result,
            };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result,
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current &&
        propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          true,
        );
      workInProgress.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress.mode,
      );
      nextProps.ref = workInProgress.ref;
      workInProgress.child = nextProps;
      nextProps.return = workInProgress;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes,
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountActivityChildren(
        workInProgress,
        workInProgress.pendingProps,
      );
      current.flags |= 2;
      popSuspenseHandler(workInProgress);
      workInProgress.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        didSuspend = 0 !== (workInProgress.flags & 128);
      workInProgress.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return (
              (current = mountActivityChildren(workInProgress, nextProps)),
              (workInProgress.lanes = 536870912),
              bailoutOffscreenComponent(null, current)
            );
          pushDehydratedActivitySuspenseHandler(workInProgress);
          (current = nextHydratableInstance)
            ? ((current = canHydrateHydrationBoundary(
                current,
                rootOrSingletonContext,
              )),
              (current =
                null !== current && "&" === current.data ? current : null),
              null !== current &&
                ((workInProgress.memoizedState = {
                  dehydrated: current,
                  treeContext:
                    null !== treeContextProvider
                      ? { id: treeContextId, overflow: treeContextOverflow }
                      : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (renderLanes = createFiberFromDehydratedFragment(current)),
                (renderLanes.return = workInProgress),
                (workInProgress.child = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null)))
            : (current = null);
          if (null === current) throw throwOnHydrationMismatch(workInProgress);
          workInProgress.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress);
        if (didSuspend)
          if (workInProgress.flags & 256)
            ((workInProgress.flags &= -257),
              (workInProgress = retryActivityComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes,
              )));
          else if (null !== workInProgress.memoizedState)
            ((workInProgress.child = current.child),
              (workInProgress.flags |= 128),
              (workInProgress = null));
          else throw Error(formatProdErrorMessage(558));
        else if (
          (didReceiveUpdate ||
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              false,
            ),
          (didSuspend = 0 !== (renderLanes & current.childLanes)),
          didReceiveUpdate || didSuspend)
        ) {
          nextProps = workInProgressRoot;
          if (
            null !== nextProps &&
            ((dehydrated = getBumpedLaneForHydration(nextProps, renderLanes)),
            0 !== dehydrated && dehydrated !== prevState.retryLane)
          )
            throw (
              (prevState.retryLane = dehydrated),
              enqueueConcurrentRenderForLane(current, dehydrated),
              scheduleUpdateOnFiber(nextProps, current, dehydrated),
              SelectiveHydrationException
            );
          renderDidSuspendDelayIfPossible();
          workInProgress = retryActivityComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes,
          );
        } else
          ((current = prevState.treeContext),
            (nextHydratableInstance = getNextHydratable(
              dehydrated.nextSibling,
            )),
            (hydrationParentFiber = workInProgress),
            (isHydrating = true),
            (hydrationErrors = null),
            (rootOrSingletonContext = false),
            null !== current &&
              restoreSuspendedTreeContext(workInProgress, current),
            (workInProgress = mountActivityChildren(workInProgress, nextProps)),
            (workInProgress.flags |= 4096));
        return workInProgress;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children,
      });
      current.ref = workInProgress.ref;
      workInProgress.child = current;
      current.return = workInProgress;
      return current;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref)
        null !== current &&
          null !== current.ref &&
          (workInProgress.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress.flags |= 4194816;
      }
    }
    function updateFunctionComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    ) {
      prepareToReadContext(workInProgress);
      Component = renderWithHooks(
        current,
        workInProgress,
        Component,
        nextProps,
        void 0,
        renderLanes,
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(
      current,
      workInProgress,
      nextProps,
      Component,
      secondArg,
      renderLanes,
    ) {
      prepareToReadContext(workInProgress);
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress,
        Component,
        nextProps,
        secondArg,
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    ) {
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        var context = emptyContextObject,
          contextType = Component.contextType;
        "object" === typeof contextType &&
          null !== contextType &&
          (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress.memoizedState =
          null !== context.state && void 0 !== context.state
            ? context.state
            : null;
        context.updater = classComponentUpdater;
        workInProgress.stateNode = context;
        context._reactInternals = workInProgress;
        context = workInProgress.stateNode;
        context.props = nextProps;
        context.state = workInProgress.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress);
        contextType = Component.contextType;
        context.context =
          "object" === typeof contextType && null !== contextType
            ? readContext(contextType)
            : emptyContextObject;
        context.state = workInProgress.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            contextType,
            nextProps,
          ),
          (context.state = workInProgress.memoizedState));
        "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof context.getSnapshotBeforeUpdate ||
          ("function" !== typeof context.UNSAFE_componentWillMount &&
            "function" !== typeof context.componentWillMount) ||
          ((contextType = context.state),
          "function" === typeof context.componentWillMount &&
            context.componentWillMount(),
          "function" === typeof context.UNSAFE_componentWillMount &&
            context.UNSAFE_componentWillMount(),
          contextType !== context.state &&
            classComponentUpdater.enqueueReplaceState(
              context,
              context.state,
              null,
            ),
          processUpdateQueue(workInProgress, nextProps, context, renderLanes),
          suspendIfUpdateReadFromEntangledAsyncAction(),
          (context.state = workInProgress.memoizedState));
        "function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps,
          oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context,
          contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 &&
          null !== contextType$jscomp$0 &&
          (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 =
          "function" === typeof getDerivedStateFromProps ||
          "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 ||
          ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof context.componentWillReceiveProps) ||
          ((unresolvedOldProps || oldContext !== contextType) &&
            callComponentWillReceiveProps(
              workInProgress,
              context,
              nextProps,
              contextType,
            ));
        hasForceUpdate = false;
        var oldState = workInProgress.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress, nextProps, context, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
          ? ("function" === typeof getDerivedStateFromProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                getDerivedStateFromProps,
                nextProps,
              ),
              (oldContext = workInProgress.memoizedState)),
            (oldProps =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                oldProps,
                nextProps,
                oldState,
                oldContext,
                contextType,
              ))
              ? (contextType$jscomp$0 ||
                  ("function" !== typeof context.UNSAFE_componentWillMount &&
                    "function" !== typeof context.componentWillMount) ||
                  ("function" === typeof context.componentWillMount &&
                    context.componentWillMount(),
                  "function" === typeof context.UNSAFE_componentWillMount &&
                    context.UNSAFE_componentWillMount()),
                "function" === typeof context.componentDidMount &&
                  (workInProgress.flags |= 4194308))
              : ("function" === typeof context.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = oldContext)),
            (context.props = nextProps),
            (context.state = oldContext),
            (context.context = contextType),
            (nextProps = oldProps))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (nextProps = false));
      } else {
        context = workInProgress.stateNode;
        cloneUpdateQueue(current, workInProgress);
        contextType = workInProgress.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(
          Component,
          contextType,
        );
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext &&
          null !== oldContext &&
          (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext =
          "function" === typeof unresolvedOldProps ||
          "function" === typeof context.getSnapshotBeforeUpdate) ||
          ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof context.componentWillReceiveProps) ||
          ((contextType !== getDerivedStateFromProps ||
            oldState !== oldProps) &&
            callComponentWillReceiveProps(
              workInProgress,
              context,
              nextProps,
              oldProps,
            ));
        hasForceUpdate = false;
        oldState = workInProgress.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress, nextProps, context, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        contextType !== getDerivedStateFromProps ||
        oldState !== newState ||
        hasForceUpdate ||
        (null !== current &&
          null !== current.dependencies &&
          checkIfContextChanged(current.dependencies))
          ? ("function" === typeof unresolvedOldProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                unresolvedOldProps,
                nextProps,
              ),
              (newState = workInProgress.memoizedState)),
            (contextType$jscomp$0 =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                contextType$jscomp$0,
                nextProps,
                oldState,
                newState,
                oldProps,
              ) ||
              (null !== current &&
                null !== current.dependencies &&
                checkIfContextChanged(current.dependencies)))
              ? (oldContext ||
                  ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                    "function" !== typeof context.componentWillUpdate) ||
                  ("function" === typeof context.componentWillUpdate &&
                    context.componentWillUpdate(nextProps, newState, oldProps),
                  "function" === typeof context.UNSAFE_componentWillUpdate &&
                    context.UNSAFE_componentWillUpdate(
                      nextProps,
                      newState,
                      oldProps,
                    )),
                "function" === typeof context.componentDidUpdate &&
                  (workInProgress.flags |= 4),
                "function" === typeof context.getSnapshotBeforeUpdate &&
                  (workInProgress.flags |= 1024))
              : ("function" !== typeof context.componentDidUpdate ||
                  (contextType === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 4),
                "function" !== typeof context.getSnapshotBeforeUpdate ||
                  (contextType === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 1024),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = newState)),
            (context.props = nextProps),
            (context.state = newState),
            (context.context = oldProps),
            (nextProps = contextType$jscomp$0))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (nextProps = false));
      }
      context = nextProps;
      markRef(current, workInProgress);
      nextProps = 0 !== (workInProgress.flags & 128);
      context || nextProps
        ? ((context = workInProgress.stateNode),
          (Component =
            nextProps &&
            "function" !== typeof Component.getDerivedStateFromError
              ? null
              : context.render()),
          (workInProgress.flags |= 1),
          null !== current && nextProps
            ? ((workInProgress.child = reconcileChildFibers(
                workInProgress,
                current.child,
                null,
                renderLanes,
              )),
              (workInProgress.child = reconcileChildFibers(
                workInProgress,
                null,
                Component,
                renderLanes,
              )))
            : reconcileChildren(
                current,
                workInProgress,
                Component,
                renderLanes,
              ),
          (workInProgress.memoizedState = context.state),
          (current = workInProgress.child))
        : (current = bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes,
          ));
      return current;
    }
    function mountHostRootWithoutHydrating(
      current,
      workInProgress,
      nextChildren,
      renderLanes,
    ) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null,
    };
    function mountSuspenseOffscreenState(renderLanes) {
      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(
      current,
      primaryTreeDidDefer,
      renderLanes,
    ) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        showFallback = false,
        didSuspend = 0 !== (workInProgress.flags & 128),
        JSCompiler_temp;
      (JSCompiler_temp = didSuspend) ||
        (JSCompiler_temp =
          null !== current && null === current.memoizedState
            ? false
            : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp &&
        ((showFallback = true), (workInProgress.flags &= -129));
      JSCompiler_temp = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback
            ? pushPrimaryTreeSuspenseHandler(workInProgress)
            : reuseSuspenseHandlerOnStack();
          (current = nextHydratableInstance)
            ? ((current = canHydrateHydrationBoundary(
                current,
                rootOrSingletonContext,
              )),
              (current =
                null !== current && "&" !== current.data ? current : null),
              null !== current &&
                ((workInProgress.memoizedState = {
                  dehydrated: current,
                  treeContext:
                    null !== treeContextProvider
                      ? { id: treeContextId, overflow: treeContextOverflow }
                      : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (renderLanes = createFiberFromDehydratedFragment(current)),
                (renderLanes.return = workInProgress),
                (workInProgress.child = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null)))
            : (current = null);
          if (null === current) throw throwOnHydrationMismatch(workInProgress);
          isSuspenseInstanceFallback(current)
            ? (workInProgress.lanes = 32)
            : (workInProgress.lanes = 536870912);
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return (
            reuseSuspenseHandlerOnStack(),
            (showFallback = workInProgress.mode),
            (nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback,
            )),
            (nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes,
              null,
            )),
            (nextPrimaryChildren.return = workInProgress),
            (nextProps.return = workInProgress),
            (nextPrimaryChildren.sibling = nextProps),
            (workInProgress.child = nextPrimaryChildren),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes,
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            bailoutOffscreenComponent(null, nextProps)
          );
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(
          workInProgress,
          nextPrimaryChildren,
        );
      }
      var prevState = current.memoizedState;
      if (
        null !== prevState &&
        ((nextPrimaryChildren = prevState.dehydrated),
        null !== nextPrimaryChildren)
      ) {
        if (didSuspend)
          workInProgress.flags & 256
            ? (pushPrimaryTreeSuspenseHandler(workInProgress),
              (workInProgress.flags &= -257),
              (workInProgress = retrySuspenseComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes,
              )))
            : null !== workInProgress.memoizedState
              ? (reuseSuspenseHandlerOnStack(),
                (workInProgress.child = current.child),
                (workInProgress.flags |= 128),
                (workInProgress = null))
              : (reuseSuspenseHandlerOnStack(),
                (nextPrimaryChildren = nextProps.fallback),
                (showFallback = workInProgress.mode),
                (nextProps = mountWorkInProgressOffscreenFiber(
                  { mode: "visible", children: nextProps.children },
                  showFallback,
                )),
                (nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  showFallback,
                  renderLanes,
                  null,
                )),
                (nextPrimaryChildren.flags |= 2),
                (nextProps.return = workInProgress),
                (nextPrimaryChildren.return = workInProgress),
                (nextProps.sibling = nextPrimaryChildren),
                (workInProgress.child = nextProps),
                reconcileChildFibers(
                  workInProgress,
                  current.child,
                  null,
                  renderLanes,
                ),
                (nextProps = workInProgress.child),
                (nextProps.memoizedState =
                  mountSuspenseOffscreenState(renderLanes)),
                (nextProps.childLanes = getRemainingWorkInPrimaryTree(
                  current,
                  JSCompiler_temp,
                  renderLanes,
                )),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                (workInProgress = bailoutOffscreenComponent(null, nextProps)));
        else if (
          (pushPrimaryTreeSuspenseHandler(workInProgress),
          isSuspenseInstanceFallback(nextPrimaryChildren))
        ) {
          JSCompiler_temp =
            nextPrimaryChildren.nextSibling &&
            nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes,
          );
        } else if (
          (didReceiveUpdate ||
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              false,
            ),
          (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
          didReceiveUpdate || JSCompiler_temp)
        ) {
          JSCompiler_temp = workInProgressRoot;
          if (
            null !== JSCompiler_temp &&
            ((nextProps = getBumpedLaneForHydration(
              JSCompiler_temp,
              renderLanes,
            )),
            0 !== nextProps && nextProps !== prevState.retryLane)
          )
            throw (
              (prevState.retryLane = nextProps),
              enqueueConcurrentRenderForLane(current, nextProps),
              scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
              SelectiveHydrationException
            );
          isSuspenseInstancePending(nextPrimaryChildren) ||
            renderDidSuspendDelayIfPossible();
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes,
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren)
            ? ((workInProgress.flags |= 192),
              (workInProgress.child = current.child),
              (workInProgress = null))
            : ((current = prevState.treeContext),
              (nextHydratableInstance = getNextHydratable(
                nextPrimaryChildren.nextSibling,
              )),
              (hydrationParentFiber = workInProgress),
              (isHydrating = true),
              (hydrationErrors = null),
              (rootOrSingletonContext = false),
              null !== current &&
                restoreSuspendedTreeContext(workInProgress, current),
              (workInProgress = mountSuspensePrimaryChildren(
                workInProgress,
                nextProps.children,
              )),
              (workInProgress.flags |= 4096));
        return workInProgress;
      }
      if (showFallback)
        return (
          reuseSuspenseHandlerOnStack(),
          (nextPrimaryChildren = nextProps.fallback),
          (showFallback = workInProgress.mode),
          (prevState = current.child),
          (digest = prevState.sibling),
          (nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children,
          })),
          (nextProps.subtreeFlags = prevState.subtreeFlags & 65011712),
          null !== digest
            ? (nextPrimaryChildren = createWorkInProgress(
                digest,
                nextPrimaryChildren,
              ))
            : ((nextPrimaryChildren = createFiberFromFragment(
                nextPrimaryChildren,
                showFallback,
                renderLanes,
                null,
              )),
              (nextPrimaryChildren.flags |= 2)),
          (nextPrimaryChildren.return = workInProgress),
          (nextProps.return = workInProgress),
          (nextProps.sibling = nextPrimaryChildren),
          (workInProgress.child = nextProps),
          bailoutOffscreenComponent(null, nextProps),
          (nextProps = workInProgress.child),
          (nextPrimaryChildren = current.child.memoizedState),
          null === nextPrimaryChildren
            ? (nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes))
            : ((showFallback = nextPrimaryChildren.cachePool),
              null !== showFallback
                ? ((prevState = CacheContext._currentValue),
                  (showFallback =
                    showFallback.parent !== prevState
                      ? { parent: prevState, pool: prevState }
                      : showFallback))
                : (showFallback = getSuspendedCache()),
              (nextPrimaryChildren = {
                baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
                cachePool: showFallback,
              })),
          (nextProps.memoizedState = nextPrimaryChildren),
          (nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes,
          )),
          (workInProgress.memoizedState = SUSPENDED_MARKER),
          bailoutOffscreenComponent(current.child, nextProps)
        );
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: nextProps.children,
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current &&
        ((JSCompiler_temp = workInProgress.deletions),
        null === JSCompiler_temp
          ? ((workInProgress.deletions = [current]),
            (workInProgress.flags |= 16))
          : JSCompiler_temp.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress.mode,
      );
      primaryChildren.return = workInProgress;
      return (workInProgress.child = primaryChildren);
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes,
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(
        workInProgress,
        workInProgress.pendingProps.children,
      );
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(
        fiber.return,
        renderLanes,
        propagationRoot,
      );
    }
    function initSuspenseListRenderState(
      workInProgress,
      isBackwards,
      tail,
      lastContentRow,
      tailMode,
      treeForkCount,
    ) {
      var renderState = workInProgress.memoizedState;
      null === renderState
        ? (workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode,
            treeForkCount: treeForkCount,
          })
        : ((renderState.isBackwards = isBackwards),
          (renderState.rendering = null),
          (renderState.renderingStartTime = 0),
          (renderState.last = lastContentRow),
          (renderState.tail = tail),
          (renderState.tailMode = tailMode),
          (renderState.treeForkCount = treeForkCount));
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current,
        shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback
        ? ((suspenseContext = (suspenseContext & 1) | 2),
          (workInProgress.flags |= 128))
        : (suspenseContext &= 1);
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      nextProps = isHydrating ? treeForkCount : 0;
      if (
        !shouldForceFallback &&
        null !== current &&
        0 !== (current.flags & 128)
      )
        a: for (current = workInProgress.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState &&
              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes; )
            ((current = renderLanes.alternate),
              null !== current &&
                null === findFirstSuspended(current) &&
                (revealOrder = renderLanes),
              (renderLanes = renderLanes.sibling));
          renderLanes = revealOrder;
          null === renderLanes
            ? ((revealOrder = workInProgress.child),
              (workInProgress.child = null))
            : ((revealOrder = renderLanes.sibling),
              (renderLanes.sibling = null));
          initSuspenseListRenderState(
            workInProgress,
            false,
            revealOrder,
            renderLanes,
            tailMode,
            nextProps,
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress,
            true,
            renderLanes,
            null,
            tailMode,
            nextProps,
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress,
            false,
            null,
            null,
            void 0,
            nextProps,
          );
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    ) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes))
        if (null !== current) {
          if (
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              false,
            ),
            0 === (renderLanes & workInProgress.childLanes))
          )
            return null;
        } else return null;
      if (null !== current && workInProgress.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling; )
          ((current = current.sibling),
            (renderLanes = renderLanes.sibling =
              createWorkInProgress(current, current.pendingProps)),
            (renderLanes.return = workInProgress));
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(
      current,
      workInProgress,
      renderLanes,
    ) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo,
          );
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache,
          );
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo,
          );
          break;
        case 10:
          pushProvider(
            workInProgress,
            workInProgress.type,
            workInProgress.memoizedProps.value,
          );
          break;
        case 31:
          if (null !== workInProgress.memoizedState)
            return (
              (workInProgress.flags |= 128),
              pushDehydratedActivitySuspenseHandler(workInProgress),
              null
            );
          break;
        case 13:
          var state$102 = workInProgress.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return (
                pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags |= 128),
                null
              );
            if (0 !== (renderLanes & workInProgress.child.childLanes))
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderLanes,
              );
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes,
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes & workInProgress.childLanes);
          state$102 ||
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              false,
            ),
            (state$102 = 0 !== (renderLanes & workInProgress.childLanes)));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress,
                renderLanes,
              );
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore &&
            ((didSuspendBefore.rendering = null),
            (didSuspendBefore.tail = null),
            (didSuspendBefore.lastEffect = null));
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return (
            (workInProgress.lanes = 0),
            updateOffscreenComponent(
              current,
              workInProgress,
              renderLanes,
              workInProgress.pendingProps,
            )
          );
        case 24:
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache,
          );
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress.pendingProps)
          didReceiveUpdate = true;
        else {
          if (
            !checkScheduledUpdateOrContext(current, renderLanes) &&
            0 === (workInProgress.flags & 128)
          )
            return (
              (didReceiveUpdate = false),
              attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress,
                renderLanes,
              )
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        ((didReceiveUpdate = false),
          isHydrating &&
            0 !== (workInProgress.flags & 1048576) &&
            pushTreeId(workInProgress, treeForkCount, workInProgress.index));
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: {
            var props = workInProgress.pendingProps;
            current = resolveLazy(workInProgress.elementType);
            workInProgress.type = current;
            if ("function" === typeof current)
              shouldConstruct(current)
                ? ((props = resolveClassComponentProps(current, props)),
                  (workInProgress.tag = 1),
                  (workInProgress = updateClassComponent(
                    null,
                    workInProgress,
                    current,
                    props,
                    renderLanes,
                  )))
                : ((workInProgress.tag = 0),
                  (workInProgress = updateFunctionComponent(
                    null,
                    workInProgress,
                    current,
                    props,
                    renderLanes,
                  )));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress.tag = 11;
                  workInProgress = updateForwardRef(
                    null,
                    workInProgress,
                    current,
                    props,
                    renderLanes,
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress.tag = 14;
                  workInProgress = updateMemoComponent(
                    null,
                    workInProgress,
                    current,
                    props,
                    renderLanes,
                  );
                  break a;
                }
              }
              workInProgress = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress, ""));
            }
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes,
          );
        case 1:
          return (
            (props = workInProgress.type),
            ($$typeof = resolveClassComponentProps(
              props,
              workInProgress.pendingProps,
            )),
            updateClassComponent(
              current,
              workInProgress,
              props,
              $$typeof,
              renderLanes,
            )
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo,
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress.pendingProps;
            var prevState = workInProgress.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, props, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress, CacheContext, props);
            props !== prevState.cache &&
              propagateContextChanges(
                workInProgress,
                [CacheContext],
                renderLanes,
                true,
              );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (
                ((prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache,
                }),
                (workInProgress.updateQueue.baseState = prevState),
                (workInProgress.memoizedState = prevState),
                workInProgress.flags & 256)
              ) {
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  props,
                  renderLanes,
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress,
                );
                queueHydrationError($$typeof);
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  props,
                  renderLanes,
                );
                break a;
              } else {
                current = workInProgress.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current =
                      "HTML" === current.nodeName
                        ? current.ownerDocument.body
                        : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes = mountChildFibers(
                  workInProgress,
                  null,
                  props,
                  renderLanes,
                );
                for (workInProgress.child = renderLanes; renderLanes; )
                  ((renderLanes.flags = (renderLanes.flags & -3) | 4096),
                    (renderLanes = renderLanes.sibling));
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderLanes,
                );
                break a;
              }
              reconcileChildren(current, workInProgress, props, renderLanes);
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return (
            markRef(current, workInProgress),
            null === current
              ? (renderLanes = getResource(
                  workInProgress.type,
                  null,
                  workInProgress.pendingProps,
                  null,
                ))
                ? (workInProgress.memoizedState = renderLanes)
                : isHydrating ||
                  ((renderLanes = workInProgress.type),
                  (current = workInProgress.pendingProps),
                  (props = getOwnerDocumentFromRootContainer(
                    rootInstanceStackCursor.current,
                  ).createElement(renderLanes)),
                  (props[internalInstanceKey] = workInProgress),
                  (props[internalPropsKey] = current),
                  setInitialProperties(props, renderLanes, current),
                  markNodeAsHoistable(props),
                  (workInProgress.stateNode = props))
              : (workInProgress.memoizedState = getResource(
                  workInProgress.type,
                  current.memoizedProps,
                  workInProgress.pendingProps,
                  current.memoizedState,
                )),
            null
          );
        case 27:
          return (
            pushHostContext(workInProgress),
            null === current &&
              isHydrating &&
              ((props = workInProgress.stateNode =
                resolveSingletonInstance(
                  workInProgress.type,
                  workInProgress.pendingProps,
                  rootInstanceStackCursor.current,
                )),
              (hydrationParentFiber = workInProgress),
              (rootOrSingletonContext = true),
              ($$typeof = nextHydratableInstance),
              isSingletonScope(workInProgress.type)
                ? ((previousHydratableOnEnteringScopedSingleton = $$typeof),
                  (nextHydratableInstance = getNextHydratable(
                    props.firstChild,
                  )))
                : (nextHydratableInstance = $$typeof)),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes,
            ),
            markRef(current, workInProgress),
            null === current && (workInProgress.flags |= 4194304),
            workInProgress.child
          );
        case 5:
          if (null === current && isHydrating) {
            if (($$typeof = props = nextHydratableInstance))
              ((props = canHydrateInstance(
                props,
                workInProgress.type,
                workInProgress.pendingProps,
                rootOrSingletonContext,
              )),
                null !== props
                  ? ((workInProgress.stateNode = props),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = getNextHydratable(
                      props.firstChild,
                    )),
                    (rootOrSingletonContext = false),
                    ($$typeof = true))
                  : ($$typeof = false));
            $$typeof || throwOnHydrationMismatch(workInProgress);
          }
          pushHostContext(workInProgress);
          $$typeof = workInProgress.type;
          prevState = workInProgress.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState)
            ? (props = null)
            : null !== nextState &&
              shouldSetTextContent($$typeof, nextState) &&
              (workInProgress.flags |= 32);
          null !== workInProgress.memoizedState &&
            (($$typeof = renderWithHooks(
              current,
              workInProgress,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes,
            )),
            (HostTransitionContext._currentValue = $$typeof));
          markRef(current, workInProgress);
          reconcileChildren(current, workInProgress, props, renderLanes);
          return workInProgress.child;
        case 6:
          if (null === current && isHydrating) {
            if ((current = renderLanes = nextHydratableInstance))
              ((renderLanes = canHydrateTextInstance(
                renderLanes,
                workInProgress.pendingProps,
                rootOrSingletonContext,
              )),
                null !== renderLanes
                  ? ((workInProgress.stateNode = renderLanes),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null),
                    (current = true))
                  : (current = false));
            current || throwOnHydrationMismatch(workInProgress);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return (
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo,
            ),
            (props = workInProgress.pendingProps),
            null === current
              ? (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  props,
                  renderLanes,
                ))
              : reconcileChildren(current, workInProgress, props, renderLanes),
            workInProgress.child
          );
        case 11:
          return updateForwardRef(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes,
          );
        case 7:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps,
              renderLanes,
            ),
            workInProgress.child
          );
        case 8:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes,
            ),
            workInProgress.child
          );
        case 12:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes,
            ),
            workInProgress.child
          );
        case 10:
          return (
            (props = workInProgress.pendingProps),
            pushProvider(workInProgress, workInProgress.type, props.value),
            reconcileChildren(
              current,
              workInProgress,
              props.children,
              renderLanes,
            ),
            workInProgress.child
          );
        case 9:
          return (
            ($$typeof = workInProgress.type._context),
            (props = workInProgress.pendingProps.children),
            prepareToReadContext(workInProgress),
            ($$typeof = readContext($$typeof)),
            (props = props($$typeof)),
            (workInProgress.flags |= 1),
            reconcileChildren(current, workInProgress, props, renderLanes),
            workInProgress.child
          );
        case 14:
          return updateMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes,
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes,
          );
        case 19:
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes,
          );
        case 31:
          return updateActivityComponent(current, workInProgress, renderLanes);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress,
            renderLanes,
            workInProgress.pendingProps,
          );
        case 24:
          return (
            prepareToReadContext(workInProgress),
            (props = readContext(CacheContext)),
            null === current
              ? (($$typeof = peekCacheFromPool()),
                null === $$typeof &&
                  (($$typeof = workInProgressRoot),
                  (prevState = createCache()),
                  ($$typeof.pooledCache = prevState),
                  prevState.refCount++,
                  null !== prevState &&
                    ($$typeof.pooledCacheLanes |= renderLanes),
                  ($$typeof = prevState)),
                (workInProgress.memoizedState = {
                  parent: props,
                  cache: $$typeof,
                }),
                initializeUpdateQueue(workInProgress),
                pushProvider(workInProgress, CacheContext, $$typeof))
              : (0 !== (current.lanes & renderLanes) &&
                  (cloneUpdateQueue(current, workInProgress),
                  processUpdateQueue(workInProgress, null, null, renderLanes),
                  suspendIfUpdateReadFromEntangledAsyncAction()),
                ($$typeof = current.memoizedState),
                (prevState = workInProgress.memoizedState),
                $$typeof.parent !== props
                  ? (($$typeof = { parent: props, cache: props }),
                    (workInProgress.memoizedState = $$typeof),
                    0 === workInProgress.lanes &&
                      (workInProgress.memoizedState =
                        workInProgress.updateQueue.baseState =
                          $$typeof),
                    pushProvider(workInProgress, CacheContext, props))
                  : ((props = prevState.cache),
                    pushProvider(workInProgress, CacheContext, props),
                    props !== $$typeof.cache &&
                      propagateContextChanges(
                        workInProgress,
                        [CacheContext],
                        renderLanes,
                        true,
                      ))),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes,
            ),
            workInProgress.child
          );
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress.tag));
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(
      workInProgress,
      type,
      oldProps,
      newProps,
      renderLanes,
    ) {
      if ((type = 0 !== (workInProgress.mode & 32))) type = false;
      if (type) {
        if (
          ((workInProgress.flags |= 16777216),
          (renderLanes & 335544128) === renderLanes)
        )
          if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
          else
            throw (
              (suspendedThenable = noopSuspenseyCommitThenable),
              SuspenseyCommitException
            );
      } else workInProgress.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress.flags &= -16777217;
      else if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
        if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
        else
          throw (
            (suspendedThenable = noopSuspenseyCommitThenable),
            SuspenseyCommitException
          );
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 &&
        ((retryQueue =
          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
        (workInProgress.lanes |= retryQueue),
        (workInProgressSuspendedRetryLanes |= retryQueue));
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              (null !== hasRenderedATailFallback.alternate &&
                (lastTailNode = hasRenderedATailFallback),
                (hasRenderedATailFallback = hasRenderedATailFallback.sibling));
            null === lastTailNode
              ? (renderState.tail = null)
              : (lastTailNode.sibling = null);
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              (null !== lastTailNode.alternate &&
                (lastTailNode$106 = lastTailNode),
                (lastTailNode = lastTailNode.sibling));
            null === lastTailNode$106
              ? hasRenderedATailFallback || null === renderState.tail
                ? (renderState.tail = null)
                : (renderState.tail.sibling = null)
              : (lastTailNode$106.sibling = null);
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout =
          null !== completedWork.alternate &&
          completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          ((newChildLanes |= child$107.lanes | child$107.childLanes),
            (subtreeFlags |= child$107.subtreeFlags & 65011712),
            (subtreeFlags |= child$107.flags & 65011712),
            (child$107.return = completedWork),
            (child$107 = child$107.sibling));
      else
        for (child$107 = completedWork.child; null !== child$107; )
          ((newChildLanes |= child$107.lanes | child$107.childLanes),
            (subtreeFlags |= child$107.subtreeFlags),
            (subtreeFlags |= child$107.flags),
            (child$107.return = completedWork),
            (child$107 = child$107.sibling));
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return (bubbleProperties(workInProgress), null);
        case 1:
          return (bubbleProperties(workInProgress), null);
        case 3:
          renderLanes = workInProgress.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== newProps &&
            (workInProgress.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes.pendingContext &&
            ((renderLanes.context = renderLanes.pendingContext),
            (renderLanes.pendingContext = null));
          if (null === current || null === current.child)
            popHydrationState(workInProgress)
              ? markUpdate(workInProgress)
              : null === current ||
                (current.memoizedState.isDehydrated &&
                  0 === (workInProgress.flags & 256)) ||
                ((workInProgress.flags |= 1024),
                upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress);
          return null;
        case 26:
          var type = workInProgress.type,
            nextResource = workInProgress.memoizedState;
          null === current
            ? (markUpdate(workInProgress),
              null !== nextResource
                ? (bubbleProperties(workInProgress),
                  preloadResourceAndSuspendIfNeeded(
                    workInProgress,
                    nextResource,
                  ))
                : (bubbleProperties(workInProgress),
                  preloadInstanceAndSuspendIfNeeded(
                    workInProgress,
                    type,
                    null,
                    newProps,
                    renderLanes,
                  )))
            : nextResource
              ? nextResource !== current.memoizedState
                ? (markUpdate(workInProgress),
                  bubbleProperties(workInProgress),
                  preloadResourceAndSuspendIfNeeded(
                    workInProgress,
                    nextResource,
                  ))
                : (bubbleProperties(workInProgress),
                  (workInProgress.flags &= -16777217))
              : ((current = current.memoizedProps),
                current !== newProps && markUpdate(workInProgress),
                bubbleProperties(workInProgress),
                preloadInstanceAndSuspendIfNeeded(
                  workInProgress,
                  type,
                  current,
                  newProps,
                  renderLanes,
                ));
          return null;
        case 27:
          popHostContext(workInProgress);
          renderLanes = rootInstanceStackCursor.current;
          type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress)
              ? prepareToHydrateHostInstance(workInProgress)
              : ((current = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes,
                )),
                (workInProgress.stateNode = current),
                markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress))
              prepareToHydrateHostInstance(workInProgress);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current,
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type,
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type,
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type,
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type,
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script>\x3c/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild,
                      );
                      break;
                    case "select":
                      nextResource =
                        "string" === typeof newProps.is
                          ? ownerDocument.createElement("select", {
                              is: newProps.is,
                            })
                          : ownerDocument.createElement("select");
                      newProps.multiple
                        ? (nextResource.multiple = true)
                        : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource =
                        "string" === typeof newProps.is
                          ? ownerDocument.createElement(type, {
                              is: newProps.is,
                            })
                          : ownerDocument.createElement(type);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress;
              nextResource[internalPropsKey] = newProps;
              a: for (
                ownerDocument = workInProgress.child;
                null !== ownerDocument;
              ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (
                  4 !== ownerDocument.tag &&
                  27 !== ownerDocument.tag &&
                  null !== ownerDocument.child
                ) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (
                    null === ownerDocument.return ||
                    ownerDocument.return === workInProgress
                  )
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress.stateNode = nextResource;
              a: switch (
                (setInitialProperties(nextResource, type, newProps), type)
              ) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress,
            workInProgress.type,
            null === current ? null : current.memoizedProps,
            workInProgress.pendingProps,
            renderLanes,
          );
          return null;
        case 6:
          if (current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (
              "string" !== typeof newProps &&
              null === workInProgress.stateNode
            )
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              renderLanes = workInProgress.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress;
              current =
                current.nodeValue === renderLanes ||
                (null !== newProps &&
                  true === newProps.suppressHydrationWarning) ||
                checkForUnmatchedText(current.nodeValue, renderLanes)
                  ? true
                  : false;
              current || throwOnHydrationMismatch(workInProgress, true);
            } else
              ((current =
                getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps,
                )),
                (current[internalInstanceKey] = workInProgress),
                (workInProgress.stateNode = current));
          }
          bubbleProperties(workInProgress);
          return null;
        case 31:
          renderLanes = workInProgress.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress);
            if (null !== renderLanes) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress;
              } else
                (resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4));
              bubbleProperties(workInProgress);
              current = false;
            } else
              ((renderLanes = upgradeHydrationErrorsToRecoverable()),
                null !== current &&
                  null !== current.memoizedState &&
                  (current.memoizedState.hydrationErrors = renderLanes),
                (current = true));
            if (!current) {
              if (workInProgress.flags & 256)
                return (popSuspenseHandler(workInProgress), workInProgress);
              popSuspenseHandler(workInProgress);
              return null;
            }
            if (0 !== (workInProgress.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (
            null === current ||
            (null !== current.memoizedState &&
              null !== current.memoizedState.dehydrated)
          ) {
            type = popHydrationState(workInProgress);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress;
              } else
                (resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4));
              bubbleProperties(workInProgress);
              type = false;
            } else
              ((type = upgradeHydrationErrorsToRecoverable()),
                null !== current &&
                  null !== current.memoizedState &&
                  (current.memoizedState.hydrationErrors = type),
                (type = true));
            if (!type) {
              if (workInProgress.flags & 256)
                return (popSuspenseHandler(workInProgress), workInProgress);
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128))
            return ((workInProgress.lanes = renderLanes), workInProgress);
          renderLanes = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes &&
            ((newProps = workInProgress.child),
            (type = null),
            null !== newProps.alternate &&
              null !== newProps.alternate.memoizedState &&
              null !== newProps.alternate.memoizedState.cachePool &&
              (type = newProps.alternate.memoizedState.cachePool.pool),
            (nextResource = null),
            null !== newProps.memoizedState &&
              null !== newProps.memoizedState.cachePool &&
              (nextResource = newProps.memoizedState.cachePool.pool),
            nextResource !== type && (newProps.flags |= 2048));
          renderLanes !== current &&
            renderLanes &&
            (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          return null;
        case 4:
          return (
            popHostContainer(),
            null === current &&
              listenToAllSupportedEvents(
                workInProgress.stateNode.containerInfo,
              ),
            bubbleProperties(workInProgress),
            null
          );
        case 10:
          return (
            popProvider(workInProgress.type),
            bubbleProperties(workInProgress),
            null
          );
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress.memoizedState;
          if (null === newProps)
            return (bubbleProperties(workInProgress), null);
          type = 0 !== (workInProgress.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, false);
            else {
              if (
                0 !== workInProgressRootExitStatus ||
                (null !== current && 0 !== (current.flags & 128))
              )
                for (current = workInProgress.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress.updateQueue = current;
                    scheduleRetryEffect(workInProgress, current);
                    workInProgress.subtreeFlags = 0;
                    current = renderLanes;
                    for (
                      renderLanes = workInProgress.child;
                      null !== renderLanes;
                    )
                      (resetWorkInProgress(renderLanes, current),
                        (renderLanes = renderLanes.sibling));
                    push(
                      suspenseStackCursor,
                      (suspenseStackCursor.current & 1) | 2,
                    );
                    isHydrating &&
                      pushTreeFork(workInProgress, newProps.treeForkCount);
                    return workInProgress.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail &&
                now() > workInProgressRootRenderTargetTime &&
                ((workInProgress.flags |= 128),
                (type = true),
                cutOffTailIfNeeded(newProps, false),
                (workInProgress.lanes = 4194304));
            }
          else {
            if (!type)
              if (
                ((current = findFirstSuspended(nextResource)), null !== current)
              ) {
                if (
                  ((workInProgress.flags |= 128),
                  (type = true),
                  (current = current.updateQueue),
                  (workInProgress.updateQueue = current),
                  scheduleRetryEffect(workInProgress, current),
                  cutOffTailIfNeeded(newProps, true),
                  null === newProps.tail &&
                    "hidden" === newProps.tailMode &&
                    !nextResource.alternate &&
                    !isHydrating)
                )
                  return (bubbleProperties(workInProgress), null);
              } else
                2 * now() - newProps.renderingStartTime >
                  workInProgressRootRenderTargetTime &&
                  536870912 !== renderLanes &&
                  ((workInProgress.flags |= 128),
                  (type = true),
                  cutOffTailIfNeeded(newProps, false),
                  (workInProgress.lanes = 4194304));
            newProps.isBackwards
              ? ((nextResource.sibling = workInProgress.child),
                (workInProgress.child = nextResource))
              : ((current = newProps.last),
                null !== current
                  ? (current.sibling = nextResource)
                  : (workInProgress.child = nextResource),
                (newProps.last = nextResource));
          }
          if (null !== newProps.tail)
            return (
              (current = newProps.tail),
              (newProps.rendering = current),
              (newProps.tail = current.sibling),
              (newProps.renderingStartTime = now()),
              (current.sibling = null),
              (renderLanes = suspenseStackCursor.current),
              push(
                suspenseStackCursor,
                type ? (renderLanes & 1) | 2 : renderLanes & 1,
              ),
              isHydrating &&
                pushTreeFork(workInProgress, newProps.treeForkCount),
              current
            );
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(),
            (newProps = null !== workInProgress.memoizedState),
            null !== current
              ? (null !== current.memoizedState) !== newProps &&
                (workInProgress.flags |= 8192)
              : newProps && (workInProgress.flags |= 8192),
            newProps
              ? 0 !== (renderLanes & 536870912) &&
                0 === (workInProgress.flags & 128) &&
                (bubbleProperties(workInProgress),
                workInProgress.subtreeFlags & 6 &&
                  (workInProgress.flags |= 8192))
              : bubbleProperties(workInProgress),
            (renderLanes = workInProgress.updateQueue),
            null !== renderLanes &&
              scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
            (renderLanes = null),
            null !== current &&
              null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              (renderLanes = current.memoizedState.cachePool.pool),
            (newProps = null),
            null !== workInProgress.memoizedState &&
              null !== workInProgress.memoizedState.cachePool &&
              (newProps = workInProgress.memoizedState.cachePool.pool),
            newProps !== renderLanes && (workInProgress.flags |= 2048),
            null !== current && pop(resumedCache),
            null
          );
        case 24:
          return (
            (renderLanes = null),
            null !== current && (renderLanes = current.memoizedState.cache),
            workInProgress.memoizedState.cache !== renderLanes &&
              (workInProgress.flags |= 2048),
            popProvider(CacheContext),
            bubbleProperties(workInProgress),
            null
          );
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress.tag));
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return (
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 3:
          return (
            popProvider(CacheContext),
            popHostContainer(),
            (current = workInProgress.flags),
            0 !== (current & 65536) && 0 === (current & 128)
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 26:
        case 27:
        case 5:
          return (popHostContext(workInProgress), null);
        case 31:
          if (null !== workInProgress.memoizedState) {
            popSuspenseHandler(workInProgress);
            if (null === workInProgress.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              workInProgress)
            : null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              workInProgress)
            : null;
        case 19:
          return (pop(suspenseStackCursor), null);
        case 4:
          return (popHostContainer(), null);
        case 10:
          return (popProvider(workInProgress.type), null);
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(),
            null !== current && pop(resumedCache),
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 24:
          return (popProvider(CacheContext), null);
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState &&
            popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create,
                inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(
      flags,
      finishedWork,
      nearestMountedAncestor$jscomp$0,
    ) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
                  destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error,
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(
      current,
      nearestMountedAncestor,
      instance,
    ) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps,
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref
            ? (current.refCleanup = ref(instanceToUse))
            : (ref.current = instanceToUse);
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            ((current.refCleanup = null),
              (current = current.alternate),
              null != current && (current.refCleanup = null));
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src
              ? (instance.src = props.src)
              : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return (
        5 === fiber.tag ||
        3 === fiber.tag ||
        26 === fiber.tag ||
        (27 === fiber.tag && isSingletonScope(fiber.type)) ||
        4 === fiber.tag
      );
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (
          fiber = fiber.sibling;
          5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
        ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else ((fiber.child.return = fiber), (fiber = fiber.child));
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        ((node = node.stateNode),
          before
            ? (9 === parent.nodeType
                ? parent.body
                : "HTML" === parent.nodeName
                  ? parent.ownerDocument.body
                  : parent
              ).insertBefore(node, before)
            : ((before =
                9 === parent.nodeType
                  ? parent.body
                  : "HTML" === parent.nodeName
                    ? parent.ownerDocument.body
                    : parent),
              before.appendChild(node),
              (parent = parent._reactRootContainer),
              (null !== parent && void 0 !== parent) ||
                null !== before.onclick ||
                (before.onclick = noop$1)));
      else if (
        4 !== tag &&
        (27 === tag &&
          isSingletonScope(node.type) &&
          ((parent = node.stateNode), (before = null)),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            node = node.sibling;
          null !== node;
        )
          (insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            (node = node.sibling));
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        ((node = node.stateNode),
          before
            ? parent.insertBefore(node, before)
            : parent.appendChild(node));
      else if (
        4 !== tag &&
        (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNode(node, before, parent),
            node = node.sibling;
          null !== node;
        )
          (insertOrAppendPlacementNode(node, before, parent),
            (node = node.sibling));
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode,
        props = finishedWork.memoizedProps;
      try {
        for (
          var type = finishedWork.type, attributes = singleton.attributes;
          attributes.length;
        )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false,
      offscreenSubtreeWasHidden = false,
      needsFormReset = false,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null;
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root)
          var JSCompiler_temp = {
            start: root.selectionStart,
            end: root.selectionEnd,
          };
        else
          a: {
            JSCompiler_temp =
              ((JSCompiler_temp = root.ownerDocument) &&
                JSCompiler_temp.defaultView) ||
              window;
            var selection =
              JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset,
                focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                (JSCompiler_temp.nodeType, focusNode.nodeType);
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0,
                start = -1,
                end = -1,
                indexWithinAnchor = 0,
                indexWithinFocus = 0,
                node = root,
                parentNode = null;
              b: for (;;) {
                for (var next; ; ) {
                  node !== JSCompiler_temp ||
                    (0 !== anchorOffset && 3 !== node.nodeType) ||
                    (start = length + anchorOffset);
                  node !== focusNode ||
                    (0 !== selection && 3 !== node.nodeType) ||
                    (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (;;) {
                  if (node === root) break b;
                  parentNode === JSCompiler_temp &&
                    ++indexWithinAnchor === anchorOffset &&
                    (start = length);
                  parentNode === focusNode &&
                    ++indexWithinFocus === selection &&
                    (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp =
                -1 === start || -1 === end ? null : { start: start, end: end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp,
      };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (
          ((firstChild = nextEffect),
          (root = firstChild.child),
          0 !== (firstChild.subtreeFlags & 1028) && null !== root)
        )
          ((root.return = firstChild), (nextEffect = root));
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (
                  0 !== (root & 4) &&
                  ((root = firstChild.updateQueue),
                  (root = null !== root ? root.events : null),
                  null !== root)
                )
                  for (
                    JSCompiler_temp = 0;
                    JSCompiler_temp < root.length;
                    JSCompiler_temp++
                  )
                    ((anchorOffset = root[JSCompiler_temp]),
                      (anchorOffset.ref.impl = anchorOffset.nextImpl));
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root & 1024) && null !== focusNode) {
                  root = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset,
                    );
                    root = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode,
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error,
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root & 1024))
                  if (
                    ((root = firstChild.stateNode.containerInfo),
                    (JSCompiler_temp = root.nodeType),
                    9 === JSCompiler_temp)
                  )
                    clearContainerSparingly(root);
                  else if (1 === JSCompiler_temp)
                    switch (root.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root);
                        break;
                      default:
                        root.textContent = "";
                    }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root & 1024))
                  throw Error(formatProdErrorMessage(163));
            }
            root = firstChild.sibling;
            if (null !== root) {
              root.return = firstChild.return;
              nextEffect = root;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (((finishedRoot = finishedWork.stateNode), null === current))
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error,
                );
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps,
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate,
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139,
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (
            flags & 64 &&
            ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
          ) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current &&
            flags & 4 &&
            commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 &&
            ((finishedRoot = finishedWork.memoizedState),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.dehydrated),
              null !== finishedRoot &&
                ((finishedWork = retryDehydratedSuspenseBoundary.bind(
                  null,
                  finishedWork,
                )),
                registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags =
            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current =
              (null !== current && null !== current.memoizedState) ||
              offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) &&
            !prevOffscreenSubtreeWasHidden
              ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772),
                )
              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate &&
        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag &&
        ((alternate = fiber.stateNode),
        null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null,
      hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(
      finishedRoot,
      nearestMountedAncestor,
      parent,
    ) {
      for (parent = parent.child; null !== parent; )
        (commitDeletionEffectsOnFiber(
          finishedRoot,
          nearestMountedAncestor,
          parent,
        ),
          (parent = parent.sibling));
    }
    function commitDeletionEffectsOnFiber(
      finishedRoot,
      nearestMountedAncestor,
      deletedFiber,
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onCommitFiberUnmount
      )
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {}
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          deletedFiber.memoizedState
            ? deletedFiber.memoizedState.count--
            : deletedFiber.stateNode &&
              ((deletedFiber = deletedFiber.stateNode),
              deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) &&
            ((hostParent = deletedFiber.stateNode),
            (hostParentIsContainer = false));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType
                  ? hostParent.body
                  : "HTML" === hostParent.nodeName
                    ? hostParent.ownerDocument.body
                    : hostParent
                ).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error,
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error,
                );
              }
          break;
        case 18:
          null !== hostParent &&
            (hostParentIsContainer
              ? ((finishedRoot = hostParent),
                clearHydrationBoundary(
                  9 === finishedRoot.nodeType
                    ? finishedRoot.body
                    : "HTML" === finishedRoot.nodeName
                      ? finishedRoot.ownerDocument.body
                      : finishedRoot,
                  deletedFiber.stateNode,
                ),
                retryIfBlockedOn(finishedRoot))
              : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden ||
            commitHookEffectListUnmount(
              4,
              deletedFiber,
              nearestMountedAncestor,
            );
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          break;
        case 1:
          offscreenSubtreeWasHidden ||
            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
            (prevHostParent = deletedFiber.stateNode),
            "function" === typeof prevHostParent.componentWillUnmount &&
              safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent,
              ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          break;
        case 22:
          offscreenSubtreeWasHidden =
            (prevHostParent = offscreenSubtreeWasHidden) ||
            null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber,
          );
      }
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot))
      ) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState),
          null !== finishedRoot &&
            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
      )
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache &&
            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return (
            (finishedWork = finishedWork.stateNode),
            (retryCache = finishedWork._retryCache),
            null === retryCache &&
              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
            retryCache
          );
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i],
            root = root$jscomp$0,
            returnFiber = parentFiber,
            parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root = childToDelete.alternate;
          null !== root && (root.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          (commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
            (parentFiber = parentFiber.sibling));
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
            commitHookEffectListMount(3, finishedWork),
            commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          flags & 64 &&
            offscreenSubtreeIsHidden &&
            ((finishedWork = finishedWork.updateQueue),
            null !== finishedWork &&
              ((flags = finishedWork.callbacks),
              null !== flags &&
                ((current = finishedWork.shared.hiddenCallbacks),
                (finishedWork.shared.hiddenCallbacks =
                  null === current ? flags : current.concat(flags)))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource =
              null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot =
                      hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource =
                          hoistableRoot.getElementsByTagName("title")[0];
                        if (
                          !currentResource ||
                          currentResource[internalHoistableMarker] ||
                          currentResource[internalInstanceKey] ||
                          "http://www.w3.org/2000/svg" ===
                            currentResource.namespaceURI ||
                          currentResource.hasAttribute("itemprop")
                        )
                          ((currentResource =
                            hoistableRoot.createElement(flags)),
                            hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title"),
                            ));
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot,
                        ).get(flags + (current.href || ""));
                        if (maybeNodes)
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (
                              ((currentResource = maybeNodes[i]),
                              currentResource.getAttribute("href") ===
                                (null == current.href || "" === current.href
                                  ? null
                                  : current.href) &&
                                currentResource.getAttribute("rel") ===
                                  (null == current.rel ? null : current.rel) &&
                                currentResource.getAttribute("title") ===
                                  (null == current.title
                                    ? null
                                    : current.title) &&
                                currentResource.getAttribute("crossorigin") ===
                                  (null == current.crossOrigin
                                    ? null
                                    : current.crossOrigin))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (
                          (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot,
                          ).get(flags + (current.content || "")))
                        )
                          for (i = 0; i < maybeNodes.length; i++)
                            if (
                              ((currentResource = maybeNodes[i]),
                              currentResource.getAttribute("content") ===
                                (null == current.content
                                  ? null
                                  : "" + current.content) &&
                                currentResource.getAttribute("name") ===
                                  (null == current.name
                                    ? null
                                    : current.name) &&
                                currentResource.getAttribute("property") ===
                                  (null == current.property
                                    ? null
                                    : current.property) &&
                                currentResource.getAttribute("http-equiv") ===
                                  (null == current.httpEquiv
                                    ? null
                                    : current.httpEquiv) &&
                                currentResource.getAttribute("charset") ===
                                  (null == current.charSet
                                    ? null
                                    : current.charSet))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode,
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps,
                );
            else
              currentResource !== flags
                ? (null === currentResource
                    ? null !== current.stateNode &&
                      ((current = current.stateNode),
                      current.parentNode.removeChild(current))
                    : currentResource.count--,
                  null === flags
                    ? mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode,
                      )
                    : acquireResource(
                        hoistableRoot,
                        flags,
                        finishedWork.memoizedProps,
                      ))
                : null === flags &&
                  null !== finishedWork.stateNode &&
                  commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current.memoizedProps,
                  );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          null !== current &&
            flags & 4 &&
            commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps,
            );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 &&
            null != finishedWork.stateNode &&
            ((hoistableRoot = finishedWork.memoizedProps),
            commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot,
            ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (
            flags & 4 &&
            null !== current &&
            current.memoizedState.isDehydrated
          )
            try {
              retryIfBlockedOn(root.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset &&
            ((needsFormReset = false), recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo,
          );
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 &&
            (null !== finishedWork.memoizedState) !==
              (null !== current && null !== current.memoizedState) &&
            (globalMostRecentFallbackTime = now());
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState,
            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden =
            prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden =
            prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (
              root = finishedWork.stateNode,
                root._visibility = hoistableRoot
                  ? root._visibility & -2
                  : root._visibility | 1,
                hoistableRoot &&
                  (null === current ||
                    wasHidden ||
                    offscreenSubtreeIsHidden ||
                    offscreenSubtreeWasHidden ||
                    recursivelyTraverseDisappearLayoutEffects(finishedWork)),
                current = null,
                root = finishedWork;
              ;
            ) {
              if (5 === root.tag || 26 === root.tag) {
                if (null === current) {
                  wasHidden = current = root;
                  try {
                    if (
                      ((currentResource = wasHidden.stateNode), hoistableRoot)
                    )
                      ((maybeNodes = currentResource.style),
                        "function" === typeof maybeNodes.setProperty
                          ? maybeNodes.setProperty(
                              "display",
                              "none",
                              "important",
                            )
                          : (maybeNodes.display = "none"));
                    else {
                      i = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style,
                        display =
                          void 0 !== styleProp &&
                          null !== styleProp &&
                          styleProp.hasOwnProperty("display")
                            ? styleProp.display
                            : null;
                      i.style.display =
                        null == display || "boolean" === typeof display
                          ? ""
                          : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root.tag) {
                if (null === current) {
                  wasHidden = root;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot
                      ? ""
                      : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root.tag) {
                if (null === current) {
                  wasHidden = root;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot
                      ? hideOrUnhideDehydratedBoundary(instance, !0)
                      : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, !1);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (
                ((22 !== root.tag && 23 !== root.tag) ||
                  null === root.memoizedState ||
                  root === finishedWork) &&
                null !== root.child
              ) {
                root.child.return = root;
                root = root.child;
                continue;
              }
              if (root === finishedWork) break a;
              for (; null === root.sibling; ) {
                if (null === root.return || root.return === finishedWork)
                  break a;
                current === root && (current = null);
                root = root.return;
              }
              current === root && (current = null);
              root.sibling.return = root.return;
              root = root.sibling;
            }
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((current = flags.retryQueue),
              null !== current &&
                ((flags.retryQueue = null),
                attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          (recursivelyTraverseMutationEffects(root, finishedWork),
            commitReconciliationEffects(finishedWork));
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (
            var hostParentFiber, parentFiber = finishedWork.return;
            null !== parentFiber;
          ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode,
                before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 &&
                (setTextContent(parent$141, ""),
                (hostParentFiber.flags &= -33));
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo,
                before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143,
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          (commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
            (parentFiber = parentFiber.sibling));
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount &&
              safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance,
              );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState &&
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(
      finishedRoot$jscomp$0,
      parentFiber,
      includeWorkInProgressEffects,
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate,
          finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (
                    finishedRoot.shared.hiddenCallbacks = null,
                      finishedRoot = 0;
                    finishedRoot < hiddenCallbacks.length;
                    finishedRoot++
                  )
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects &&
              flags & 64 &&
              commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            includeWorkInProgressEffects &&
              null === current &&
              flags & 4 &&
              commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            includeWorkInProgressEffects &&
              flags & 4 &&
              commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
            includeWorkInProgressEffects &&
              flags & 4 &&
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState &&
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects,
              );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects,
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current &&
        null !== current.memoizedState &&
        null !== current.memoizedState.cachePool &&
        (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState &&
        null !== finishedWork.memoizedState.cachePool &&
        (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache &&
        (null != current && current.refCount++,
        null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate &&
        (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current &&
        (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(
      root,
      parentFiber,
      committedLanes,
      committedTransitions,
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          (commitPassiveMountOnFiber(
            root,
            parentFiber,
            committedLanes,
            committedTransitions,
          ),
            (parentFiber = parentFiber.sibling));
    }
    function commitPassiveMountOnFiber(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions,
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          flags & 2048 &&
            ((finishedRoot = null),
            null !== finishedWork.alternate &&
              (finishedRoot = finishedWork.alternate.memoizedState.cache),
            (finishedWork = finishedWork.memoizedState.cache),
            finishedWork !== finishedRoot &&
              (finishedWork.refCount++,
              null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps,
                id = _finishedWork$memoize2.id,
                onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit &&
                onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0,
                );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id = finishedWork.alternate;
          null !== finishedWork.memoizedState
            ? _finishedWork$memoize2._visibility & 2
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork,
                )
            : _finishedWork$memoize2._visibility & 2
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                )
              : ((_finishedWork$memoize2._visibility |= 2),
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  0 !== (finishedWork.subtreeFlags & 10256) || false,
                ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber,
      committedLanes$jscomp$0,
      committedTransitions$jscomp$0,
      includeWorkInProgressEffects,
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects &&
        (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          committedLanes = committedLanes$jscomp$0,
          committedTransitions = committedTransitions$jscomp$0,
          flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState
              ? instance._visibility & 2
                ? recursivelyTraverseReconnectPassiveEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions,
                    includeWorkInProgressEffects,
                  )
                : recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork,
                  )
              : ((instance._visibility |= 2),
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                ));
            includeWorkInProgressEffects &&
              flags & 2048 &&
              commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork,
              );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            );
            includeWorkInProgressEffects &&
              flags & 2048 &&
              commitCachePassiveMountEffect(
                finishedWork.alternate,
                finishedWork,
              );
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber,
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0,
            finishedWork = parentFiber,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
              );
              flags & 2048 &&
                commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork,
                );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
              );
              flags & 2048 &&
                commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork,
                );
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
              );
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(
      parentFiber,
      committedLanes,
      suspendedState,
    ) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          (accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState,
          ),
            (parentFiber = parentFiber.sibling));
    }
    function accumulateSuspenseyCommitOnFiber(
      fiber,
      committedLanes,
      suspendedState,
    ) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState,
          );
          fiber.flags & suspenseyCommitFlag &&
            null !== fiber.memoizedState &&
            suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps,
            );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState,
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            fiber.stateNode.containerInfo,
          );
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState,
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState &&
            ((previousHoistableRoot = fiber.alternate),
            null !== previousHoistableRoot &&
            null !== previousHoistableRoot.memoizedState
              ? ((previousHoistableRoot = suspenseyCommitFlag),
                (suspenseyCommitFlag = 16777216),
                recursivelyAccumulateSuspenseyCommit(
                  fiber,
                  committedLanes,
                  suspendedState,
                ),
                (suspenseyCommitFlag = previousHoistableRoot))
              : recursivelyAccumulateSuspenseyCommit(
                  fiber,
                  committedLanes,
                  suspendedState,
                ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState,
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (
        null !== previousFiber &&
        ((parentFiber = previousFiber.child), null !== parentFiber)
      ) {
        previousFiber.child = null;
        do
          ((previousFiber = parentFiber.sibling),
            (parentFiber.sibling = null),
            (parentFiber = previousFiber));
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber,
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          (commitPassiveUnmountOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling));
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 &&
            commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState &&
          instance._visibility & 2 &&
          (null === finishedWork.return || 13 !== finishedWork.return.tag)
            ? ((instance._visibility &= -3),
              recursivelyTraverseDisconnectPassiveEffects(finishedWork))
            : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber,
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i = deletions.stateNode;
            i._visibility & 2 &&
              ((i._visibility &= -3),
              recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
      deletedSubtreeRoot,
      nearestMountedAncestor,
    ) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (
              null !== fiber.memoizedState &&
              null !== fiber.memoizedState.cachePool
            ) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) ((cache.return = fiber), (nextEffect = cache));
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling,
              returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
        getCacheForType: function (resourceType) {
          var cache = readContext(CacheContext),
            cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType &&
            ((cacheForType = resourceType()),
            cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function () {
          return readContext(CacheContext).controller.signal;
        },
      },
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      executionContext = 0,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      workInProgressSuspendedReason = 0,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = false,
      workInProgressRootIsPrerendering = false,
      workInProgressRootDidAttachPingListener = false,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = 0,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = false,
      globalMostRecentFallbackTime = 0,
      globalMostRecentTransitionTime = 0,
      workInProgressRootRenderTargetTime = Infinity,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      pendingEffectsStatus = 0,
      pendingEffectsRoot = null,
      pendingFinishedWork = null,
      pendingEffectsLanes = 0,
      pendingEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      pendingRecoverableErrors = null,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes
        ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes
        : null !== ReactSharedInternals.T
          ? requestTransitionLane()
          : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) &&
            (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      if (
        (root === workInProgressRoot &&
          (2 === workInProgressSuspendedReason ||
            9 === workInProgressSuspendedReason)) ||
        null !== root.cancelPendingCommit
      )
        (prepareFreshStack(root, 0),
          markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false,
          ));
      markRootUpdated$1(root, lane);
      if (0 === (executionContext & 2) || root !== workInProgressRoot)
        (root === workInProgressRoot &&
          (0 === (executionContext & 2) &&
            (workInProgressRootInterleavedUpdatedLanes |= lane),
          4 === workInProgressRootExitStatus &&
            markRootSuspended(
              root,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false,
            )),
          ensureRootIsScheduled(root));
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6))
        throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice =
          (!forceSync &&
            0 === (lanes & 127) &&
            0 === (lanes & root$jscomp$0.expiredLanes)) ||
          checkIfRootIsPrerendering(root$jscomp$0, lanes),
        exitStatus = shouldTimeSlice
          ? renderRootConcurrent(root$jscomp$0, lanes)
          : renderRootSync(root$jscomp$0, lanes, true),
        renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering &&
            !shouldTimeSlice &&
            markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (
            renderWasConcurrent &&
            !isRenderConsistentWithExternalStores(forceSync)
          ) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              ((JSCompiler_inline_result =
                root$jscomp$0.pendingLanes & -536870913),
                (JSCompiler_inline_result =
                  0 !== JSCompiler_inline_result
                    ? JSCompiler_inline_result
                    : JSCompiler_inline_result & 536870912
                      ? 536870912
                      : 0));
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root.current.memoizedState.isDehydrated;
                wasRootDehydrated &&
                  (prepareFreshStack(root, JSCompiler_inline_result).flags |=
                    256);
                JSCompiler_inline_result = renderRootSync(
                  root,
                  JSCompiler_inline_result,
                  false,
                );
                if (2 !== JSCompiler_inline_result) {
                  if (
                    workInProgressRootDidAttachPingListener &&
                    !wasRootDehydrated
                  ) {
                    root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |=
                      renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent &&
                    (null === workInProgressRootRecoverableErrors
                      ? (workInProgressRootRecoverableErrors =
                          renderWasConcurrent)
                      : workInProgressRootRecoverableErrors.push.apply(
                          workInProgressRootRecoverableErrors,
                          renderWasConcurrent,
                        ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings,
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if (
              (lanes & 62914560) === lanes &&
              ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
              10 < exitStatus)
            ) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings,
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0,
                ),
                exitStatus,
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0,
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(
      root,
      finishedWork,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      lanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      didSkipSuspendedSiblings,
      exitStatus,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime,
    ) {
      root.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (
        suspendedCommitReason & 8192 ||
        16785408 === (suspendedCommitReason & 16785408)
      ) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$1,
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason,
        );
        var timeoutOffset =
          (lanes & 62914560) === lanes
            ? globalMostRecentFallbackTime - now()
            : (lanes & 4194048) === lanes
              ? globalMostRecentTransitionTime - now()
              : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset,
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime,
            ),
          );
          markRootSuspended(
            root,
            lanes,
            spawnedLane,
            !didSkipSuspendedSiblings,
          );
          return;
        }
      }
      commitRoot(
        root,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if (
          (0 === tag || 11 === tag || 15 === tag) &&
          node.flags & 16384 &&
          ((tag = node.updateQueue),
          null !== tag && ((tag = tag.stores), null !== tag))
        )
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i],
              getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return !1;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          ((tag.return = node), (node = tag));
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork)
              return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(
      root,
      suspendedLanes,
      spawnedLane,
      didAttemptEntireTree,
    ) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes),
          lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane &&
        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6)
        ? (flushSyncWorkAcrossRoots_impl(0), false)
        : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          ((interruptedWork = workInProgress),
            (lastContextDependency = currentlyRenderingFiber$1 = null),
            resetHooksOnUnwind(interruptedWork),
            (thenableState$1 = null),
            (thenableIndexCounter$1 = 0),
            (interruptedWork = workInProgress));
        for (; null !== interruptedWork; )
          (unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
            (interruptedWork = interruptedWork.return));
        workInProgress = null;
      }
    }
    function prepareFreshStack(root, lanes) {
      var timeoutHandle = root.timeoutHandle;
      -1 !== timeoutHandle &&
        ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
      timeoutHandle = root.cancelPendingCommit;
      null !== timeoutHandle &&
        ((root.cancelPendingCommit = null), timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes =
        workInProgressDeferredLane =
        workInProgressRootPingedLanes =
        workInProgressRootInterleavedUpdatedLanes =
        workInProgressRootSkippedLanes =
        workInProgressRootExitStatus =
          0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
        null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root.entangledLanes;
      if (0 !== allEntangledLanes)
        for (
          root = root.entanglements, allEntangledLanes &= lanes;
          0 < allEntangledLanes;
        ) {
          var index$4 = 31 - clz32(allEntangledLanes),
            lane = 1 << index$4;
          lanes |= root[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException ||
      thrownValue === SuspenseActionException
        ? ((thrownValue = getSuspendedThenable()),
          (workInProgressSuspendedReason = 3))
        : thrownValue === SuspenseyCommitException
          ? ((thrownValue = getSuspendedThenable()),
            (workInProgressSuspendedReason = 4))
          : (workInProgressSuspendedReason =
              thrownValue === SelectiveHydrationException
                ? 8
                : null !== thrownValue &&
                    "object" === typeof thrownValue &&
                    "function" === typeof thrownValue.then
                  ? 6
                  : 1);
      workInProgressThrownValue = thrownValue;
      null === workInProgress &&
        ((workInProgressRootExitStatus = 1),
        logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current),
        ));
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler
        ? true
        : (workInProgressRootRenderLanes & 4194048) ===
            workInProgressRootRenderLanes
          ? null === shellBoundary
            ? true
            : false
          : (workInProgressRootRenderLanes & 62914560) ===
                workInProgressRootRenderLanes ||
              0 !== (workInProgressRootRenderLanes & 536870912)
            ? handler === shellBoundary
            : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings ||
        ((workInProgressRootRenderLanes & 4194048) !==
          workInProgressRootRenderLanes &&
          null !== suspenseHandlerStackCursor.current) ||
        (workInProgressRootIsPrerendering = true);
      (0 === (workInProgressRootSkippedLanes & 134217727) &&
        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
        null === workInProgressRoot ||
        markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false,
        );
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      )
        ((workInProgressTransitions = null), prepareFreshStack(root, lanes));
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress,
              thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = !0);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                if (
                  shouldYieldForPrerendering &&
                  workInProgressRootIsPrerendering
                ) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                ((reason = workInProgressSuspendedReason),
                  (workInProgressSuspendedReason = 0),
                  (workInProgressThrownValue = null),
                  throwAndUnwindWorkLoop(
                    root,
                    unitOfWork,
                    thrownValue,
                    reason,
                  ));
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root, thrownValue$165);
        }
      while (1);
      lanes && root.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress &&
        ((workInProgressRoot = null),
        (workInProgressRootRenderLanes = 0),
        finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
        ? ((workInProgressTransitions = null),
          (workInProgressRootRenderTargetTime = now() + 500),
          prepareFreshStack(root, lanes))
        : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
            root,
            lanes,
          ));
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function () {
                  (2 !== workInProgressSuspendedReason &&
                    9 !== workInProgressSuspendedReason) ||
                    workInProgressRoot !== root ||
                    (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue)
                  ? ((workInProgressSuspendedReason = 0),
                    (workInProgressThrownValue = null),
                    replaySuspendedUnitOfWork(lanes))
                  : ((workInProgressSuspendedReason = 0),
                    (workInProgressThrownValue = null),
                    throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (
                      resource
                        ? preloadResource(resource)
                        : hostFiber.stateNode.complete
                    ) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber
                          ? ((workInProgress = returnFiber),
                            completeUnitOfWork(returnFiber))
                          : (workInProgress = null);
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(
        unitOfWork.alternate,
        unitOfWork,
        entangledRenderLanes,
      );
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork;
      var current = next.alternate;
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes,
          );
          break;
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes,
          );
          break;
        case 5:
          resetHooksOnUnwind(next);
        default:
          (unwindInterruptedWork(current, next),
            (next = workInProgress =
              resetWorkInProgress(next, entangledRenderLanes)),
            (next = beginWork(current, next, entangledRenderLanes)));
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
    }
    function throwAndUnwindWorkLoop(
      root,
      unitOfWork,
      thrownValue,
      suspendedReason,
    ) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (
          throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes,
          )
        ) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current),
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current),
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root = true;
        else if (
          workInProgressRootIsPrerendering ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        )
          root = false;
        else if (
          ((workInProgressRootDidSkipSuspendedSiblings = root = true),
          2 === suspendedReason ||
            9 === suspendedReason ||
            3 === suspendedReason ||
            6 === suspendedReason)
        )
          ((suspendedReason = suspenseHandlerStackCursor.current),
            null !== suspendedReason &&
              13 === suspendedReason.tag &&
              (suspendedReason.flags |= 16384));
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings,
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes,
        );
        if (null !== next) {
          workInProgress = next;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        next = unitOfWork.return;
        null !== next &&
          ((next.flags |= 32768),
          (next.subtreeFlags = 0),
          (next.deletions = null));
        if (
          !skipSiblings &&
          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
        ) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(
      root,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
    ) {
      root.cancelPendingCommit = null;
      do flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6))
        throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root.current)
          throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate =
          finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
        );
        root === workInProgressRoot &&
          ((workInProgress = workInProgressRoot = null),
          (workInProgressRootRenderLanes = 0));
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) ||
        0 !== (finishedWork.flags & 10256)
          ? ((root.callbackNode = null),
            (root.callbackPriority = 0),
            scheduleCallback$1(NormalPriority$1, function () {
              flushPassiveEffects();
              return null;
            }))
          : ((root.callbackNode = null), (root.callbackPriority = 0));
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            ((executionContext = spawnedLane),
              (ReactDOMSharedInternals.p = transitions),
              (ReactSharedInternals.T = recoverableErrors));
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (
          0 !== (finishedWork.subtreeFlags & 13878) ||
          rootMutationHasEffect
        ) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root);
            var priorSelectionInformation = selectionInformation,
              curFocusedElem = getActiveElementDeep(root.containerInfo),
              priorFocusedElem = priorSelectionInformation.focusedElem,
              priorSelectionRange = priorSelectionInformation.selectionRange;
            if (
              curFocusedElem !== priorFocusedElem &&
              priorFocusedElem &&
              priorFocusedElem.ownerDocument &&
              containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem,
              )
            ) {
              if (
                null !== priorSelectionRange &&
                hasSelectionCapabilities(priorFocusedElem)
              ) {
                var start = priorSelectionRange.start,
                  end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  ((priorFocusedElem.selectionStart = start),
                    (priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length,
                    )));
                else {
                  var doc = priorFocusedElem.ownerDocument || document,
                    win = (doc && doc.defaultView) || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(),
                      length = priorFocusedElem.textContent.length,
                      start$jscomp$0 = Math.min(
                        priorSelectionRange.start,
                        length,
                      ),
                      end$jscomp$0 =
                        void 0 === priorSelectionRange.end
                          ? start$jscomp$0
                          : Math.min(priorSelectionRange.end, length);
                    !selection.extend &&
                      start$jscomp$0 > end$jscomp$0 &&
                      ((curFocusedElem = end$jscomp$0),
                      (end$jscomp$0 = start$jscomp$0),
                      (start$jscomp$0 = curFocusedElem));
                    var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0,
                      ),
                      endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0,
                      );
                    if (
                      startMarker &&
                      endMarker &&
                      (1 !== selection.rangeCount ||
                        selection.anchorNode !== startMarker.node ||
                        selection.anchorOffset !== startMarker.offset ||
                        selection.focusNode !== endMarker.node ||
                        selection.focusOffset !== endMarker.offset)
                    ) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0
                        ? (selection.addRange(range),
                          selection.extend(endMarker.node, endMarker.offset))
                        : (range.setEnd(endMarker.node, endMarker.offset),
                          selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (
                selection = priorFocusedElem;
                (selection = selection.parentNode);
              )
                1 === selection.nodeType &&
                  doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop,
                  });
              "function" === typeof priorFocusedElem.focus &&
                priorFocusedElem.focus();
              for (
                priorFocusedElem = 0;
                priorFocusedElem < doc.length;
                priorFocusedElem++
              ) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            ((executionContext = prevExecutionContext),
              (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = rootMutationHasEffect));
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(
              root,
              finishedWork.alternate,
              finishedWork,
            );
          } finally {
            ((executionContext = prevExecutionContext),
              (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = rootHasLayoutEffect));
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) ||
        0 !== (finishedWork.flags & 10256)
          ? (pendingEffectsStatus = 5)
          : ((pendingEffectsStatus = 0),
            (pendingFinishedWork = pendingEffectsRoot = null),
            releaseRootPooledCache(root, root.pendingLanes));
        var remainingLanes = root.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (
          injectedHook &&
          "function" === typeof injectedHook.onCommitFiberRoot
        )
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128),
            );
          } catch (err) {}
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (
              var onRecoverableError = root.onRecoverableError, i = 0;
              i < recoverableErrors.length;
              i++
            ) {
              var recoverableError = recoverableErrors[i];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack,
              });
            }
          } finally {
            ((ReactSharedInternals.T = finishedWork),
              (ReactDOMSharedInternals.p = remainingLanes));
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root);
        remainingLanes = root.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42)
          ? root === rootWithNestedUpdates
            ? nestedUpdateCount++
            : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
          : (nestedUpdateCount = 0);
        flushSyncWorkAcrossRoots_impl(0);
      }
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) &&
        ((remainingLanes = root.pooledCache),
        null != remainingLanes &&
          ((root.pooledCache = null), releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root = pendingEffectsRoot,
        remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
        prevTransition = ReactSharedInternals.T,
        previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot,
          lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6))
          throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority,
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        if (
          injectedHook &&
          "function" === typeof injectedHook.onPostCommitFiberRoot
        )
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {}
        return !0;
      } finally {
        ((ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition),
          releaseRootPooledCache(root, remainingLanes));
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber &&
        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(
      sourceFiber,
      nearestMountedAncestor,
      error,
    ) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error,
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if (
              "function" ===
                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
              ("function" === typeof instance.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
            ) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance &&
                (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber,
                ),
                markRootUpdated$1(instance, 2),
                ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        ((threadIDs = pingCache.get(wakeable)),
          void 0 === threadIDs &&
            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs)));
      threadIDs.has(lanes) ||
        ((workInProgressRootDidAttachPingListener = true),
        threadIDs.add(lanes),
        (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
        wakeable.then(root, root));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      workInProgressRoot === root &&
        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
        (4 === workInProgressRootExitStatus ||
        (3 === workInProgressRootExitStatus &&
          (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes &&
          300 > now() - globalMostRecentFallbackTime)
          ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
          : (workInProgressRootPingedLanes |= pingedLanes),
        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
          (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber &&
        (markRootUpdated$1(boundaryFiber, retryLane),
        ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = false,
      mightHavePendingSyncWork = false,
      isFlushingWork = false,
      currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot &&
        null === root.next &&
        (null === lastScheduledRoot
          ? (firstScheduledRoot = lastScheduledRoot = root)
          : (lastScheduledRoot = lastScheduledRoot.next = root));
      mightHavePendingSyncWork = true;
      didScheduleMicrotask ||
        ((didScheduleMicrotask = true), scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$170.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$170.suspendedLanes,
                  pingedLanes = root$170.pingedLanes;
                JSCompiler_inline_result =
                  (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                JSCompiler_inline_result &=
                  pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result =
                  JSCompiler_inline_result & 201326741
                    ? (JSCompiler_inline_result & 201326741) | 1
                    : JSCompiler_inline_result
                      ? JSCompiler_inline_result | 2
                      : 0;
              }
              0 !== JSCompiler_inline_result &&
                ((didPerformSomeWork = true),
                performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            } else
              ((JSCompiler_inline_result = workInProgressRootRenderLanes),
                (JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot
                    ? JSCompiler_inline_result
                    : 0,
                  null !== root$170.cancelPendingCommit ||
                    -1 !== root$170.timeoutHandle,
                )),
                0 === (JSCompiler_inline_result & 3) ||
                  checkIfRootIsPrerendering(
                    root$170,
                    JSCompiler_inline_result,
                  ) ||
                  ((didPerformSomeWork = true),
                  performSyncWorkOnRoot(root$170, JSCompiler_inline_result)));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane &&
        shouldAttemptEagerTransition() &&
        (syncTransitionLanes = currentEventTransitionLane);
      for (
        var currentTime = now(), prev = null, root = firstScheduledRoot;
        null !== root;
      ) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes)
          ((root.next = null),
            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
            null === next && (lastScheduledRoot = prev));
        else if (
          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        )
          mightHavePendingSyncWork = true;
        root = next;
      }
      (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) ||
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (
        var suspendedLanes = root.suspendedLanes,
          pingedLanes = root.pingedLanes,
          expirationTimes = root.expirationTimes,
          lanes = root.pendingLanes & -62914561;
        0 < lanes;
      ) {
        var index$5 = 31 - clz32(lanes),
          lane = 1 << index$5,
          expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root,
        root === currentTime ? suspendedLanes : 0,
        null !== root.cancelPendingCommit || -1 !== root.timeoutHandle,
      );
      pingedLanes = root.callbackNode;
      if (
        0 === suspendedLanes ||
        (root === currentTime &&
          (2 === workInProgressSuspendedReason ||
            9 === workInProgressSuspendedReason)) ||
        null !== root.cancelPendingCommit
      )
        return (
          null !== pingedLanes &&
            null !== pingedLanes &&
            cancelCallback$1(pingedLanes),
          (root.callbackNode = null),
          (root.callbackPriority = 0)
        );
      if (
        0 === (suspendedLanes & 3) ||
        checkIfRootIsPrerendering(root, suspendedLanes)
      ) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return ((root.callbackNode = null), (root.callbackPriority = 0), null);
      var originalCallbackNode = root.callbackNode;
      if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 =
        workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root,
        root === workInProgressRoot
          ? workInProgressRootRenderLanes$jscomp$0
          : 0,
        null !== root.cancelPendingCommit || -1 !== root.timeoutHandle,
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(
        root,
        workInProgressRootRenderLanes$jscomp$0,
        didTimeout,
      );
      scheduleTaskForRootDuringMicrotask(root, now());
      return null != root.callbackNode &&
        root.callbackNode === originalCallbackNode
        ? performWorkOnRootViaSchedulerTask.bind(null, root)
        : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function () {
        0 !== (executionContext & 6)
          ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask,
            )
          : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane &&
          ((actionScopeLane = nextTransitionUpdateLane),
          (nextTransitionUpdateLane <<= 1),
          0 === (nextTransitionUpdateLane & 261888) &&
            (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp ||
        "symbol" === typeof actionProp ||
        "boolean" === typeof actionProp
        ? null
        : "function" === typeof actionProp
          ? actionProp
          : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(
      dispatchQueue,
      domEventName,
      maybeTargetInst,
      nativeEvent,
      nativeEventTarget,
    ) {
      if (
        "submit" === domEventName &&
        maybeTargetInst &&
        maybeTargetInst.stateNode === nativeEventTarget
      ) {
        var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action,
          ),
          submitter = nativeEvent.submitter;
        submitter &&
          ((domEventName = (domEventName = submitter[internalPropsKey] || null)
            ? coerceFormActionProp(domEventName.formAction)
            : submitter.getAttribute("formAction")),
          null !== domEventName &&
            ((action = domEventName), (submitter = null)));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget,
        );
        dispatchQueue.push({
          event: event,
          listeners: [
            {
              instance: null,
              listener: function () {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter
                      ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter,
                        )
                      : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action,
                      },
                      null,
                      formData,
                    );
                  }
                } else
                  "function" === typeof action &&
                    (event.preventDefault(),
                    (formData = submitter
                      ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter,
                        )
                      : new FormData(nativeEventTarget)),
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action,
                      },
                      action,
                      formData,
                    ));
              },
              currentTarget: nativeEventTarget,
            },
          ],
        });
      }
    }
    for (
      var i$jscomp$inline_1577 = 0;
      i$jscomp$inline_1577 < simpleEventPluginEvents.length;
      i$jscomp$inline_1577++
    ) {
      var eventName$jscomp$inline_1578 =
          simpleEventPluginEvents[i$jscomp$inline_1577],
        domEventName$jscomp$inline_1579 =
          eventName$jscomp$inline_1578.toLowerCase(),
        capitalizedEvent$jscomp$inline_1580 =
          eventName$jscomp$inline_1578[0].toUpperCase() +
          eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580,
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " ",
      ),
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " ",
      ),
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste",
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" "),
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" "),
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
    );
    var mediaEventTypes =
        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " ",
        ),
      nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle"
          .split(" ")
          .concat(mediaEventTypes),
      );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i],
          event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (
              var i$jscomp$0 = _dispatchQueue$i.length - 1;
              0 <= i$jscomp$0;
              i$jscomp$0--
            ) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                instance = _dispatchListeners$i.instance,
                currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (
              i$jscomp$0 = 0;
              i$jscomp$0 < _dispatchQueue$i.length;
              i$jscomp$0++
            ) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result &&
        (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
          new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) ||
        (addTrappedEventListener(targetElement, domEventName, 2, false),
        JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener,
      );
    }
    var listeningMarker =
      "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName &&
            (nonDelegatedEvents.has(domEventName) ||
              listenToNativeEvent(domEventName, false, rootContainerElement),
            listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument =
          9 === rootContainerElement.nodeType
            ? rootContainerElement
            : rootContainerElement.ownerDocument;
        null === ownerDocument ||
          ownerDocument[listeningMarker] ||
          ((ownerDocument[listeningMarker] = true),
          listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(
      targetContainer,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener,
    ) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer,
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported ||
        ("touchstart" !== domEventName &&
          "touchmove" !== domEventName &&
          "wheel" !== domEventName) ||
        (listenerWrapper = true);
      isCapturePhaseListener
        ? void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: true,
              passive: listenerWrapper,
            })
          : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              true,
            )
        : void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              passive: listenerWrapper,
            })
          : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              false,
            );
    }
    function dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetInst$jscomp$0,
      targetContainer,
    ) {
      var ancestorInst = targetInst$jscomp$0;
      if (
        0 === (eventSystemFlags & 1) &&
        0 === (eventSystemFlags & 2) &&
        null !== targetInst$jscomp$0
      )
        a: for (;;) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if (
                  (3 === grandTag || 4 === grandTag) &&
                  nodeTag.stateNode.containerInfo === targetContainer
                )
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (
                5 === grandTag ||
                6 === grandTag ||
                26 === grandTag ||
                27 === grandTag
              ) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly =
                !inCapturePhase &&
                ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase
                ? null !== reactName
                  ? reactName + "Capture"
                  : null
                : reactName;
            inCapturePhase = [];
            for (
              var instance = targetInst, lastHostComponent;
              null !== instance;
            ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
                null === lastHostComponent ||
                null === reactEventName ||
                ((_instance = getListener(instance, reactEventName)),
                null != _instance &&
                  inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance,
                      lastHostComponent,
                    ),
                  ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length &&
              ((reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget,
              )),
              dispatchQueue.push({
                event: reactName,
                listeners: inCapturePhase,
              }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName =
              "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor =
              "mouseout" === domEventName || "pointerout" === domEventName;
            if (
              reactName &&
              nativeEvent !== currentReplayingEvent &&
              (reactEventType =
                nativeEvent.relatedTarget || nativeEvent.fromElement) &&
              (getClosestInstanceFromNode(reactEventType) ||
                reactEventType[internalContainerInstanceKey])
            )
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName =
                nativeEventTarget.window === nativeEventTarget
                  ? nativeEventTarget
                  : (reactName = nativeEventTarget.ownerDocument)
                    ? reactName.defaultView || reactName.parentWindow
                    : window;
              if (SyntheticEventCtor) {
                if (
                  ((reactEventType =
                    nativeEvent.relatedTarget || nativeEvent.toElement),
                  (SyntheticEventCtor = targetInst),
                  (reactEventType = reactEventType
                    ? getClosestInstanceFromNode(reactEventType)
                    : null),
                  null !== reactEventType &&
                    ((accumulateTargetOnly =
                      getNearestMountedFiber(reactEventType)),
                    (inCapturePhase = reactEventType.tag),
                    reactEventType !== accumulateTargetOnly ||
                      (5 !== inCapturePhase &&
                        27 !== inCapturePhase &&
                        6 !== inCapturePhase)))
                )
                  reactEventType = null;
              } else
                ((SyntheticEventCtor = null), (reactEventType = targetInst));
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (
                  "pointerout" === domEventName ||
                  "pointerover" === domEventName
                )
                  ((inCapturePhase = SyntheticPointerEvent),
                    (_instance = "onPointerLeave"),
                    (reactEventName = "onPointerEnter"),
                    (instance = "pointer"));
                accumulateTargetOnly =
                  null == SyntheticEventCtor
                    ? reactName
                    : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent =
                  null == reactEventType
                    ? reactName
                    : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget,
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
                  ((inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget,
                  )),
                  (inCapturePhase.target = lastHostComponent),
                  (inCapturePhase.relatedTarget = accumulateTargetOnly),
                  (_instance = inCapturePhase));
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (
                      _instance = reactEventName;
                      _instance;
                      _instance = inCapturePhase(_instance)
                    )
                      lastHostComponent++;
                    _instance = 0;
                    for (
                      var tempB = instance;
                      tempB;
                      tempB = inCapturePhase(tempB)
                    )
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      ((reactEventName = inCapturePhase(reactEventName)),
                        lastHostComponent--);
                    for (; 0 < _instance - lastHostComponent; )
                      ((instance = inCapturePhase(instance)), _instance--);
                    for (; lastHostComponent--; ) {
                      if (
                        reactEventName === instance ||
                        (null !== instance &&
                          reactEventName === instance.alternate)
                      ) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    !1,
                  );
                null !== reactEventType &&
                  null !== accumulateTargetOnly &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    !0,
                  );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor =
              reactName.nodeName && reactName.nodeName.toLowerCase();
            if (
              "select" === SyntheticEventCtor ||
              ("input" === SyntheticEventCtor && "file" === reactName.type)
            )
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              ((SyntheticEventCtor = reactName.nodeName),
                !SyntheticEventCtor ||
                "input" !== SyntheticEventCtor.toLowerCase() ||
                ("checkbox" !== reactName.type && "radio" !== reactName.type)
                  ? targetInst &&
                    isCustomElement(targetInst.elementType) &&
                    (getTargetInstFunc = getTargetInstForChangeEvent)
                  : (getTargetInstFunc = getTargetInstForClickEvent));
            if (
              getTargetInstFunc &&
              (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
            ) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget,
              );
              break a;
            }
            handleEventFunc &&
              handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName &&
              targetInst &&
              "number" === reactName.type &&
              null != targetInst.memoizedProps.value &&
              setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst
            ? getNodeFromInstance(targetInst)
            : window;
          switch (domEventName) {
            case "focusin":
              if (
                isTextInputElement(handleEventFunc) ||
                "true" === handleEventFunc.contentEditable
              )
                ((activeElement = handleEventFunc),
                  (activeElementInst = targetInst),
                  (lastSelection = null));
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget,
              );
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget,
              );
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing
              ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                (eventType = "onCompositionEnd")
              : "keydown" === domEventName &&
                229 === nativeEvent.keyCode &&
                (eventType = "onCompositionStart");
          eventType &&
            (useFallbackCompositionData &&
              "ko" !== nativeEvent.locale &&
              (isComposing || "onCompositionStart" !== eventType
                ? "onCompositionEnd" === eventType &&
                  isComposing &&
                  (fallbackData = getData())
                : ((root = nativeEventTarget),
                  (startText = "value" in root ? root.value : root.textContent),
                  (isComposing = !0))),
            (handleEventFunc = accumulateTwoPhaseListeners(
              targetInst,
              eventType,
            )),
            0 < handleEventFunc.length &&
              ((eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget,
              )),
              dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc,
              }),
              fallbackData
                ? (eventType.data = fallbackData)
                : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                  null !== fallbackData && (eventType.data = fallbackData))));
          if (
            (fallbackData = canUseTextInputEvent
              ? getNativeBeforeInputChars(domEventName, nativeEvent)
              : getFallbackBeforeInputChars(domEventName, nativeEvent))
          )
            ((eventType = accumulateTwoPhaseListeners(
              targetInst,
              "onBeforeInput",
            )),
              0 < eventType.length &&
                ((handleEventFunc = new SyntheticCompositionEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget,
                )),
                dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType,
                }),
                (handleEventFunc.data = fallbackData)));
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget,
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget,
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (
        var captureName = reactName + "Capture", listeners = [];
        null !== targetFiber;
      ) {
        var _instance2 = targetFiber,
          stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
          null === stateNode ||
          ((_instance2 = getListener(targetFiber, captureName)),
          null != _instance2 &&
            listeners.unshift(
              createDispatchListener(targetFiber, _instance2, stateNode),
            ),
          (_instance2 = getListener(targetFiber, reactName)),
          null != _instance2 &&
            listeners.push(
              createDispatchListener(targetFiber, _instance2, stateNode),
            ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      event,
      target,
      common,
      inCapturePhase,
    ) {
      for (
        var registrationName = event._reactName, listeners = [];
        null !== target && target !== common;
      ) {
        var _instance3 = target,
          alternate = _instance3.alternate,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
          null === stateNode ||
          ((alternate = stateNode),
          inCapturePhase
            ? ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.unshift(
                  createDispatchListener(target, stateNode, alternate),
                ))
            : inCapturePhase ||
              ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.push(
                  createDispatchListener(target, stateNode, alternate),
                )));
        target = target.return;
      }
      0 !== listeners.length &&
        dispatchQueue.push({ event: event, listeners: listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup)
        .replace(NORMALIZE_NEWLINES_REGEX, "\n")
        .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText
        ? true
        : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value
            ? "body" === tag ||
              ("textarea" === tag && "" === value) ||
              setTextContent(domElement, value)
            : ("number" === typeof value || "bigint" === typeof value) &&
              "body" !== tag &&
              setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (
            null == value ||
            "function" === typeof value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')",
            );
            break;
          } else
            "function" === typeof prevValue &&
              ("formAction" === key
                ? ("input" !== tag &&
                    setProp(domElement, tag, "name", props.name, props, null),
                  setProp(
                    domElement,
                    tag,
                    "formEncType",
                    props.formEncType,
                    props,
                    null,
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formMethod",
                    props.formMethod,
                    props,
                    null,
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formTarget",
                    props.formTarget,
                    props,
                    null,
                  ))
                : (setProp(
                    domElement,
                    tag,
                    "encType",
                    props.encType,
                    props,
                    null,
                  ),
                  setProp(domElement, tag, "method", props.method, props, null),
                  setProp(
                    domElement,
                    tag,
                    "target",
                    props.target,
                    props,
                    null,
                  )));
          if (
            null == value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (
            null == value ||
            "function" === typeof value ||
            "boolean" === typeof value ||
            "symbol" === typeof value
          ) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key,
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value
            ? domElement.setAttribute(key, "" + value)
            : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value
            ? domElement.setAttribute(key, "")
            : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value
            ? domElement.setAttribute(key, "")
            : false !== value &&
                null != value &&
                "function" !== typeof value &&
                "symbol" !== typeof value
              ? domElement.setAttribute(key, value)
              : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value &&
          !isNaN(value) &&
          1 <= value
            ? domElement.setAttribute(key, value)
            : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value ||
          "function" === typeof value ||
          "symbol" === typeof value ||
          isNaN(value)
            ? domElement.removeAttribute(key)
            : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value,
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value,
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value,
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value,
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value,
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value,
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value,
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value,
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value,
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (
            !(2 < key.length) ||
            ("o" !== key[0] && "O" !== key[0]) ||
            ("n" !== key[1] && "N" !== key[1])
          )
            ((key = aliases.get(key) || key),
              setValueForAttribute(domElement, key, value));
      }
    }
    function setPropOnCustomElement(
      domElement,
      tag,
      key,
      value,
      props,
      prevValue,
    ) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value
            ? setTextContent(domElement, value)
            : ("number" === typeof value || "bigint" === typeof value) &&
              setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if (
                "o" === key[0] &&
                "n" === key[1] &&
                ((props = key.endsWith("Capture")),
                (tag = key.slice(2, props ? key.length - 7 : void 0)),
                (prevValue = domElement[internalPropsKey] || null),
                (prevValue = null != prevValue ? prevValue[key] : null),
                "function" === typeof prevValue &&
                  domElement.removeEventListener(tag, prevValue, props),
                "function" === typeof value)
              ) {
                "function" !== typeof prevValue &&
                  null !== prevValue &&
                  (key in domElement
                    ? (domElement[key] = null)
                    : domElement.hasAttribute(key) &&
                      domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement
                ? (domElement[key] = value)
                : true === value
                  ? domElement.setAttribute(key, "")
                  : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false,
            hasSrcSet = false,
            propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet &&
            setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = (propKey = propValue = hasSrcSet = null),
            checked = null,
            defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      hasSrc,
                      propValue$184,
                      props,
                      null,
                    );
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false,
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (
              props.hasOwnProperty(hasSrcSet) &&
              ((defaultValue = props[hasSrcSet]), null != defaultValue)
            )
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(
                    domElement,
                    tag,
                    hasSrcSet,
                    defaultValue,
                    props,
                    null,
                  );
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag
            ? updateOptions(domElement, !!hasSrc, tag, false)
            : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (
              props.hasOwnProperty(propValue) &&
              ((defaultValue = props[propValue]), null != defaultValue)
            )
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue)
                    throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propValue,
                    defaultValue,
                    props,
                    null,
                  );
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (
              props.hasOwnProperty(checked) &&
              ((hasSrc = props[checked]), null != hasSrc)
            )
              switch (checked) {
                case "selected":
                  domElement.selected =
                    hasSrc &&
                    "function" !== typeof hasSrc &&
                    "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          (listenToNonDelegatedEvent("error", domElement),
            listenToNonDelegatedEvent("load", domElement));
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (
              props.hasOwnProperty(defaultChecked) &&
              ((hasSrc = props[defaultChecked]), null != hasSrc)
            )
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) &&
                ((hasSrc = props[propValue$184]),
                void 0 !== hasSrc &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    propValue$184,
                    hasSrc,
                    props,
                    void 0,
                  ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) &&
          ((hasSrc = props[defaultValue]),
          null != hasSrc &&
            setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) ||
                    setProp(
                      domElement,
                      tag,
                      propKey,
                      null,
                      nextProps,
                      lastProp,
                    );
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (
              nextProps.hasOwnProperty(propKey$201) &&
              (null != propKey || null != lastProp)
            )
              switch (propKey$201) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp &&
                    setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp,
                    );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name,
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$201 = null;
          for (type in lastProps)
            if (
              ((lastDefaultValue = lastProps[type]),
              lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            )
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) ||
                    setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue,
                    );
              }
          for (name in nextProps)
            if (
              ((type = nextProps[name]),
              (lastDefaultValue = lastProps[name]),
              nextProps.hasOwnProperty(name) &&
                (null != type || null != lastDefaultValue))
            )
              switch (name) {
                case "value":
                  propKey$201 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue &&
                    setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue,
                    );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201
            ? updateOptions(domElement, !!lastProps, propKey$201, false)
            : !!nextProps !== !!lastProps &&
              (null != tag
                ? updateOptions(domElement, !!lastProps, tag, true)
                : updateOptions(
                    domElement,
                    !!lastProps,
                    lastProps ? [] : "",
                    false,
                  ));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue in lastProps)
            if (
              ((name = lastProps[defaultValue]),
              lastProps.hasOwnProperty(defaultValue) &&
                null != name &&
                !nextProps.hasOwnProperty(defaultValue))
            )
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (
              ((name = nextProps[value]),
              (type = lastProps[value]),
              nextProps.hasOwnProperty(value) && (null != name || null != type))
            )
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type &&
                    setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (
              ((propKey$201 = lastProps[propKey$217]),
              lastProps.hasOwnProperty(propKey$217) &&
                null != propKey$201 &&
                !nextProps.hasOwnProperty(propKey$217))
            )
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201,
                  );
              }
          for (lastDefaultValue in nextProps)
            if (
              ((propKey$201 = nextProps[lastDefaultValue]),
              (propKey = lastProps[lastDefaultValue]),
              nextProps.hasOwnProperty(lastDefaultValue) &&
                propKey$201 !== propKey &&
                (null != propKey$201 || null != propKey))
            )
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected =
                    propKey$201 &&
                    "function" !== typeof propKey$201 &&
                    "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey,
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            ((propKey$201 = lastProps[propKey$222]),
              lastProps.hasOwnProperty(propKey$222) &&
                null != propKey$201 &&
                !nextProps.hasOwnProperty(propKey$222) &&
                setProp(
                  domElement,
                  tag,
                  propKey$222,
                  null,
                  nextProps,
                  propKey$201,
                ));
          for (checked in nextProps)
            if (
              ((propKey$201 = nextProps[checked]),
              (propKey = lastProps[checked]),
              nextProps.hasOwnProperty(checked) &&
                propKey$201 !== propKey &&
                (null != propKey$201 || null != propKey))
            )
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey,
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              ((propKey$201 = lastProps[propKey$227]),
                lastProps.hasOwnProperty(propKey$227) &&
                  void 0 !== propKey$201 &&
                  !nextProps.hasOwnProperty(propKey$227) &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    propKey$227,
                    void 0,
                    nextProps,
                    propKey$201,
                  ));
            for (defaultChecked in nextProps)
              ((propKey$201 = nextProps[defaultChecked]),
                (propKey = lastProps[defaultChecked]),
                !nextProps.hasOwnProperty(defaultChecked) ||
                  propKey$201 === propKey ||
                  (void 0 === propKey$201 && void 0 === propKey) ||
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    propKey$201,
                    nextProps,
                    propKey,
                  ));
            return;
          }
      }
      for (var propKey$232 in lastProps)
        ((propKey$201 = lastProps[propKey$232]),
          lastProps.hasOwnProperty(propKey$232) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$232) &&
            setProp(
              domElement,
              tag,
              propKey$232,
              null,
              nextProps,
              propKey$201,
            ));
      for (lastProp in nextProps)
        ((propKey$201 = nextProps[lastProp]),
          (propKey = lastProps[lastProp]),
          !nextProps.hasOwnProperty(lastProp) ||
            propKey$201 === propKey ||
            (null == propKey$201 && null == propKey) ||
            setProp(
              domElement,
              tag,
              lastProp,
              propKey$201,
              nextProps,
              propKey,
            ));
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (
          var count = 0,
            bits = 0,
            resourceEntries = performance.getEntriesByType("resource"),
            i = 0;
          i < resourceEntries.length;
          i++
        ) {
          var entry = resourceEntries[i],
            transferSize = entry.transferSize,
            initiatorType = entry.initiatorType,
            duration = entry.duration;
          if (
            transferSize &&
            duration &&
            isLikelyStaticResource(initiatorType)
          ) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i],
                overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize,
                overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize &&
                isLikelyStaticResource(overlapInitiatorType) &&
                ((overlapEntry = overlapEntry.responseEnd),
                (initiatorType +=
                  overlapTransferSize *
                  (overlapEntry < duration
                    ? 1
                    : (duration - overlapStartTime) /
                      (overlapEntry - overlapStartTime))));
            }
            --i;
            bits +=
              (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection &&
        ((count = navigator.connection.downlink), "number" === typeof count)
        ? count
        : 5;
    }
    var eventsEnabled = null,
      selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type
        ? 0
        : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return (
        "textarea" === type ||
        "noscript" === type ||
        "string" === typeof props.children ||
        "number" === typeof props.children ||
        "bigint" === typeof props.children ||
        ("object" === typeof props.dangerouslySetInnerHTML &&
          null !== props.dangerouslySetInnerHTML &&
          null != props.dangerouslySetInnerHTML.__html)
      );
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout =
        "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout =
        "function" === typeof clearTimeout ? clearTimeout : void 0,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask =
        "function" === typeof queueMicrotask
          ? queueMicrotask
          : "undefined" !== typeof localPromise
            ? function (callback) {
                return localPromise
                  .resolve(null)
                  .then(callback)
                  .catch(handleErrorInNextTick);
              }
            : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (((node = nextNode.data), "/$" === node || "/&" === node)) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if (
            "$" === node ||
            "$?" === node ||
            "$~" === node ||
            "$!" === node ||
            "&" === node
          )
            depth++;
          else if ("html" === node)
            releaseSingletonInstance(
              parentInstance.ownerDocument.documentElement,
            );
          else if ("head" === node) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
                nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] ||
                "SCRIPT" === nodeName ||
                "STYLE" === nodeName ||
                ("LINK" === nodeName &&
                  "stylesheet" === node$jscomp$0.rel.toLowerCase()) ||
                node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node &&
              releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        1 === node.nodeType
          ? isHidden
            ? ((node._stashedDisplay = node.style.display),
              (node.style.display = "none"))
            : ((node.style.display = node._stashedDisplay || ""),
              "" === node.getAttribute("style") &&
                node.removeAttribute("style"))
          : 3 === node.nodeType &&
            (isHidden
              ? ((node._stashedText = node.nodeValue), (node.nodeValue = ""))
              : (node.nodeValue = node._stashedText || ""));
        if (nextNode && 8 === nextNode.nodeType)
          if (((node = nextNode.data), "/$" === node))
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            ("$" !== node && "$?" !== node && "$~" !== node && "$!" !== node) ||
              suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (
            !inRootOrSingleton &&
            ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
          )
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if (
              "hidden" === anyProps.type &&
              instance.getAttribute("name") === name
            )
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if (
                "stylesheet" === name &&
                instance.hasAttribute("data-precedence")
              )
                break;
              else if (
                name !== anyProps.rel ||
                instance.getAttribute("href") !==
                  (null == anyProps.href || "" === anyProps.href
                    ? null
                    : anyProps.href) ||
                instance.getAttribute("crossorigin") !==
                  (null == anyProps.crossOrigin
                    ? null
                    : anyProps.crossOrigin) ||
                instance.getAttribute("title") !==
                  (null == anyProps.title ? null : anyProps.title)
              )
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if (
                (name !== (null == anyProps.src ? null : anyProps.src) ||
                  instance.getAttribute("type") !==
                    (null == anyProps.type ? null : anyProps.type) ||
                  instance.getAttribute("crossorigin") !==
                    (null == anyProps.crossOrigin
                      ? null
                      : anyProps.crossOrigin)) &&
                name &&
                instance.hasAttribute("async") &&
                !instance.hasAttribute("itemprop")
              )
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    function isSuspenseInstanceFallback(instance) {
      return (
        "$!" === instance.data ||
        ("$?" === instance.data &&
          "loading" !== instance.ownerDocument.readyState)
      );
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = function () {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (
            "$" === nodeType ||
            "$!" === nodeType ||
            "$?" === nodeType ||
            "$~" === nodeType ||
            "&" === nodeType ||
            "F!" === nodeType ||
            "F" === nodeType
          )
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(
      hydrationInstance,
    ) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if ("/$" === data || "/&" === data) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            ("$" !== data &&
              "$!" !== data &&
              "$?" !== data &&
              "$~" !== data &&
              "&" !== data) ||
              depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (
            "$" === data ||
            "$!" === data ||
            "$?" === data ||
            "$~" === data ||
            "&" === data
          ) {
            if (0 === depth) return targetInstance;
            depth--;
          } else ("/$" !== data && "/&" !== data) || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = new Map(),
      preconnectsSet = new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode
        ? container.getRootNode()
        : 9 === container.nodeType
          ? container
          : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript,
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(),
        wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type
        ? requestFormReset$1(formInst)
        : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref =
          escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref =
          'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin &&
          (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) ||
          (preconnectsSet.add(limitedEscapedHref),
          (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
          null === ownerDocument.querySelector(limitedEscapedHref) &&
            ((href = ownerDocument.createElement("link")),
            setInitialProperties(href, "link", rel),
            markNodeAsHoistable(href),
            ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options) {
      previousDispatcher.L(href, as, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector =
          'link[rel="preload"][as="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(as) +
          '"]';
        "image" === as
          ? options && options.imageSrcSet
            ? ((preloadSelector +=
                '[imagesrcset="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(
                  options.imageSrcSet,
                ) +
                '"]'),
              "string" === typeof options.imageSizes &&
                (preloadSelector +=
                  '[imagesizes="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    options.imageSizes,
                  ) +
                  '"]'))
            : (preloadSelector +=
                '[href="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                '"]')
          : (preloadSelector +=
              '[href="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
              '"]');
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) ||
          ((href = assign(
            {
              rel: "preload",
              href:
                "image" === as && options && options.imageSrcSet
                  ? void 0
                  : href,
              as: as,
            },
            options,
          )),
          preloadPropsMap.set(key, href),
          null !== ownerDocument.querySelector(preloadSelector) ||
            ("style" === as &&
              ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
            ("script" === as &&
              ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
            ((as = ownerDocument.createElement("link")),
            setInitialProperties(as, "link", href),
            markNodeAsHoistable(as),
            ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options) {
      previousDispatcher.m(href, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as =
            options && "string" === typeof options.as ? options.as : "script",
          preloadSelector =
            'link[rel="modulepreload"][as="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(as) +
            '"][href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]',
          key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (
          !preloadPropsMap.has(key) &&
          ((href = assign({ rel: "modulepreload", href: href }, options)),
          preloadPropsMap.set(key, href),
          null === ownerDocument.querySelector(preloadSelector))
        ) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options) {
      previousDispatcher.S(href, precedence, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
          key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (
            (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key),
            ))
          )
            state.loading = 5;
          else {
            href = assign(
              { rel: "stylesheet", href: href, "data-precedence": precedence },
              options,
            );
            (options = preloadPropsMap.get(key)) &&
              adoptPreloadPropsForStylesheet(href, options);
            var link = (resource = ownerDocument.createElement("link"));
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function (resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function () {
              state.loading |= 1;
            });
            link.addEventListener("error", function () {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state: state,
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options) {
      previousDispatcher.X(src, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key = getScriptKey(src),
          resource = scripts.get(key);
        resource ||
          ((resource = ownerDocument.querySelector(
            getScriptSelectorFromKey(key),
          )),
          resource ||
            ((src = assign({ src: src, async: true }, options)),
            (options = preloadPropsMap.get(key)) &&
              adoptPreloadPropsForScript(src, options),
            (resource = ownerDocument.createElement("script")),
            markNodeAsHoistable(resource),
            setInitialProperties(resource, "link", src),
            ownerDocument.head.appendChild(resource)),
          (resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null,
          }),
          scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options) {
      previousDispatcher.M(src, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key = getScriptKey(src),
          resource = scripts.get(key);
        resource ||
          ((resource = ownerDocument.querySelector(
            getScriptSelectorFromKey(key),
          )),
          resource ||
            ((src = assign({ src: src, async: true, type: "module" }, options)),
            (options = preloadPropsMap.get(key)) &&
              adoptPreloadPropsForScript(src, options),
            (resource = ownerDocument.createElement("script")),
            markNodeAsHoistable(resource),
            setInitialProperties(resource, "link", src),
            ownerDocument.head.appendChild(resource)),
          (resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null,
          }),
          scripts.set(key, resource));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result =
        rootInstanceStackCursor.current)
        ? getHoistableRoot(JSCompiler_inline_result)
        : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence &&
            "string" === typeof pendingProps.href
            ? ((currentProps = getStyleKey(pendingProps.href)),
              (pendingProps = getResourcesFromRoot(
                JSCompiler_inline_result,
              ).hoistableStyles),
              (currentResource = pendingProps.get(currentProps)),
              currentResource ||
                ((currentResource = {
                  type: "style",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                pendingProps.set(currentProps, currentResource)),
              currentResource)
            : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (
            "stylesheet" === pendingProps.rel &&
            "string" === typeof pendingProps.href &&
            "string" === typeof pendingProps.precedence
          ) {
            type = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result,
              ).hoistableStyles,
              resource$244 = styles$243.get(type);
            resource$244 ||
              ((JSCompiler_inline_result =
                JSCompiler_inline_result.ownerDocument ||
                JSCompiler_inline_result),
              (resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              styles$243.set(type, resource$244),
              (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type),
              )) &&
                !styles$243._p &&
                ((resource$244.instance = styles$243),
                (resource$244.state.loading = 5)),
              preloadPropsMap.has(type) ||
                ((pendingProps = {
                  rel: "preload",
                  as: "style",
                  href: pendingProps.href,
                  crossOrigin: pendingProps.crossOrigin,
                  integrity: pendingProps.integrity,
                  media: pendingProps.media,
                  hrefLang: pendingProps.hrefLang,
                  referrerPolicy: pendingProps.referrerPolicy,
                }),
                preloadPropsMap.set(type, pendingProps),
                styles$243 ||
                  preloadStylesheet(
                    JSCompiler_inline_result,
                    type,
                    pendingProps,
                    resource$244.state,
                  )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return (
            (currentProps = pendingProps.async),
            (pendingProps = pendingProps.src),
            "string" === typeof pendingProps &&
            currentProps &&
            "function" !== typeof currentProps &&
            "symbol" !== typeof currentProps
              ? ((currentProps = getScriptKey(pendingProps)),
                (pendingProps = getResourcesFromRoot(
                  JSCompiler_inline_result,
                ).hoistableScripts),
                (currentResource = pendingProps.get(currentProps)),
                currentResource ||
                  ((currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null,
                  }),
                  pendingProps.set(currentProps, currentResource)),
                currentResource)
              : { type: "void", instance: null, count: 0, state: null }
          );
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    function getStyleKey(href) {
      return (
        'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"'
      );
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null,
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector(
        'link[rel="preload"][as="style"][' + key + "]",
      )
        ? (state.loading = 1)
        : ((key = ownerDocument.createElement("link")),
          (state.preload = key),
          key.addEventListener("load", function () {
            return (state.loading |= 1);
          }),
          key.addEventListener("error", function () {
            return (state.loading |= 2);
          }),
          setInitialProperties(key, "link", preloadProps),
          markNodeAsHoistable(key),
          ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return (
        '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]'
      );
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                '"]',
            );
            if (instance)
              return (
                (resource.instance = instance),
                markNodeAsHoistable(instance),
                instance
              );
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null,
            });
            instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return (resource.instance = instance);
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps),
            );
            if (instance$249)
              return (
                (resource.state.loading |= 4),
                (resource.instance = instance$249),
                markNodeAsHoistable(instance$249),
                instance$249
              );
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) &&
              adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function (resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return (resource.instance = instance$249);
          case "script":
            instance$249 = getScriptKey(props.src);
            if (
              (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249),
              ))
            )
              return (
                (resource.instance = styleProps),
                markNodeAsHoistable(styleProps),
                styleProps
              );
            instance = props;
            if ((styleProps = preloadPropsMap.get(instance$249)))
              ((instance = assign({}, props)),
                adoptPreloadPropsForScript(instance, styleProps));
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return (resource.instance = styleProps);
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type &&
          0 === (resource.state.loading & 4) &&
          ((instance = resource.instance),
          (resource.state.loading |= 4),
          insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (
        var nodes = root.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]',
          ),
          last = nodes.length ? nodes[nodes.length - 1] : null,
          prior = last,
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior
        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
        : ((precedence = 9 === root.nodeType ? root.head : root),
          precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin &&
        (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy &&
        (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title &&
        (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin &&
        (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy &&
        (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity &&
        (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = (tagCaches = new Map());
        caches.set(ownerDocument, cache);
      } else
        ((caches = tagCaches),
          (cache = caches.get(ownerDocument)),
          cache || ((cache = new Map()), caches.set(ownerDocument, cache)));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (
          !(
            node[internalHoistableMarker] ||
            node[internalInstanceKey] ||
            ("link" === type && "stylesheet" === node.getAttribute("rel"))
          ) &&
          "http://www.w3.org/2000/svg" !== node.namespaceURI
        ) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null,
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if (
            "string" !== typeof props.precedence ||
            "string" !== typeof props.href ||
            "" === props.href
          )
            break;
          return true;
        case "link":
          if (
            "string" !== typeof props.rel ||
            "string" !== typeof props.href ||
            "" === props.href ||
            props.onLoad ||
            props.onError
          )
            break;
          switch (props.rel) {
            case "stylesheet":
              return (
                (type = props.disabled),
                "string" === typeof props.precedence && null == type
              );
            default:
              return true;
          }
        case "script":
          if (
            props.async &&
            "function" !== typeof props.async &&
            "symbol" !== typeof props.async &&
            !props.onLoad &&
            !props.onError &&
            props.src &&
            "string" === typeof props.src
          )
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type &&
        0 === (resource.state.loading & 3)
        ? false
        : true;
    }
    function suspendResource(state, hoistableRoot, resource, props) {
      if (
        "stylesheet" === resource.type &&
        ("string" !== typeof props.media ||
          false !== matchMedia(props.media).matches) &&
        0 === (resource.state.loading & 4)
      ) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key),
            );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot &&
              "object" === typeof hoistableRoot &&
              "function" === typeof hoistableRoot.then &&
              (state.count++,
              (state = onUnsuspend.bind(state)),
              hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) &&
            adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) &&
          0 === (resource.state.loading & 3) &&
          (state.count++,
          (resource = onUnsuspend.bind(state)),
          hoistableRoot.addEventListener("load", resource),
          hoistableRoot.addEventListener("error", resource));
      }
    }
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets &&
        0 === state.count &&
        insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount
        ? function (commit) {
            var stylesheetTimer = setTimeout(function () {
              state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4 + timeoutOffset);
            0 < state.imgBytes &&
              0 === estimatedBytesWithinLimit &&
              (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
            var imgTimer = setTimeout(
              function () {
                state.waitingForImages = false;
                if (
                  0 === state.count &&
                  (state.stylesheets &&
                    insertSuspendedStylesheets(state, state.stylesheets),
                  state.unsuspend)
                ) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) +
                timeoutOffset,
            );
            state.unsuspend = commit;
            return function () {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          }
        : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages))
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend &&
        (state.count++,
        (precedencesByRoot = new Map()),
        resources.forEach(insertStylesheetIntoRoot, state),
        (precedencesByRoot = null),
        onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (
            var nodes = root.querySelectorAll(
                "link[data-precedence],style[data-precedence]",
              ),
              i = 0;
            i < nodes.length;
            i++
          ) {
            var node = nodes[i];
            if (
              "LINK" === node.nodeName ||
              "not all" !== node.getAttribute("media")
            )
              (precedences.set(node.dataset.precedence, node), (last = node));
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(null, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i
          ? i.parentNode.insertBefore(nodes, i.nextSibling)
          : ((root = 9 === root.nodeType ? root.head : root),
            root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0,
    };
    function FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator,
      formState,
    ) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
    }
    function createFiberRoot(
      containerInfo,
      tag,
      hydrate,
      initialChildren,
      hydrationCallbacks,
      isStrictMode,
      identifierPrefix,
      formState,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator,
    ) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState,
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag,
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(
      rootFiber,
      lane,
      element,
      container,
      parentComponent,
      callback,
    ) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context
        ? (container.context = parentComponent)
        : (container.pendingContext = parentComponent);
      container = createUpdate(lane);
      container.payload = { element: element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element &&
        (scheduleUpdateOnFiber(element, rootFiber, lane),
        entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root && scheduleUpdateOnFiber(root, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent,
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ((ReactDOMSharedInternals.p = 2),
          dispatchEvent(
            domEventName,
            eventSystemFlags,
            container,
            nativeEvent,
          ));
      } finally {
        ((ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition));
      }
    }
    function dispatchContinuousEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent,
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ((ReactDOMSharedInternals.p = 8),
          dispatchEvent(
            domEventName,
            eventSystemFlags,
            container,
            nativeEvent,
          ));
      } finally {
        ((ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition));
      }
    }
    function dispatchEvent(
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    ) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          (dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer,
          ),
            clearIfContinuousEvent(domEventName, nativeEvent));
        else if (
          queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent,
          )
        )
          nativeEvent.stopPropagation();
        else if (
          (clearIfContinuousEvent(domEventName, nativeEvent),
          eventSystemFlags & 4 &&
            -1 < discreteReplayableEvents.indexOf(domEventName))
        ) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root = fiber;
                      root.pendingLanes |= 2;
                      for (root.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << (31 - clz32(lanes));
                        root.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) &&
                        ((workInProgressRootRenderTargetTime = now() + 500),
                        flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  ((root = enqueueConcurrentRenderForLane(fiber, 2)),
                    null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                    flushSyncWork$1(),
                    markRetryLaneIfNotHydrated(fiber, 2));
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber &&
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer,
              );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer,
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents =
        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " ",
        );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(
      existingQueuedEvent,
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    ) {
      if (
        null === existingQueuedEvent ||
        existingQueuedEvent.nativeEvent !== nativeEvent
      )
        return (
          (existingQueuedEvent = {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags,
            nativeEvent: nativeEvent,
            targetContainers: [targetContainer],
          }),
          null !== blockedOn &&
            ((blockedOn = getInstanceFromNode(blockedOn)),
            null !== blockedOn && attemptContinuousHydration(blockedOn)),
          existingQueuedEvent
        );
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer &&
        -1 === blockedOn.indexOf(targetContainer) &&
        blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    ) {
      switch (domEventName) {
        case "focusin":
          return (
            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent,
            )),
            true
          );
        case "dragenter":
          return (
            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent,
            )),
            true
          );
        case "mouseover":
          return (
            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent,
            )),
            true
          );
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent,
            ),
          );
          return true;
        case "gotpointercapture":
          return (
            (pointerId = nativeEvent.pointerId),
            queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent,
              ),
            ),
            true
          );
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted)
          if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
            if (
              ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (
              ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (
            3 === targetInst &&
            nearestMounted.stateNode.current.memoizedState.isDehydrated
          ) {
            queuedTarget.blockedOn =
              3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            return;
          }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (
        var targetContainers = queuedEvent.targetContainers;
        0 < targetContainers.length;
      ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn,
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return (
            (targetContainers = getInstanceFromNode(nextBlockedOn)),
            null !== targetContainers &&
              attemptContinuousHydration(targetContainers),
            (queuedEvent.blockedOn = nextBlockedOn),
            false
          );
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus &&
        attemptReplayContinuousQueuedEvent(queuedFocus) &&
        (queuedFocus = null);
      null !== queuedDrag &&
        attemptReplayContinuousQueuedEvent(queuedDrag) &&
        (queuedDrag = null);
      null !== queuedMouse &&
        attemptReplayContinuousQueuedEvent(queuedMouse) &&
        (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked &&
        ((queuedEvent.blockedOn = null),
        hasScheduledReplayAttempt ||
          ((hasScheduledReplayAttempt = true),
          Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents,
          )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue &&
        ((lastScheduledReplayQueue = formReplayingQueue),
        Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function () {
            lastScheduledReplayQueue === formReplayingQueue &&
              (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i],
                submitterOrAction = formReplayingQueue[i + 1],
                formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (
                  null === findInstanceBlockingTarget(submitterOrAction || form)
                )
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst &&
                (formReplayingQueue.splice(i, 3),
                (i -= 3),
                startHostTransition(
                  formInst,
                  {
                    pending: true,
                    data: formData,
                    method: form.method,
                    action: submitterOrAction,
                  },
                  submitterOrAction,
                  formData,
                ));
            }
          },
        ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus &&
        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse &&
        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (
        ;
        0 < queuedExplicitHydrationTargets.length &&
        ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);
      )
        (attemptExplicitHydrationTarget(i),
          null === i.blockedOn && queuedExplicitHydrationTargets.shift());
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget],
            submitterOrAction = i[queuedTarget + 1],
            formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (
              submitterOrAction &&
              submitterOrAction.hasAttribute("formAction")
            )
              if (
                ((form = submitterOrAction),
                (formProps = submitterOrAction[internalPropsKey] || null))
              )
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action
              ? (i[queuedTarget + 1] = action)
              : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept &&
          "react-transition" === event.info &&
          event.intercept({
            handler: function () {
              return new Promise(function (resolve) {
                return (pendingResolve = resolve);
              });
            },
            focusReset: "manual",
            scroll: "manual",
          });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry &&
            null != currentEntry.url &&
            navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace",
            });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = false,
          pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function () {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener(
            "navigatesuccess",
            handleNavigateComplete,
          );
          navigation.removeEventListener(
            "navigateerror",
            handleNavigateComplete,
          );
          null !== pendingResolve &&
            (pendingResolve(), (pendingResolve = null));
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
      function (children) {
        var root = this._internalRoot;
        if (null === root) throw Error(formatProdErrorMessage(409));
        var current = root.current,
          lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root, null, null);
      };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
      function () {
        var root = this._internalRoot;
        if (null !== root) {
          this._internalRoot = null;
          var container = root.containerInfo;
          updateContainerImpl(root.current, 2, null, root, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
      target,
    ) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target: target, priority: updatePriority };
        for (
          var i = 0;
          i < queuedExplicitHydrationTargets.length &&
          0 !== updatePriority &&
          updatePriority < queuedExplicitHydrationTargets[i].priority;
          i++
        );
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
    if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.3",
        ),
      );
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement =
        null !== componentOrElement
          ? findCurrentHostFiberImpl(componentOrElement)
          : null;
      componentOrElement =
        null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.3",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.3",
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (
        !hook$jscomp$inline_2348.isDisabled &&
        hook$jscomp$inline_2348.supportsFiber
      )
        try {
          ((rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347,
          )),
            (injectedHook = hook$jscomp$inline_2348));
        } catch (err) {}
    }
    reactDomClient_production.createRoot = function (container, options) {
      if (!isValidContainer(container))
        throw Error(formatProdErrorMessage(299));
      var isStrictMode = false,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError;
      null !== options &&
        void 0 !== options &&
        (true === options.unstable_strictMode && (isStrictMode = true),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError));
      options = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator,
      );
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options);
    };
    reactDomClient_production.hydrateRoot = function (
      container,
      initialChildren,
      options,
    ) {
      if (!isValidContainer(container))
        throw Error(formatProdErrorMessage(299));
      var isStrictMode = false,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        formState = null;
      null !== options &&
        void 0 !== options &&
        (true === options.unstable_strictMode && (isStrictMode = true),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options ? options : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator,
      );
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      options = isStrictMode;
      initialChildren.current.lanes = options;
      markRootUpdated$1(initialChildren, options);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.2.3";
    return reactDomClient_production;
  }

  var hasRequiredClient;

  function requireClient() {
    if (hasRequiredClient) return client.exports;
    hasRequiredClient = 1;

    function checkDCE() {
      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
      if (
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function"
      ) {
        return;
      }
      try {
        // Verify that the code above has been dead code eliminated (DCE'd).
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        // DevTools shouldn't crash React, no matter what.
        // We should still report in case we break this code.
        console.error(err);
      }
    }

    {
      // DCE check should happen before ReactDOM bundle executes so that
      // DevTools can report bad minification during injection.
      checkDCE();
      client.exports = requireReactDomClient_production();
    }
    return client.exports;
  }

  var clientExports = requireClient();

  const defaultTheme$1 = {
    name: "default",
    colors: {
      primary: "#27903F",
      primaryHover: "#218838",
      primaryActive: "#1e7835",
      secondary: "#009b4d",
      secondaryHover: "#008840",
      accent: "#10b981",
      accentHover: "#059669",
      background: "#f6f8fa",
      backgroundSecondary: "#f9fafb",
      backgroundTertiary: "#fff",
      surface: "#fff",
      surfaceHover: "#f9fafb",
      border: "#e5e7eb",
      borderHover: "#d1d5db",
      borderFocus: "#27903F",
      text: "#111827",
      textSecondary: "#374151",
      textTertiary: "#4E8F50",
      textDisabled: "#9ca3af",
      textOnPrimary: "#fff",
      textOnSecondary: "#fff",
      success: "#4E8F50",
      successBackground: "#ecfdf5",
      successBorder: "#6ee7b7",
      error: "#ef4444",
      errorBackground: "#fee2e2",
      errorBorder: "#fca5a5",
      warning: "#f59e0b",
      warningBackground: "#fef3c7",
      warningBorder: "#fcd34d",
      info: "#3b82f6",
      infoBackground: "#dbeafe",
      infoBorder: "#93c5fd",
    },
    typography: {
      fontFamily:
        "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
      fontFamilyHeading:
        "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
      fontSizeXs: "12px",
      fontSizeSm: "14px",
      fontSizeMd: "16px",
      fontSizeLg: "18px",
      fontSizeXl: "20px",
      fontSize2xl: "24px",
      fontSize3xl: "30px",
      fontWeightNormal: "400",
      fontWeightMedium: "500",
      fontWeightSemibold: "600",
      fontWeightBold: "700",
      lineHeightTight: "1.25",
      lineHeightNormal: "1.5",
      lineHeightRelaxed: "1.75",
    },
    spacing: {
      xs: "4px",
      sm: "8px",
      md: "12px",
      lg: "16px",
      xl: "20px",
      "2xl": "24px",
      "3xl": "32px",
      "4xl": "40px",
    },
    shadows: {
      none: "none",
      sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
      md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
      lg: "0 8px 24px rgba(16, 24, 40, 0.08)",
      xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
      "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    },
    radii: {
      none: "0",
      sm: "4px",
      md: "8px",
      lg: "12px",
      xl: "16px",
      full: "9999px",
    },
    transitions: {
      fast: "150ms cubic-bezier(0.4, 0, 0.2, 1)",
      normal: "200ms cubic-bezier(0.4, 0, 0.2, 1)",
      slow: "300ms cubic-bezier(0.4, 0, 0.2, 1)",
    },
    breakpoints: {
      mobile: "320px",
      tablet: "768px",
      desktop: "1024px",
      wide: "1280px",
    },
  };
  const modernTheme = {
    name: "modern",
    colors: {
      primary: "#1e3a5f",
      primaryHover: "#2c4a6f",
      primaryActive: "#152942",
      secondary: "#ff6b35",
      secondaryHover: "#ff5722",
      accent: "#3b82f6",
      accentHover: "#2563eb",
      background: "#fff",
      backgroundSecondary: "#f8fafc",
      backgroundTertiary: "#f1f5f9",
      surface: "#ffffff",
      surfaceHover: "#f8fafc",
      border: "#e2e8f0",
      borderHover: "#cbd5e1",
      borderFocus: "#3b82f6",
      text: "#1e293b",
      textSecondary: "#64748b",
      textTertiary: "#94a3b8",
      textDisabled: "#cbd5e1",
      textOnPrimary: "#ffffff",
      textOnSecondary: "#ffffff",
      success: "#4E8F50",
      successBackground: "#ecfdf5",
      successBorder: "#6ee7b7",
      error: "#ef4444",
      errorBackground: "#fef2f2",
      errorBorder: "#fca5a5",
      warning: "#f59e0b",
      warningBackground: "#fffbeb",
      warningBorder: "#fcd34d",
      info: "#0ea5e9",
      infoBackground: "#e0f2fe",
      infoBorder: "#7dd3fc",
    },
    typography: {
      fontFamily:
        "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
      fontFamilyHeading:
        "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
      fontSizeXs: "12px",
      fontSizeSm: "14px",
      fontSizeMd: "16px",
      fontSizeLg: "18px",
      fontSizeXl: "20px",
      fontSize2xl: "24px",
      fontSize3xl: "30px",
      fontWeightNormal: "400",
      fontWeightMedium: "500",
      fontWeightSemibold: "600",
      fontWeightBold: "700",
      lineHeightTight: "1.25",
      lineHeightNormal: "1.5",
      lineHeightRelaxed: "1.75",
    },
    spacing: {
      xs: "4px",
      sm: "8px",
      md: "12px",
      lg: "16px",
      xl: "20px",
      "2xl": "24px",
      "3xl": "32px",
      "4xl": "40px",
    },
    shadows: {
      none: "none",
      sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
      md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
      lg: "0 8px 24px rgba(30, 58, 95, 0.12)",
      xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
      "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    },
    radii: {
      none: "0",
      sm: "4px",
      md: "8px",
      lg: "12px",
      xl: "16px",
      full: "9999px",
    },
    transitions: {
      fast: "150ms cubic-bezier(0.4, 0, 0.2, 1)",
      normal: "200ms cubic-bezier(0.4, 0, 0.2, 1)",
      slow: "300ms cubic-bezier(0.4, 0, 0.2, 1)",
    },
    breakpoints: {
      mobile: "320px",
      tablet: "768px",
      desktop: "1024px",
      wide: "1280px",
    },
  };
  const themes = {
    default: defaultTheme$1,
    modern: modernTheme,
  };

  function deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        const sourceValue = source[key];
        const targetValue = result[key];
        if (
          sourceValue &&
          typeof sourceValue === "object" &&
          !Array.isArray(sourceValue) &&
          targetValue &&
          typeof targetValue === "object" &&
          !Array.isArray(targetValue)
        ) {
          result[key] = deepMerge(targetValue, sourceValue);
        } else if (sourceValue !== undefined) {
          result[key] = sourceValue;
        }
      }
    }
    return result;
  }
  function mergeTheme(partialTheme) {
    if (!partialTheme) {
      return defaultTheme$1;
    }
    return deepMerge(defaultTheme$1, partialTheme);
  }
  function getCssVarName(prefix, category, key) {
    return `--${prefix}-${category}-${key
      .replace(/([A-Z])/g, "-$1")
      .toLowerCase()}`;
  }
  function generateCssVariablesObject(theme, prefix = "medos") {
    const vars = {};
    Object.entries(theme.colors).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "color", key)] = value;
    });
    Object.entries(theme.typography).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "typography", key)] = value;
    });
    Object.entries(theme.spacing).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "spacing", key)] = value;
    });
    Object.entries(theme.shadows).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "shadow", key)] = value;
    });
    Object.entries(theme.radii).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "radius", key)] = value;
    });
    Object.entries(theme.transitions).forEach(([key, value]) => {
      vars[getCssVarName(prefix, "transition", key)] = value;
    });
    return vars;
  }

  /**
   * Create a bound version of a function with a specified `this` context
   *
   * @param {Function} fn - The function to bind
   * @param {*} thisArg - The value to be passed as the `this` parameter
   * @returns {Function} A new function that will call the original function with the specified `this` context
   */
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // utils is a library of generic helper functions non-specific to axios

  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;

  const kindOf = ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(Object.create(null));

  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };

  const typeOfTest = (type) => (thing) => typeof thing === type;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   *
   * @returns {boolean} True if value is an Array, otherwise false
   */
  const { isArray: isArray$1 } = Array;

  /**
   * Determine if a value is undefined
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  const isUndefined = typeOfTest("undefined");

  /**
   * Determine if a value is a Buffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer(val) {
    return (
      val !== null &&
      !isUndefined(val) &&
      val.constructor !== null &&
      !isUndefined(val.constructor) &&
      isFunction$1(val.constructor.isBuffer) &&
      val.constructor.isBuffer(val)
    );
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  const isArrayBuffer = kindOfTest("ArrayBuffer");

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a String, otherwise false
   */
  const isString = typeOfTest("string");

  /**
   * Determine if a value is a Function
   *
   * @param {*} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  const isFunction$1 = typeOfTest("function");

  /**
   * Determine if a value is a Number
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Number, otherwise false
   */
  const isNumber = typeOfTest("number");

  /**
   * Determine if a value is an Object
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an Object, otherwise false
   */
  const isObject = (thing) => thing !== null && typeof thing === "object";

  /**
   * Determine if a value is a Boolean
   *
   * @param {*} thing The value to test
   * @returns {boolean} True if value is a Boolean, otherwise false
   */
  const isBoolean = (thing) => thing === true || thing === false;

  /**
   * Determine if a value is a plain Object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a plain Object, otherwise false
   */
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }

    const prototype = getPrototypeOf(val);
    return (
      (prototype === null ||
        prototype === Object.prototype ||
        Object.getPrototypeOf(prototype) === null) &&
      !(toStringTag in val) &&
      !(iterator in val)
    );
  };

  /**
   * Determine if a value is an empty object (safely handles Buffers)
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is an empty object, otherwise false
   */
  const isEmptyObject = (val) => {
    // Early return for non-objects or Buffers to prevent RangeError
    if (!isObject(val) || isBuffer(val)) {
      return false;
    }

    try {
      return (
        Object.keys(val).length === 0 &&
        Object.getPrototypeOf(val) === Object.prototype
      );
    } catch (e) {
      // Fallback for any other objects that might cause RangeError with Object.keys()
      return false;
    }
  };

  /**
   * Determine if a value is a Date
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Date, otherwise false
   */
  const isDate = kindOfTest("Date");

  /**
   * Determine if a value is a File
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFile = kindOfTest("File");

  /**
   * Determine if a value is a Blob
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  const isBlob = kindOfTest("Blob");

  /**
   * Determine if a value is a FileList
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFileList = kindOfTest("FileList");

  /**
   * Determine if a value is a Stream
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  const isStream = (val) => isObject(val) && isFunction$1(val.pipe);

  /**
   * Determine if a value is a FormData
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  const isFormData = (thing) => {
    let kind;
    return (
      thing &&
      ((typeof FormData === "function" && thing instanceof FormData) ||
        (isFunction$1(thing.append) &&
          ((kind = kindOf(thing)) === "formdata" ||
            // detect form-data instance
            (kind === "object" &&
              isFunction$1(thing.toString) &&
              thing.toString() === "[object FormData]"))))
    );
  };

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  const isURLSearchParams = kindOfTest("URLSearchParams");

  const [isReadableStream, isRequest, isResponse, isHeaders] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers",
  ].map(kindOfTest);

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   *
   * @returns {String} The String freed of excess whitespace
   */
  const trim$1 = (str) =>
    str.trim
      ? str.trim()
      : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   *
   * @param {Boolean} [allOwnKeys = false]
   * @returns {any}
   */
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") {
      return;
    }

    let i;
    let l;

    // Force an array if not already something iterable
    if (typeof obj !== "object") {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray$1(obj)) {
      // Iterate over array values
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Buffer check
      if (isBuffer(obj)) {
        return;
      }

      // Iterate over object keys
      const keys = allOwnKeys
        ? Object.getOwnPropertyNames(obj)
        : Object.keys(obj);
      const len = keys.length;
      let key;

      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }

  function findKey(obj, key) {
    if (isBuffer(obj)) {
      return null;
    }

    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }

  const _global = (() => {
    /*eslint no-undef:0*/
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined"
      ? self
      : typeof window !== "undefined"
        ? window
        : global;
  })();

  const isContextDefined = (context) =>
    !isUndefined(context) && context !== _global;

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   *
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    const { caseless, skipUndefined } = (isContextDefined(this) && this) || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = (caseless && findKey(result, key)) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray$1(val)) {
        result[targetKey] = val.slice();
      } else if (!skipUndefined || !isUndefined(val)) {
        result[targetKey] = val;
      }
    };

    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   *
   * @param {Boolean} [allOwnKeys]
   * @returns {Object} The resulting value of object a
   */
  const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(
      b,
      (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      },
      { allOwnKeys },
    );
    return a;
  };

  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   *
   * @returns {string} content value without BOM
   */
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 0xfeff) {
      content = content.slice(1);
    }
    return content;
  };

  /**
   * Inherit the prototype methods from one constructor into another
   * @param {function} constructor
   * @param {function} superConstructor
   * @param {object} [props]
   * @param {object} [descriptors]
   *
   * @returns {void}
   */
  const inherits = (constructor, superConstructor, props, descriptors) => {
    constructor.prototype = Object.create(
      superConstructor.prototype,
      descriptors,
    );
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype,
    });
    props && Object.assign(constructor.prototype, props);
  };

  /**
   * Resolve object with deep prototype chain to a flat object
   * @param {Object} sourceObj source object
   * @param {Object} [destObj]
   * @param {Function|Boolean} [filter]
   * @param {Function} [propFilter]
   *
   * @returns {Object}
   */
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};

    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;

    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if (
          (!propFilter || propFilter(prop, sourceObj, destObj)) &&
          !merged[prop]
        ) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (
      sourceObj &&
      (!filter || filter(sourceObj, destObj)) &&
      sourceObj !== Object.prototype
    );

    return destObj;
  };

  /**
   * Determines whether a string ends with the characters of a specified string
   *
   * @param {String} str
   * @param {String} searchString
   * @param {Number} [position= 0]
   *
   * @returns {boolean}
   */
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === undefined || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };

  /**
   * Returns new array from array like object or null if failed
   *
   * @param {*} [thing]
   *
   * @returns {?Array}
   */
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray$1(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };

  /**
   * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
   * thing passed in is an instance of Uint8Array
   *
   * @param {TypedArray}
   *
   * @returns {Array}
   */
  // eslint-disable-next-line func-names
  const isTypedArray = ((TypedArray) => {
    // eslint-disable-next-line func-names
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));

  /**
   * For each entry in the object, call the function with the key and value.
   *
   * @param {Object<any, any>} obj - The object to iterate over.
   * @param {Function} fn - The function to call for each entry.
   *
   * @returns {void}
   */
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator];

    const _iterator = generator.call(obj);

    let result;

    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };

  /**
   * It takes a regular expression and a string, and returns an array of all the matches
   *
   * @param {string} regExp - The regular expression to match against.
   * @param {string} str - The string to search.
   *
   * @returns {Array<boolean>}
   */
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];

    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }

    return arr;
  };

  /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
  const isHTMLForm = kindOfTest("HTMLFormElement");

  const toCamelCase = (str) => {
    return str
      .toLowerCase()
      .replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      });
  };

  /* Creating a function that will check if an object has a property. */
  const hasOwnProperty = (
    ({ hasOwnProperty }) =>
    (obj, prop) =>
      hasOwnProperty.call(obj, prop)
  )(Object.prototype);

  /**
   * Determine if a value is a RegExp object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a RegExp object, otherwise false
   */
  const isRegExp = kindOfTest("RegExp");

  const reduceDescriptors = (obj, reducer) => {
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};

    forEach(descriptors, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });

    Object.defineProperties(obj, reducedDescriptors);
  };

  /**
   * Makes all methods read-only
   * @param {Object} obj
   */

  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      // skip restricted props in strict mode
      if (
        isFunction$1(obj) &&
        ["arguments", "caller", "callee"].indexOf(name) !== -1
      ) {
        return false;
      }

      const value = obj[name];

      if (!isFunction$1(value)) return;

      descriptor.enumerable = false;

      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }

      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };

  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};

    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };

    isArray$1(arrayOrString)
      ? define(arrayOrString)
      : define(String(arrayOrString).split(delimiter));

    return obj;
  };

  const noop$1 = () => {};

  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite((value = +value))
      ? value
      : defaultValue;
  };

  /**
   * If the thing is a FormData object, return true, otherwise return false.
   *
   * @param {unknown} thing - The thing to check.
   *
   * @returns {boolean}
   */
  function isSpecCompliantForm(thing) {
    return !!(
      thing &&
      isFunction$1(thing.append) &&
      thing[toStringTag] === "FormData" &&
      thing[iterator]
    );
  }

  const toJSONObject = (obj) => {
    const stack = new Array(10);

    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }

        //Buffer check
        if (isBuffer(source)) {
          return source;
        }

        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray$1(source) ? [] : {};

          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });

          stack[i] = undefined;

          return target;
        }
      }

      return source;
    };

    return visit(obj, 0);
  };

  const isAsyncFn = kindOfTest("AsyncFunction");

  const isThenable = (thing) =>
    thing &&
    (isObject(thing) || isFunction$1(thing)) &&
    isFunction$1(thing.then) &&
    isFunction$1(thing.catch);

  // original code
  // https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }

    return postMessageSupported
      ? ((token, callbacks) => {
          _global.addEventListener(
            "message",
            ({ source, data }) => {
              if (source === _global && data === token) {
                callbacks.length && callbacks.shift()();
              }
            },
            false,
          );

          return (cb) => {
            callbacks.push(cb);
            _global.postMessage(token, "*");
          };
        })(`axios@${Math.random()}`, [])
      : (cb) => setTimeout(cb);
  })(typeof setImmediate === "function", isFunction$1(_global.postMessage));

  const asap =
    typeof queueMicrotask !== "undefined"
      ? queueMicrotask.bind(_global)
      : (typeof process !== "undefined" && process.nextTick) || _setImmediate;

  // *********************

  const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);

  var utils$1 = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim: trim$1,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable,
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  function AxiosError$1(message, code, config, request, response) {
    Error.call(this);

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }

    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }

  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status,
      };
    },
  });

  const prototype$1 = AxiosError$1.prototype;
  const descriptors = {};

  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL",
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });

  Object.defineProperties(AxiosError$1, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });

  // eslint-disable-next-line func-names
  AxiosError$1.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);

    utils$1.toFlatObject(
      error,
      axiosError,
      function filter(obj) {
        return obj !== Error.prototype;
      },
      (prop) => {
        return prop !== "isAxiosError";
      },
    );

    const msg = error && error.message ? error.message : "Error";

    // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)
    const errCode = code == null && error ? error.code : code;
    AxiosError$1.call(axiosError, msg, errCode, config, request, response);

    // Chain the original error on the standard field; non-enumerable to avoid JSON noise
    if (error && axiosError.cause == null) {
      Object.defineProperty(axiosError, "cause", {
        value: error,
        configurable: true,
      });
    }

    axiosError.name = (error && error.name) || "Error";

    customProps && Object.assign(axiosError, customProps);

    return axiosError;
  };

  // eslint-disable-next-line strict
  var httpAdapter = null;

  /**
   * Determines if the given thing is a array or js object.
   *
   * @param {string} thing - The object or array to be visited.
   *
   * @returns {boolean}
   */
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }

  /**
   * It removes the brackets from the end of a string
   *
   * @param {string} key - The key of the parameter.
   *
   * @returns {string} the key without the brackets.
   */
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }

  /**
   * It takes a path, a key, and a boolean, and returns a string
   *
   * @param {string} path - The path to the current key.
   * @param {string} key - The key of the current object being iterated over.
   * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
   *
   * @returns {string} The path to the current key.
   */
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path
      .concat(key)
      .map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      })
      .join(dots ? "." : "");
  }

  /**
   * If the array is an array and none of its elements are visitable, then it's a flat array.
   *
   * @param {Array<any>} arr - The array to check
   *
   * @returns {boolean}
   */
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }

  const predicates = utils$1.toFlatObject(
    utils$1,
    {},
    null,
    function filter(prop) {
      return /^is[A-Z]/.test(prop);
    },
  );

  /**
   * Convert a data object to FormData
   *
   * @param {Object} obj
   * @param {?Object} [formData]
   * @param {?Object} [options]
   * @param {Function} [options.visitor]
   * @param {Boolean} [options.metaTokens = true]
   * @param {Boolean} [options.dots = false]
   * @param {?Boolean} [options.indexes = false]
   *
   * @returns {Object}
   **/

  /**
   * It converts an object into a FormData object
   *
   * @param {Object<any, any>} obj - The object to convert to form data.
   * @param {string} formData - The FormData object to append to.
   * @param {Object<string, any>} options
   *
   * @returns
   */
  function toFormData$1(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }

    // eslint-disable-next-line no-param-reassign
    formData = formData || new FormData();

    // eslint-disable-next-line no-param-reassign
    options = utils$1.toFlatObject(
      options,
      {
        metaTokens: true,
        dots: false,
        indexes: false,
      },
      false,
      function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !utils$1.isUndefined(source[option]);
      },
    );

    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || (typeof Blob !== "undefined" && Blob);
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }

    function convertValue(value) {
      if (value === null) return "";

      if (utils$1.isDate(value)) {
        return value.toISOString();
      }

      if (utils$1.isBoolean(value)) {
        return value.toString();
      }

      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }

      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function"
          ? new Blob([value])
          : Buffer.from(value);
      }

      return value;
    }

    /**
     * Default visitor.
     *
     * @param {*} value
     * @param {String|Number} key
     * @param {Array<String|Number>} path
     * @this {FormData}
     *
     * @returns {boolean} return true to visit the each prop of the value recursively
     */
    function defaultVisitor(value, key, path) {
      let arr = value;

      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          // eslint-disable-next-line no-param-reassign
          key = metaTokens ? key : key.slice(0, -2);
          // eslint-disable-next-line no-param-reassign
          value = JSON.stringify(value);
        } else if (
          (utils$1.isArray(value) && isFlatArray(value)) ||
          ((utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) &&
            (arr = utils$1.toArray(value)))
        ) {
          // eslint-disable-next-line no-param-reassign
          key = removeBrackets(key);

          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) &&
              formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true
                  ? renderKey([key], index, dots)
                  : indexes === null
                    ? key
                    : key + "[]",
                convertValue(el),
              );
          });
          return false;
        }
      }

      if (isVisitable(value)) {
        return true;
      }

      formData.append(renderKey(path, key, dots), convertValue(value));

      return false;
    }

    const stack = [];

    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable,
    });

    function build(value, path) {
      if (utils$1.isUndefined(value)) return;

      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }

      stack.push(value);

      utils$1.forEach(value, function each(el, key) {
        const result =
          !(utils$1.isUndefined(el) || el === null) &&
          visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers,
          );

        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });

      stack.pop();
    }

    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }

    build(obj);

    return formData;
  }

  /**
   * It encodes a string by replacing all characters that are not in the unreserved set with
   * their percent-encoded equivalents
   *
   * @param {string} str - The string to encode.
   *
   * @returns {string} The encoded string.
   */
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\x00",
    };
    return encodeURIComponent(str).replace(
      /[!'()~]|%20|%00/g,
      function replacer(match) {
        return charMap[match];
      },
    );
  }

  /**
   * It takes a params object and converts it to a FormData object
   *
   * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
   * @param {Object<string, any>} options - The options object passed to the Axios constructor.
   *
   * @returns {void}
   */
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];

    params && toFormData$1(params, this, options);
  }

  const prototype = AxiosURLSearchParams.prototype;

  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };

  prototype.toString = function toString(encoder) {
    const _encode = encoder
      ? function (value) {
          return encoder.call(this, value, encode$1);
        }
      : encode$1;

    return this._pairs
      .map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "")
      .join("&");
  };

  /**
   * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
   * URI encoded counterparts
   *
   * @param {string} val The value to be encoded.
   *
   * @returns {string} The encoded value.
   */
  function encode(val) {
    return encodeURIComponent(val)
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%20/g, "+");
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @param {?(object|Function)} options
   *
   * @returns {string} The formatted url
   */
  function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    const _encode = (options && options.encode) || encode;

    if (utils$1.isFunction(options)) {
      options = {
        serialize: options,
      };
    }

    const serializeFn = options && options.serialize;

    let serializedParams;

    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params)
        ? params.toString()
        : new AxiosURLSearchParams(params, options).toString(_encode);
    }

    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }

    return url;
  }

  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null,
      });
      return this.handlers.length - 1;
    }

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }

    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }

  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false,
  };

  var URLSearchParams$1 =
    typeof URLSearchParams !== "undefined"
      ? URLSearchParams
      : AxiosURLSearchParams;

  var FormData$1 = typeof FormData !== "undefined" ? FormData : null;

  var Blob$1 = typeof Blob !== "undefined" ? Blob : null;

  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1,
    },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };

  const hasBrowserEnv =
    typeof window !== "undefined" && typeof document !== "undefined";

  const _navigator = (typeof navigator === "object" && navigator) || undefined;

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   *
   * @returns {boolean}
   */
  const hasStandardBrowserEnv =
    hasBrowserEnv &&
    (!_navigator ||
      ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);

  /**
   * Determine if we're running in a standard browser webWorker environment
   *
   * Although the `isStandardBrowserEnv` method indicates that
   * `allows axios to run in a web worker`, the WebWorker will still be
   * filtered out due to its judgment standard
   * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
   * This leads to a problem when axios post `FormData` in webWorker
   */
  const hasStandardBrowserWebWorkerEnv = (() => {
    return (
      typeof WorkerGlobalScope !== "undefined" &&
      // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope &&
      typeof self.importScripts === "function"
    );
  })();

  const origin = (hasBrowserEnv && window.location.href) || "http://localhost";

  var utils = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin: origin,
  });

  var platform = {
    ...utils,
    ...platform$1,
  };

  function toURLEncodedForm(data, options) {
    return toFormData$1(data, new platform.classes.URLSearchParams(), {
      visitor: function (value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }

        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options,
    });
  }

  /**
   * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
   *
   * @param {string} name - The name of the property to get.
   *
   * @returns An array of strings.
   */
  function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }

  /**
   * Convert an array to an object.
   *
   * @param {Array<any>} arr - The array to convert to an object.
   *
   * @returns An object with the same keys and values as the array.
   */
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }

  /**
   * It takes a FormData object and returns a JavaScript object
   *
   * @param {string} formData The FormData object to convert to JSON.
   *
   * @returns {Object<string, any> | null} The converted object.
   */
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];

      if (name === "__proto__") return true;

      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;

      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }

        return !isNumericKey;
      }

      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }

      const result = buildPath(path, value, target[name], index);

      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }

      return !isNumericKey;
    }

    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};

      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });

      return obj;
    }

    return null;
  }

  /**
   * It takes a string, tries to parse it, and if it fails, it returns the stringified version
   * of the input
   *
   * @param {any} rawValue - The value to be stringified.
   * @param {Function} parser - A function that parses a string into a JavaScript object.
   * @param {Function} encoder - A function that takes a value and returns a string.
   *
   * @returns {string} A stringified version of the rawValue.
   */
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }

    return (encoder || JSON.stringify)(rawValue);
  }

  const defaults = {
    transitional: transitionalDefaults,

    adapter: ["xhr", "http", "fetch"],

    transformRequest: [
      function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);

        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }

        const isFormData = utils$1.isFormData(data);

        if (isFormData) {
          return hasJSONContentType
            ? JSON.stringify(formDataToJSON(data))
            : data;
        }

        if (
          utils$1.isArrayBuffer(data) ||
          utils$1.isBuffer(data) ||
          utils$1.isStream(data) ||
          utils$1.isFile(data) ||
          utils$1.isBlob(data) ||
          utils$1.isReadableStream(data)
        ) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            false,
          );
          return data.toString();
        }

        let isFileList;

        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }

          if (
            (isFileList = utils$1.isFileList(data)) ||
            contentType.indexOf("multipart/form-data") > -1
          ) {
            const _FormData = this.env && this.env.FormData;

            return toFormData$1(
              isFileList ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer,
            );
          }
        }

        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }

        return data;
      },
    ],

    transformResponse: [
      function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing =
          transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";

        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }

        if (
          data &&
          utils$1.isString(data) &&
          ((forcedJSONParsing && !this.responseType) || JSONRequested)
        ) {
          const silentJSONParsing =
            transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;

          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(
                  e,
                  AxiosError$1.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response,
                );
              }
              throw e;
            }
          }
        }

        return data;
      },
    ],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",

    maxContentLength: -1,
    maxBodyLength: -1,

    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob,
    },

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },

    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": undefined,
      },
    },
  };

  utils$1.forEach(
    ["delete", "get", "head", "post", "put", "patch"],
    (method) => {
      defaults.headers[method] = {};
    },
  );

  // RawAxiosHeaders whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]);

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} rawHeaders Headers needing to be parsed
   *
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;

    rawHeaders &&
      rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();

        if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
          return;
        }

        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });

    return parsed;
  };

  const $internals = Symbol("internals");

  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }

  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }

    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }

  function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;

    while ((match = tokensRE.exec(str))) {
      tokens[match[1]] = match[2];
    }

    return tokens;
  }

  const isValidHeaderName = (str) =>
    /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

  function matchHeaderValue(
    context,
    value,
    header,
    filter,
    isHeaderNameFilter,
  ) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }

    if (isHeaderNameFilter) {
      value = header;
    }

    if (!utils$1.isString(value)) return;

    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }

    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }

  function formatHeader(header) {
    return header
      .trim()
      .toLowerCase()
      .replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
  }

  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);

    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function (arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true,
      });
    });
  }

  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }

    set(header, valueOrRewrite, rewrite) {
      const self = this;

      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);

        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }

        const key = utils$1.findKey(self, lHeader);

        if (
          !key ||
          self[key] === undefined ||
          _rewrite === true ||
          (_rewrite === undefined && self[key] !== false)
        ) {
          self[key || _header] = normalizeValue(_value);
        }
      }

      const setHeaders = (headers, _rewrite) =>
        utils$1.forEach(headers, (_value, _header) =>
          setHeader(_value, _header, _rewrite),
        );

      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (
        utils$1.isString(header) &&
        (header = header.trim()) &&
        !isValidHeaderName(header)
      ) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {},
          dest,
          key;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }

          obj[(key = entry[0])] = (dest = obj[key])
            ? utils$1.isArray(dest)
              ? [...dest, entry[1]]
              : [dest, entry[1]]
            : entry[1];
        }

        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }

      return this;
    }

    get(header, parser) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$1.findKey(this, header);

        if (key) {
          const value = this[key];

          if (!parser) {
            return value;
          }

          if (parser === true) {
            return parseTokens(value);
          }

          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }

          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }

          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }

    has(header, matcher) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$1.findKey(this, header);

        return !!(
          key &&
          this[key] !== undefined &&
          (!matcher || matchHeaderValue(this, this[key], key, matcher))
        );
      }

      return false;
    }

    delete(header, matcher) {
      const self = this;
      let deleted = false;

      function deleteHeader(_header) {
        _header = normalizeHeader(_header);

        if (_header) {
          const key = utils$1.findKey(self, _header);

          if (
            key &&
            (!matcher || matchHeaderValue(self, self[key], key, matcher))
          ) {
            delete self[key];

            deleted = true;
          }
        }
      }

      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }

      return deleted;
    }

    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;

      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }

      return deleted;
    }

    normalize(format) {
      const self = this;
      const headers = {};

      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);

        if (key) {
          self[key] = normalizeValue(value);
          delete self[header];
          return;
        }

        const normalized = format
          ? formatHeader(header)
          : String(header).trim();

        if (normalized !== header) {
          delete self[header];
        }

        self[normalized] = normalizeValue(value);

        headers[normalized] = true;
      });

      return this;
    }

    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }

    toJSON(asStrings) {
      const obj = Object.create(null);

      utils$1.forEach(this, (value, header) => {
        value != null &&
          value !== false &&
          (obj[header] =
            asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });

      return obj;
    }

    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }

    toString() {
      return Object.entries(this.toJSON())
        .map(([header, value]) => header + ": " + value)
        .join("\n");
    }

    getSetCookie() {
      return this.get("set-cookie") || [];
    }

    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }

    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }

    static concat(first, ...targets) {
      const computed = new this(first);

      targets.forEach((target) => computed.set(target));

      return computed;
    }

    static accessor(header) {
      const internals =
        (this[$internals] =
        this[$internals] =
          {
            accessors: {},
          });

      const accessors = internals.accessors;
      const prototype = this.prototype;

      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);

        if (!accessors[lHeader]) {
          buildAccessors(prototype, _header);
          accessors[lHeader] = true;
        }
      }

      utils$1.isArray(header)
        ? header.forEach(defineAccessor)
        : defineAccessor(header);

      return this;
    }
  };

  AxiosHeaders$1.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization",
  ]);

  // reserved names hotfix
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      },
    };
  });

  utils$1.freezeMethods(AxiosHeaders$1);

  /**
   * Transform the data for a request or a response
   *
   * @param {Array|Function} fns A single function or Array of functions
   * @param {?Object} response The response object
   *
   * @returns {*} The resulting transformed data
   */
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;

    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(
        config,
        data,
        headers.normalize(),
        response ? response.status : undefined,
      );
    });

    headers.normalize();

    return data;
  }

  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }

  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  function CanceledError$1(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    AxiosError$1.call(
      this,
      message == null ? "canceled" : message,
      AxiosError$1.ERR_CANCELED,
      config,
      request,
    );
    this.name = "CanceledError";
  }

  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true,
  });

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   *
   * @returns {object} The response.
   */
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (
      !response.status ||
      !validateStatus ||
      validateStatus(response.status)
    ) {
      resolve(response);
    } else {
      reject(
        new AxiosError$1(
          "Request failed with status code " + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][
            Math.floor(response.status / 100) - 4
          ],
          response.config,
          response.request,
          response,
        ),
      );
    }
  }

  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return (match && match[1]) || "";
  }

  /**
   * Calculate data maxRate
   * @param {Number} [samplesCount= 10]
   * @param {Number} [min= 1000]
   * @returns {Function}
   */
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;

    min = min !== undefined ? min : 1000;

    return function push(chunkLength) {
      const now = Date.now();

      const startedAt = timestamps[tail];

      if (!firstSampleTS) {
        firstSampleTS = now;
      }

      bytes[head] = chunkLength;
      timestamps[head] = now;

      let i = tail;
      let bytesCount = 0;

      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }

      head = (head + 1) % samplesCount;

      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }

      if (now - firstSampleTS < min) {
        return;
      }

      const passed = startedAt && now - startedAt;

      return passed ? Math.round((bytesCount * 1000) / passed) : undefined;
    };
  }

  /**
   * Throttle decorator
   * @param {Function} fn
   * @param {Number} freq
   * @return {Function}
   */
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1000 / freq;
    let lastArgs;
    let timer;

    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };

    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };

    const flush = () => lastArgs && invoke(lastArgs);

    return [throttled, flush];
  }

  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);

    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : undefined;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;

      bytesNotified = loaded;

      const data = {
        loaded,
        total,
        progress: total ? loaded / total : undefined,
        bytes: progressBytes,
        rate: rate ? rate : undefined,
        estimated:
          rate && total && inRange ? (total - loaded) / rate : undefined,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true,
      };

      listener(data);
    }, freq);
  };

  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;

    return [
      (loaded) =>
        throttled[0]({
          lengthComputable,
          total,
          loaded,
        }),
      throttled[1],
    ];
  };

  const asyncDecorator =
    (fn) =>
    (...args) =>
      utils$1.asap(() => fn(...args));

  var isURLSameOrigin = platform.hasStandardBrowserEnv
    ? ((origin, isMSIE) => (url) => {
        url = new URL(url, platform.origin);

        return (
          origin.protocol === url.protocol &&
          origin.host === url.host &&
          (isMSIE || origin.port === url.port)
        );
      })(
        new URL(platform.origin),
        platform.navigator &&
          /(msie|trident)/i.test(platform.navigator.userAgent),
      )
    : () => true;

  var cookies = platform.hasStandardBrowserEnv
    ? // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure, sameSite) {
          if (typeof document === "undefined") return;

          const cookie = [`${name}=${encodeURIComponent(value)}`];

          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }

          document.cookie = cookie.join("; ");
        },

        read(name) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(
            new RegExp("(?:^|; )" + name + "=([^;]*)"),
          );
          return match ? decodeURIComponent(match[1]) : null;
        },

        remove(name) {
          this.write(name, "", Date.now() - 86400000, "/");
        },
      }
    : // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {},
        read() {
          return null;
        },
        remove() {},
      };

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   *
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   *
   * @returns {string} The combined URL
   */
  function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "")
      : baseURL;
  }

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   *
   * @returns {string} The combined full path
   */
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  const headersToObject = (thing) =>
    thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   *
   * @returns {Object} New object resulting from merging config2 to config1
   */
  function mergeConfig$1(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};

    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }

    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a, prop, caseless);
      }
    }

    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      }
    }

    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a);
      }
    }

    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(undefined, a);
      }
    }

    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) =>
        mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true),
    };

    utils$1.forEach(
      Object.keys({ ...config1, ...config2 }),
      function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) ||
          (config[prop] = configValue);
      },
    );

    return config;
  }

  var resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);

    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } =
      newConfig;

    newConfig.headers = headers = AxiosHeaders$1.from(headers);

    newConfig.url = buildURL(
      buildFullPath(
        newConfig.baseURL,
        newConfig.url,
        newConfig.allowAbsoluteUrls,
      ),
      config.params,
      config.paramsSerializer,
    );

    // HTTP basic authentication
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " +
          btoa(
            (auth.username || "") +
              ":" +
              (auth.password
                ? unescape(encodeURIComponent(auth.password))
                : ""),
          ),
      );
    }

    if (utils$1.isFormData(data)) {
      if (
        platform.hasStandardBrowserEnv ||
        platform.hasStandardBrowserWebWorkerEnv
      ) {
        headers.setContentType(undefined); // browser handles it
      } else if (utils$1.isFunction(data.getHeaders)) {
        // Node.js FormData (like form-data package)
        const formHeaders = data.getHeaders();
        // Only set safe headers to avoid overwriting security headers
        const allowedHeaders = ["content-type", "content-length"];
        Object.entries(formHeaders).forEach(([key, val]) => {
          if (allowedHeaders.includes(key.toLowerCase())) {
            headers.set(key, val);
          }
        });
      }
    }

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.

    if (platform.hasStandardBrowserEnv) {
      withXSRFToken &&
        utils$1.isFunction(withXSRFToken) &&
        (withXSRFToken = withXSRFToken(newConfig));

      if (
        withXSRFToken ||
        (withXSRFToken !== false && isURLSameOrigin(newConfig.url))
      ) {
        // Add xsrf header
        const xsrfValue =
          xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }

    return newConfig;
  };

  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";

  var xhrAdapter =
    isXHRAdapterSupported &&
    function (config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;

        function done() {
          flushUpload && flushUpload(); // flush events
          flushDownload && flushDownload(); // flush events

          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

          _config.signal &&
            _config.signal.removeEventListener("abort", onCanceled);
        }

        let request = new XMLHttpRequest();

        request.open(_config.method.toUpperCase(), _config.url, true);

        // Set the request timeout in MS
        request.timeout = _config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request &&
              request.getAllResponseHeaders(),
          );
          const responseData =
            !responseType || responseType === "text" || responseType === "json"
              ? request.responseText
              : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request,
          };

          settle(
            function _resolve(value) {
              resolve(value);
              done();
            },
            function _reject(err) {
              reject(err);
              done();
            },
            response,
          );

          // Clean up request
          request = null;
        }

        if ("onloadend" in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (
              request.status === 0 &&
              !(
                request.responseURL &&
                request.responseURL.indexOf("file:") === 0
              )
            ) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(
            new AxiosError$1(
              "Request aborted",
              AxiosError$1.ECONNABORTED,
              config,
              request,
            ),
          );

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError(event) {
          // Browsers deliver a ProgressEvent in XHR onerror
          // (message may be empty; when present, surface it)
          // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError$1(
            msg,
            AxiosError$1.ERR_NETWORK,
            config,
            request,
          );
          // attach the underlying event for consumers who want details
          err.event = event || null;
          reject(err);
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout
            ? "timeout of " + _config.timeout + "ms exceeded"
            : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(
            new AxiosError$1(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError
                ? AxiosError$1.ETIMEDOUT
                : AxiosError$1.ECONNABORTED,
              config,
              request,
            ),
          );

          // Clean up request
          request = null;
        };

        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);

        // Add headers to the request
        if ("setRequestHeader" in request) {
          utils$1.forEach(
            requestHeaders.toJSON(),
            function setRequestHeader(val, key) {
              request.setRequestHeader(key, val);
            },
          );
        }

        // Add withCredentials to request if needed
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }

        // Handle progress if needed
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(
            onDownloadProgress,
            true,
          );
          request.addEventListener("progress", downloadThrottled);
        }

        // Not all browsers support upload events
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] =
            progressEventReducer(onUploadProgress);

          request.upload.addEventListener("progress", uploadThrottled);

          request.upload.addEventListener("loadend", flushUpload);
        }

        if (_config.cancelToken || _config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(
              !cancel || cancel.type
                ? new CanceledError$1(null, config, request)
                : cancel,
            );
            request.abort();
            request = null;
          };

          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted
              ? onCanceled()
              : _config.signal.addEventListener("abort", onCanceled);
          }
        }

        const protocol = parseProtocol(_config.url);

        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(
            new AxiosError$1(
              "Unsupported protocol " + protocol + ":",
              AxiosError$1.ERR_BAD_REQUEST,
              config,
            ),
          );
          return;
        }

        // Send the request
        request.send(requestData || null);
      });
    };

  const composeSignals = (signals, timeout) => {
    const { length } = (signals = signals ? signals.filter(Boolean) : []);

    if (timeout || length) {
      let controller = new AbortController();

      let aborted;

      const onabort = function (reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(
            err instanceof AxiosError$1
              ? err
              : new CanceledError$1(err instanceof Error ? err.message : err),
          );
        }
      };

      let timer =
        timeout &&
        setTimeout(() => {
          timer = null;
          onabort(
            new AxiosError$1(
              `timeout ${timeout} of ms exceeded`,
              AxiosError$1.ETIMEDOUT,
            ),
          );
        }, timeout);

      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal) => {
            signal.unsubscribe
              ? signal.unsubscribe(onabort)
              : signal.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };

      signals.forEach((signal) => signal.addEventListener("abort", onabort));

      const { signal } = controller;

      signal.unsubscribe = () => utils$1.asap(unsubscribe);

      return signal;
    }
  };

  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;

    if (len < chunkSize) {
      yield chunk;
      return;
    }

    let pos = 0;
    let end;

    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };

  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };

  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }

    const reader = stream.getReader();
    try {
      for (;;) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };

  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream, chunkSize);

    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };

    return new ReadableStream(
      {
        async pull(controller) {
          try {
            const { done, value } = await iterator.next();

            if (done) {
              _onFinish();
              controller.close();
              return;
            }

            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = (bytes += len);
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator.return();
        },
      },
      {
        highWaterMark: 2,
      },
    );
  };

  const DEFAULT_CHUNK_SIZE = 64 * 1024;

  const { isFunction } = utils$1;

  const globalFetchAPI = (({ Request, Response }) => ({
    Request,
    Response,
  }))(utils$1.global);

  const { ReadableStream: ReadableStream$1, TextEncoder } = utils$1.global;

  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };

  const factory = (env) => {
    env = utils$1.merge.call(
      {
        skipUndefined: true,
      },
      globalFetchAPI,
      env,
    );

    const { fetch: envFetch, Request, Response } = env;
    const isFetchSupported = envFetch
      ? isFunction(envFetch)
      : typeof fetch === "function";
    const isRequestSupported = isFunction(Request);
    const isResponseSupported = isFunction(Response);

    if (!isFetchSupported) {
      return false;
    }

    const isReadableStreamSupported =
      isFetchSupported && isFunction(ReadableStream$1);

    const encodeText =
      isFetchSupported &&
      (typeof TextEncoder === "function"
        ? (
            (encoder) => (str) =>
              encoder.encode(str)
          )(new TextEncoder())
        : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));

    const supportsRequestStream =
      isRequestSupported &&
      isReadableStreamSupported &&
      test(() => {
        let duplexAccessed = false;

        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          },
        }).headers.has("Content-Type");

        return duplexAccessed && !hasContentType;
      });

    const supportsResponseStream =
      isResponseSupported &&
      isReadableStreamSupported &&
      test(() => utils$1.isReadableStream(new Response("").body));

    const resolvers = {
      stream: supportsResponseStream && ((res) => res.body),
    };

    isFetchSupported &&
      (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(
          (type) => {
            !resolvers[type] &&
              (resolvers[type] = (res, config) => {
                let method = res && res[type];

                if (method) {
                  return method.call(res);
                }

                throw new AxiosError$1(
                  `Response type '${type}' is not supported`,
                  AxiosError$1.ERR_NOT_SUPPORT,
                  config,
                );
              });
          },
        );
      })();

    const getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }

      if (utils$1.isBlob(body)) {
        return body.size;
      }

      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body,
        });
        return (await _request.arrayBuffer()).byteLength;
      }

      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }

      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }

      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };

    const resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());

      return length == null ? getBodyLength(body) : length;
    };

    return async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions,
      } = resolveConfig(config);

      let _fetch = envFetch || fetch;

      responseType = responseType ? (responseType + "").toLowerCase() : "text";

      let composedSignal = composeSignals(
        [signal, cancelToken && cancelToken.toAbortSignal()],
        timeout,
      );

      let request = null;

      const unsubscribe =
        composedSignal &&
        composedSignal.unsubscribe &&
        (() => {
          composedSignal.unsubscribe();
        });

      let requestContentLength;

      try {
        if (
          onUploadProgress &&
          supportsRequestStream &&
          method !== "get" &&
          method !== "head" &&
          (requestContentLength = await resolveBodyLength(headers, data)) !== 0
        ) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half",
          });

          let contentTypeHeader;

          if (
            utils$1.isFormData(data) &&
            (contentTypeHeader = _request.headers.get("content-type"))
          ) {
            headers.setContentType(contentTypeHeader);
          }

          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress)),
            );

            data = trackStream(
              _request.body,
              DEFAULT_CHUNK_SIZE,
              onProgress,
              flush,
            );
          }
        }

        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }

        // Cloudflare Workers throws when credentials are defined
        // see https://github.com/cloudflare/workerd/issues/902
        const isCredentialsSupported =
          isRequestSupported && "credentials" in Request.prototype;

        const resolvedOptions = {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : undefined,
        };

        request = isRequestSupported && new Request(url, resolvedOptions);

        let response = await (isRequestSupported
          ? _fetch(request, fetchOptions)
          : _fetch(url, resolvedOptions));

        const isStreamResponse =
          supportsResponseStream &&
          (responseType === "stream" || responseType === "response");

        if (
          supportsResponseStream &&
          (onDownloadProgress || (isStreamResponse && unsubscribe))
        ) {
          const options = {};

          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });

          const responseContentLength = utils$1.toFiniteNumber(
            response.headers.get("content-length"),
          );

          const [onProgress, flush] =
            (onDownloadProgress &&
              progressEventDecorator(
                responseContentLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true),
              )) ||
            [];

          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options,
          );
        }

        responseType = responseType || "text";

        let responseData = await resolvers[
          utils$1.findKey(resolvers, responseType) || "text"
        ](response, config);

        !isStreamResponse && unsubscribe && unsubscribe();

        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request,
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();

        if (
          err &&
          err.name === "TypeError" &&
          /Load failed|fetch/i.test(err.message)
        ) {
          throw Object.assign(
            new AxiosError$1(
              "Network Error",
              AxiosError$1.ERR_NETWORK,
              config,
              request,
            ),
            {
              cause: err.cause || err,
            },
          );
        }

        throw AxiosError$1.from(err, err && err.code, config, request);
      }
    };
  };

  const seedCache = new Map();

  const getFetch = (config) => {
    let env = (config && config.env) || {};
    const { fetch, Request, Response } = env;
    const seeds = [Request, Response, fetch];

    let len = seeds.length,
      i = len,
      seed,
      target,
      map = seedCache;

    while (i--) {
      seed = seeds[i];
      target = map.get(seed);

      target === undefined &&
        map.set(seed, (target = i ? new Map() : factory(env)));

      map = target;
    }

    return target;
  };

  getFetch();

  /**
   * Known adapters mapping.
   * Provides environment-specific adapters for Axios:
   * - `http` for Node.js
   * - `xhr` for browsers
   * - `fetch` for fetch API-based requests
   *
   * @type {Object<string, Function|Object>}
   */
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: {
      get: getFetch,
    },
  };

  // Assign adapter names for easier debugging and identification
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
        // eslint-disable-next-line no-empty
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });

  /**
   * Render a rejection reason string for unknown or unsupported adapters
   *
   * @param {string} reason
   * @returns {string}
   */
  const renderReason = (reason) => `- ${reason}`;

  /**
   * Check if the adapter is resolved (function, null, or false)
   *
   * @param {Function|null|false} adapter
   * @returns {boolean}
   */
  const isResolvedHandle = (adapter) =>
    utils$1.isFunction(adapter) || adapter === null || adapter === false;

  /**
   * Get the first suitable adapter from the provided list.
   * Tries each adapter in order until a supported one is found.
   * Throws an AxiosError if no adapter is suitable.
   *
   * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.
   * @param {Object} config - Axios request configuration
   * @throws {AxiosError} If no suitable adapter is available
   * @returns {Function} The resolved adapter function
   */
  function getAdapter$1(adapters, config) {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const { length } = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }

      if (
        adapter &&
        (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))
      ) {
        break;
      }

      rejectedReasons[id || "#" + i] = adapter;
    }

    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) =>
          `adapter ${id} ` +
          (state === false
            ? "is not supported by the environment"
            : "is not available in the build"),
      );

      let s = length
        ? reasons.length > 1
          ? "since :\n" + reasons.map(renderReason).join("\n")
          : " " + renderReason(reasons[0])
        : "as no adapter specified";

      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT",
      );
    }

    return adapter;
  }

  /**
   * Exports Axios adapters and utility to resolve an adapter
   */
  var adapters = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter: getAdapter$1,

    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: knownAdapters,
  };

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   *
   * @param {Object} config The config that is to be used for the request
   *
   * @returns {void}
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }

    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    config.headers = AxiosHeaders$1.from(config.headers);

    // Transform request data
    config.data = transformData.call(config, config.transformRequest);

    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }

    const adapter = adapters.getAdapter(
      config.adapter || defaults.adapter,
      config,
    );

    return adapter(config).then(
      function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          config.transformResponse,
          response,
        );

        response.headers = AxiosHeaders$1.from(response.headers);

        return response;
      },
      function onAdapterRejection(reason) {
        if (!isCancel$1(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response,
            );
            reason.response.headers = AxiosHeaders$1.from(
              reason.response.headers,
            );
          }
        }

        return Promise.reject(reason);
      },
    );
  }

  const VERSION$1 = "1.13.2";

  const validators$1 = {};

  // eslint-disable-next-line func-names
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(
    (type, i) => {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    },
  );

  const deprecatedWarnings = {};

  /**
   * Transitional option validator
   *
   * @param {function|boolean?} validator - set to false if the transitional option has been removed
   * @param {string?} version - deprecated version / removed since version
   * @param {string?} message - some message with additional info
   *
   * @returns {function}
   */
  validators$1.transitional = function transitional(
    validator,
    version,
    message,
  ) {
    function formatMessage(opt, desc) {
      return (
        "[Axios v" +
        VERSION$1 +
        "] Transitional option '" +
        opt +
        "'" +
        desc +
        (message ? ". " + message : "")
      );
    }

    // eslint-disable-next-line func-names
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError$1(
          formatMessage(
            opt,
            " has been removed" + (version ? " in " + version : ""),
          ),
          AxiosError$1.ERR_DEPRECATED,
        );
      }

      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        // eslint-disable-next-line no-console
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" +
              version +
              " and will be removed in the near future",
          ),
        );
      }

      return validator ? validator(value, opt, opts) : true;
    };
  };

  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      // eslint-disable-next-line no-console
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };

  /**
   * Assert object's properties type
   *
   * @param {object} options
   * @param {object} schema
   * @param {boolean?} allowUnknown
   *
   * @returns {object}
   */

  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError$1(
        "options must be an object",
        AxiosError$1.ERR_BAD_OPTION_VALUE,
      );
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === undefined || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError$1(
            "option " + opt + " must be " + result,
            AxiosError$1.ERR_BAD_OPTION_VALUE,
          );
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1(
          "Unknown option " + opt,
          AxiosError$1.ERR_BAD_OPTION,
        );
      }
    }
  }

  var validator = {
    assertOptions,
    validators: validators$1,
  };

  const validators = validator.validators;

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   *
   * @return {Axios} A new instance of Axios
   */
  let Axios$1 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager(),
      };
    }

    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};

          Error.captureStackTrace
            ? Error.captureStackTrace(dummy)
            : (dummy = new Error());

          // slice off the Error: ... line
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
              // match without the 2 top stack lines
            } else if (
              stack &&
              !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))
            ) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
            // ignore the case where "stack" is an un-writable property
          }
        }

        throw err;
      }
    }

    _request(configOrUrl, config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }

      config = mergeConfig$1(this.defaults, config);

      const { transitional, paramsSerializer, headers } = config;

      if (transitional !== undefined) {
        validator.assertOptions(
          transitional,
          {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean),
          },
          false,
        );
      }

      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer,
          };
        } else {
          validator.assertOptions(
            paramsSerializer,
            {
              encode: validators.function,
              serialize: validators.function,
            },
            true,
          );
        }
      }

      // Set config.allowAbsoluteUrls
      if (config.allowAbsoluteUrls !== undefined);
      else if (this.defaults.allowAbsoluteUrls !== undefined) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }

      validator.assertOptions(
        config,
        {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken"),
        },
        true,
      );

      // Set config.method
      config.method = (
        config.method ||
        this.defaults.method ||
        "get"
      ).toLowerCase();

      // Flatten headers
      let contextHeaders =
        headers && utils$1.merge(headers.common, headers[config.method]);

      headers &&
        utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          },
        );

      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

      // filter out skipped interceptors
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(
        function unshiftRequestInterceptors(interceptor) {
          if (
            typeof interceptor.runWhen === "function" &&
            interceptor.runWhen(config) === false
          ) {
            return;
          }

          synchronousRequestInterceptors =
            synchronousRequestInterceptors && interceptor.synchronous;

          requestInterceptorChain.unshift(
            interceptor.fulfilled,
            interceptor.rejected,
          );
        },
      );

      const responseInterceptorChain = [];
      this.interceptors.response.forEach(
        function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(
            interceptor.fulfilled,
            interceptor.rejected,
          );
        },
      );

      let promise;
      let i = 0;
      let len;

      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), undefined];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;

        promise = Promise.resolve(config);

        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }

        return promise;
      }

      len = requestInterceptorChain.length;

      let newConfig = config;

      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }

      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      i = 0;
      len = responseInterceptorChain.length;

      while (i < len) {
        promise = promise.then(
          responseInterceptorChain[i++],
          responseInterceptorChain[i++],
        );
      }

      return promise;
    }

    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(
        config.baseURL,
        config.url,
        config.allowAbsoluteUrls,
      );
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };

  // Provide aliases for supported request methods
  utils$1.forEach(
    ["delete", "get", "head", "options"],
    function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios$1.prototype[method] = function (url, config) {
        return this.request(
          mergeConfig$1(config || {}, {
            method,
            url,
            data: (config || {}).data,
          }),
        );
      };
    },
  );

  utils$1.forEach(
    ["post", "put", "patch"],
    function forEachMethodWithData(method) {
      /*eslint func-names:0*/

      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(
            mergeConfig$1(config || {}, {
              method,
              headers: isForm
                ? {
                    "Content-Type": "multipart/form-data",
                  }
                : {},
              url,
              data,
            }),
          );
        };
      }

      Axios$1.prototype[method] = generateHTTPMethod();

      Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
    },
  );

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @param {Function} executor The executor function.
   *
   * @returns {CancelToken}
   */
  let CancelToken$1 = class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }

      let resolvePromise;

      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      const token = this;

      // eslint-disable-next-line func-names
      this.promise.then((cancel) => {
        if (!token._listeners) return;

        let i = token._listeners.length;

        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });

      // eslint-disable-next-line func-names
      this.promise.then = (onfulfilled) => {
        let _resolve;
        // eslint-disable-next-line func-names
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);

        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };

        return promise;
      };

      executor(function cancel(message, config, request) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new CanceledError$1(message, config, request);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }

    /**
     * Subscribe to the cancel signal
     */

    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }

      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }

    /**
     * Unsubscribe from the cancel signal
     */

    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }

    toAbortSignal() {
      const controller = new AbortController();

      const abort = (err) => {
        controller.abort(err);
      };

      this.subscribe(abort);

      controller.signal.unsubscribe = () => this.unsubscribe(abort);

      return controller.signal;
    }

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel,
      };
    }
  };

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   *
   * @returns {Function}
   */
  function spread$1(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   *
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }

  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526,
  };

  Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
    HttpStatusCode$1[value] = key;
  });

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   *
   * @returns {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);

    // Copy axios.prototype to instance
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });

    // Copy context to instance
    utils$1.extend(instance, context, null, { allOwnKeys: true });

    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
    };

    return instance;
  }

  // Create the default instance to be exported
  const axios = createInstance(defaults);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios$1;

  // Expose Cancel & CancelToken
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;

  // Expose AxiosError class
  axios.AxiosError = AxiosError$1;

  // alias for CanceledError for backward compatibility
  axios.Cancel = axios.CanceledError;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread$1;

  // Expose isAxiosError
  axios.isAxiosError = isAxiosError$1;

  // Expose mergeConfig
  axios.mergeConfig = mergeConfig$1;

  axios.AxiosHeaders = AxiosHeaders$1;

  axios.formToJSON = (thing) =>
    formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

  axios.getAdapter = adapters.getAdapter;

  axios.HttpStatusCode = HttpStatusCode$1;

  axios.default = axios;

  // This module is intended to unwrap Axios default export as named.
  // Keep top-level export same with static properties
  // so that it can keep same with es module or cjs
  const {
    Axios,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig,
  } = axios;

  const API_BASE_URL = "https://api.medos.one/v1";

  let sessionToken = null;
  const AuthService = {
    async init(apiKey) {
      try {
        const res = await axios.post(
          `${API_BASE_URL}/auth/session?api_key=${apiKey}`,
          {},
        );
        const token = res.data?.access_token;
        if (!token || typeof token !== "string") {
          throw new Error("Invalid session token response");
        }
        sessionToken = token;
        return token;
      } catch (e) {
        throw new Error(`Failed to initialize session: ${e.message}`);
      }
    },
    getToken() {
      return sessionToken;
    },
    clear() {
      sessionToken = null;
    },
  };

  const COUNTRY_CODES = [
    { code: "+93", label: " Afghanistan +93" },
    { code: "+358", label: " land Islands +358" },
    { code: "+355", label: " Albania +355" },
    { code: "+213", label: " Algeria +213" },
    { code: "+1", label: " American Samoa +1" },
    { code: "+376", label: " Andorra +376" },
    { code: "+244", label: " Angola +244" },
    { code: "+1", label: " Anguilla +1" },
    { code: "+672", label: " Antarctica +672" },
    { code: "+1", label: " Antigua and Barbuda +1" },
    { code: "+54", label: " Argentina +54" },
    { code: "+374", label: " Armenia +374" },
    { code: "+297", label: " Aruba +297" },
    { code: "+61", label: " Australia +61" },
    { code: "+43", label: " Austria +43" },
    { code: "+994", label: " Azerbaijan +994" },
    { code: "+1", label: " Bahamas +1" },
    { code: "+973", label: " Bahrain +973" },
    { code: "+880", label: " Bangladesh +880" },
    { code: "+1", label: " Barbados +1" },
    { code: "+375", label: " Belarus +375" },
    { code: "+32", label: " Belgium +32" },
    { code: "+501", label: " Belize +501" },
    { code: "+229", label: " Benin +229" },
    { code: "+1", label: " Bermuda +1" },
    { code: "+975", label: " Bhutan +975" },
    { code: "+591", label: " Bolivia +591" },
    { code: "+387", label: " Bosnia and Herzegovina +387" },
    { code: "+267", label: " Botswana +267" },
    { code: "+55", label: " Brazil +55" },
    { code: "+246", label: " British Indian Ocean Territory +246" },
    { code: "+1", label: " Brunei +1" },
    { code: "+359", label: " Bulgaria +359" },
    { code: "+226", label: " Burkina Faso +226" },
    { code: "+257", label: " Burundi +257" },
    { code: "+855", label: " Cambodia +855" },
    { code: "+237", label: " Cameroon +237" },
    { code: "+1", label: " Canada +1" },
    { code: "+238", label: " Cape Verde +238" },
    { code: "+1", label: " Cayman Islands +1" },
    { code: "+236", label: " Central African Republic +236" },
    { code: "+235", label: " Chad +235" },
    { code: "+56", label: " Chile +56" },
    { code: "+86", label: " China +86" },
    { code: "+61", label: " Christmas Island +61" },
    { code: "+61", label: " Cocos Islands +61" },
    { code: "+57", label: " Colombia +57" },
    { code: "+269", label: " Comoros +269" },
    { code: "+242", label: " Congo +242" },
    { code: "+243", label: " Congo (Democratic Republic) +243" },
    { code: "+682", label: " Cook Islands +682" },
    { code: "+506", label: " Costa Rica +506" },
    { code: "+385", label: " Croatia +385" },
    { code: "+53", label: " Cuba +53" },
    { code: "+357", label: " Cyprus +357" },
    { code: "+420", label: " Czech Republic +420" },
    { code: "+45", label: " Denmark +45" },
    { code: "+253", label: " Djibouti +253" },
    { code: "+1", label: " Dominica +1" },
    { code: "+1", label: " Dominican Republic +1" },
    { code: "+593", label: " Ecuador +593" },
    { code: "+20", label: " Egypt +20" },
    { code: "+503", label: " El Salvador +503" },
    { code: "+240", label: " Equatorial Guinea +240" },
    { code: "+291", label: " Eritrea +291" },
    { code: "+372", label: " Estonia +372" },
    { code: "+251", label: " Ethiopia +251" },
    { code: "+500", label: " Falkland Islands +500" },
    { code: "+298", label: " Faroe Islands +298" },
    { code: "+679", label: " Fiji +679" },
    { code: "+358", label: " Finland +358" },
    { code: "+33", label: " France +33" },
    { code: "+594", label: " French Guiana +594" },
    { code: "+689", label: " French Polynesia +689" },
    { code: "+508", label: " French Southern Territories +508" },
    { code: "+241", label: " Gabon +241" },
    { code: "+220", label: " Gambia +220" },
    { code: "+995", label: " Georgia +995" },
    { code: "+49", label: " Germany +49" },
    { code: "+233", label: " Ghana +233" },
    { code: "+350", label: " Gibraltar +350" },
    { code: "+30", label: " Greece +30" },
    { code: "+299", label: " Greenland +299" },
    { code: "+1", label: " Grenada +1" },
    { code: "+590", label: " Guadeloupe +590" },
    { code: "+1", label: " Guam +1" },
    { code: "+502", label: " Guatemala +502" },
    { code: "+44", label: " Guernsey +44" },
    { code: "+224", label: " Guinea +224" },
    { code: "+245", label: " Guinea-Bissau +245" },
    { code: "+592", label: " Guyana +592" },
    { code: "+509", label: " Haiti +509" },
    { code: "+504", label: " Honduras +504" },
    { code: "+852", label: " Hong Kong +852" },
    { code: "+36", label: " Hungary +36" },
    { code: "+354", label: " Iceland +354" },
    { code: "+91", label: " India +91" },
    { code: "+62", label: " Indonesia +62" },
    { code: "+98", label: " Iran +98" },
    { code: "+964", label: " Iraq +964" },
    { code: "+353", label: " Ireland +353" },
    { code: "+44", label: " Isle of Man +44" },
    { code: "+972", label: " Israel +972" },
    { code: "+39", label: " Italy +39" },
    { code: "+1", label: " Jamaica +1" },
    { code: "+81", label: " Japan +81" },
    { code: "+44", label: " Jersey +44" },
    { code: "+962", label: " Jordan +962" },
    { code: "+7", label: " Kazakhstan +7" },
    { code: "+254", label: " Kenya +254" },
    { code: "+686", label: " Kiribati +686" },
    { code: "+850", label: " North Korea +850" },
    { code: "+82", label: " South Korea +82" },
    { code: "+965", label: " Kuwait +965" },
    { code: "+996", label: " Kyrgyzstan +996" },
    { code: "+856", label: " Laos +856" },
    { code: "+371", label: " Latvia +371" },
    { code: "+961", label: " Lebanon +961" },
    { code: "+266", label: " Lesotho +266" },
    { code: "+231", label: " Liberia +231" },
    { code: "+218", label: " Libya +218" },
    { code: "+423", label: " Liechtenstein +423" },
    { code: "+370", label: " Lithuania +370" },
    { code: "+352", label: " Luxembourg +352" },
    { code: "+853", label: " Macau +853" },
    { code: "+389", label: " Macedonia +389" },
    { code: "+261", label: " Madagascar +261" },
    { code: "+265", label: " Malawi +265" },
    { code: "+60", label: " Malaysia +60" },
    { code: "+960", label: " Maldives +960" },
    { code: "+223", label: " Mali +223" },
    { code: "+356", label: " Malta +356" },
    { code: "+1", label: " Marshall Islands +1" },
    { code: "+596", label: " Martinique +596" },
    { code: "+222", label: " Mauritania +222" },
    { code: "+230", label: " Mauritius +230" },
    { code: "+262", label: " Mayotte +262" },
    { code: "+52", label: " Mexico +52" },
    { code: "+691", label: " Micronesia +691" },
    { code: "+373", label: " Moldova +373" },
    { code: "+377", label: " Monaco +377" },
    { code: "+976", label: " Mongolia +976" },
    { code: "+382", label: " Montenegro +382" },
    { code: "+1", label: " Montserrat +1" },
    { code: "+212", label: " Morocco +212" },
    { code: "+258", label: " Mozambique +258" },
    { code: "+95", label: " Myanmar +95" },
    { code: "+264", label: " Namibia +264" },
    { code: "+674", label: " Nauru +674" },
    { code: "+977", label: " Nepal +977" },
    { code: "+31", label: " Netherlands +31" },
    { code: "+599", label: " Netherlands Antilles +599" },
    { code: "+687", label: " New Caledonia +687" },
    { code: "+64", label: " New Zealand +64" },
    { code: "+505", label: " Nicaragua +505" },
    { code: "+227", label: " Niger +227" },
    { code: "+234", label: " Nigeria +234" },
    { code: "+683", label: " Niue +683" },
    { code: "+672", label: " Norfolk Island +672" },
    { code: "+1", label: " Northern Mariana Islands +1" },
    { code: "+47", label: " Norway +47" },
    { code: "+968", label: " Oman +968" },
    { code: "+92", label: " Pakistan +92" },
    { code: "+680", label: " Palau +680" },
    { code: "+970", label: " Palestine +970" },
    { code: "+507", label: " Panama +507" },
    { code: "+675", label: " Papua New Guinea +675" },
    { code: "+595", label: " Paraguay +595" },
    { code: "+51", label: " Peru +51" },
    { code: "+63", label: " Philippines +63" },
    { code: "+48", label: " Poland +48" },
    { code: "+351", label: " Portugal +351" },
    { code: "+1", label: " Puerto Rico +1" },
    { code: "+974", label: " Qatar +974" },
    { code: "+262", label: " Runion +262" },
    { code: "+40", label: " Romania +40" },
    { code: "+7", label: " Russia +7" },
    { code: "+250", label: " Rwanda +250" },
    { code: "+590", label: " Saint Barthlemy +590" },
    { code: "+1", label: " Saint Kitts and Nevis +1" },
    { code: "+1", label: " Saint Lucia +1" },
    { code: "+590", label: " Saint Martin +590" },
    { code: "+508", label: " Saint Pierre and Miquelon +508" },
    { code: "+1", label: " Saint Vincent and the Grenadines +1" },
    { code: "+685", label: " Samoa +685" },
    { code: "+378", label: " San Marino +378" },
    { code: "+239", label: " So Tom and Prncipe +239" },
    { code: "+966", label: " Saudi Arabia +966" },
    { code: "+221", label: " Senegal +221" },
    { code: "+381", label: " Serbia +381" },
    { code: "+248", label: " Seychelles +248" },
    { code: "+232", label: " Sierra Leone +232" },
    { code: "+65", label: " Singapore +65" },
    { code: "+421", label: " Slovakia +421" },
    { code: "+386", label: " Slovenia +386" },
    { code: "+677", label: " Solomon Islands +677" },
    { code: "+252", label: " Somalia +252" },
    { code: "+27", label: " South Africa +27" },
    { code: "+34", label: " Spain +34" },
    { code: "+94", label: " Sri Lanka +94" },
    { code: "+249", label: " Sudan +249" },
    { code: "+597", label: " Suriname +597" },
    { code: "+47", label: " Svalbard and Jan Mayen +47" },
    { code: "+268", label: " Swaziland +268" },
    { code: "+46", label: " Sweden +46" },
    { code: "+41", label: " Switzerland +41" },
    { code: "+963", label: " Syria +963" },
    { code: "+886", label: " Taiwan +886" },
    { code: "+992", label: " Tajikistan +992" },
    { code: "+255", label: " Tanzania +255" },
    { code: "+66", label: " Thailand +66" },
    { code: "+670", label: " Timor-Leste +670" },
    { code: "+228", label: " Togo +228" },
    { code: "+690", label: " Tokelau +690" },
    { code: "+676", label: " Tonga +676" },
    { code: "+1", label: " Trinidad and Tobago +1" },
    { code: "+216", label: " Tunisia +216" },
    { code: "+90", label: " Turkey +90" },
    { code: "+993", label: " Turkmenistan +993" },
    { code: "+1", label: " Turks and Caicos Islands +1" },
    { code: "+688", label: " Tuvalu +688" },
    { code: "+256", label: " Uganda +256" },
    { code: "+380", label: " Ukraine +380" },
    { code: "+971", label: " United Arab Emirates +971" },
    { code: "+44", label: " United Kingdom +44" },
    { code: "+1", label: " United States +1" },
    { code: "+598", label: " Uruguay +598" },
    { code: "+998", label: " Uzbekistan +998" },
    { code: "+678", label: " Vanuatu +678" },
    { code: "+39", label: " Vatican City +39" },
    { code: "+58", label: " Venezuela +58" },
    { code: "+84", label: " Vietnam +84" },
    { code: "+1", label: " Virgin Islands (US) +1" },
    { code: "+44", label: " Virgin Islands (UK) +44" },
    { code: "+681", label: " Wallis and Futuna +681" },
    { code: "+212", label: " Western Sahara +212" },
    { code: "+967", label: " Yemen +967" },
    { code: "+260", label: " Zambia +260" },
    { code: "+263", label: " Zimbabwe +263" },
  ];
  const mapBloodGroupToApi = (uiBloodGroup) => {
    const bloodGroupMap = {
      "A+": "A_POSITIVE",
      "A-": "A_NEGATIVE",
      "B+": "B_POSITIVE",
      "B-": "B_NEGATIVE",
      "AB+": "AB_POSITIVE",
      "AB-": "AB_NEGATIVE",
      "O+": "O_POSITIVE",
      "O-": "O_NEGATIVE",
    };
    return bloodGroupMap[uiBloodGroup];
  };

  const WorkspaceService = {
    async fetchWorkspace() {
      try {
        const client = await MedosClient.ensureInitialized();
        const res = await client.get("/workspaces");
        if (!res.data || typeof res.data.workspaceId !== "number") {
          throw new Error("Invalid workspace response");
        }
        return res.data;
      } catch (error) {
        throw new Error(`Failed to fetch workspace: ${error.message}`);
      }
    },
    async fetchTheme() {
      try {
        const workspace = await this.fetchWorkspace();
        return workspace.theme;
      } catch (error) {
        throw new Error(`Failed to fetch workspace theme: ${error.message}`);
      }
    },
  };

  var WorkspaceService$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    WorkspaceService: WorkspaceService,
  });

  const AppointmentService = {
    async arePackagesConfigured() {
      try {
        const workspace = await WorkspaceService.fetchWorkspace();
        return workspace.arePackagesConfigured === true;
      } catch (error) {
        console.warn(
          "Failed to check package configuration, defaulting to legacy endpoint:",
          error,
        );
        return false;
      }
    },
    async getAddresses() {
      const client = await MedosClient.ensureInitialized();
      const res = await client.get("/workspaces");
      const data = res.data ?? res;
      if (data && Array.isArray(data.addressDoctors)) {
        const addresses = data.addressDoctors
          .filter((ad) => ad.address)
          .map((ad) => {
            const addr = ad.address;
            const doctors = (ad.doctors || []).map((d) => ({
              id: Number(d.user.id),
              name:
                `${d.user.firstName || ""} ${d.user.lastName || ""}`.trim() ||
                "Doctor",
              email: d.user.email,
              gender: d.user.gender,
              countryCode: d.user.countryCode,
              phoneNumber: d.user.phoneNumber,
              dob: d.user.dob,
              platform: d.user.platform,
              isKycCompleted: d.user.isKycCompleted,
            }));
            return {
              id: Number(addr.id),
              completeAddress: addr.completeAddress,
              addressLine1: addr.addressLine1,
              addressLine2: addr.addressLine2,
              city: addr.city,
              state: addr.state,
              country: addr.country,
              zipcode: addr.zipcode,
              landmark: addr.landmark,
              phoneNumber: addr.phoneNumber,
              latitude: addr.latitude,
              longitude: addr.longitude,
              doctors,
            };
          });
        return {
          totalAddresses: data.totalAddresses,
          totalDoctors: data.totalDoctors,
          workspaceId: data.workspaceId,
          addresses,
        };
      }
      return { addresses: [] };
    },
    async fetchSlots(workspaceId, addressId, doctorId, appointmentDate) {
      const client = await MedosClient.ensureInitialized();
      console.log(
        "fetching slots",
        workspaceId,
        addressId,
        doctorId,
        appointmentDate,
      );
      const res = await client.get(`/appointments/available-slots`, {
        params: {
          workspaceId,
          addressId,
          doctorId,
          appointmentDate,
        },
      });
      const data = res.data ?? res;
      if (Array.isArray(data)) {
        return data.map((slot) => {
          const {
            appointmentDate: date,
            fromDateTimeTs: fromTime,
            toDateTimeTs: toTime,
          } = slot;
          const start = `${date}T${fromTime}:00`;
          const end = `${date}T${toTime}:00`;
          return {
            start,
            end,
            id: slot.id,
            ...slot,
          };
        });
      }
      return [];
    },
    transformToUnifiedPayload(payload) {
      const bookingType = payload.bookingType || "ONE_TIME_APPOINTMENT";
      if (
        bookingType === "PACKAGE_PURCHASE" ||
        bookingType === "USE_ACTIVE_PACKAGE"
      ) {
        if (!payload.packageConfigId) {
          throw new Error(
            "packageConfigId is required when bookingType is PACKAGE_PURCHASE",
          );
        }
        if (!payload.packageAmount) {
          throw new Error(
            "packageAmount is required when bookingType is PACKAGE_PURCHASE",
          );
        }
      }
      let consultationCharge;
      if (
        bookingType === "PACKAGE_PURCHASE" ||
        bookingType === "USE_ACTIVE_PACKAGE"
      ) {
        consultationCharge = 0;
      } else {
        consultationCharge =
          typeof payload.consultationCharge === "string"
            ? Number.parseFloat(payload.consultationCharge) || 0
            : payload.consultationCharge || 0;
      }
      const completeAddress = [
        payload.patientAddress.addressLine1,
        payload.patientAddress.addressLine2,
        payload.patientAddress.city,
        payload.patientAddress.state,
        payload.patientAddress.country,
        payload.patientAddress.zipcode,
      ]
        .filter(Boolean)
        .join(", ");
      const unifiedPayload = {
        workspaceId: Number(payload.workspaceId || 0),
        workspaceAddressId: Number(payload.workspaceAddressId),
        doctorId: Number(payload.doctorId),
        mode: payload.mode || "OFFLINE",
        appointmentDate: payload.appointmentDate,
        fromDateTimeTs: payload.fromDateTimeTs,
        toDateTimeTs: payload.toDateTimeTs,
        bookingType,
        consultationCharge,
        paymentMode: payload.paymentMode || "CASH",
        type: payload.type || "CONSULTATION",
        source: payload.source || "SDK_POWERED_WEBSITE",
        patientPayload: {
          id: payload.patientPayload.id,
          firstName: payload.patientPayload.firstName,
          lastName: payload.patientPayload.lastName,
          email: payload.patientPayload.email || "",
          countryCode: payload.patientPayload.countryCode,
          phoneNumber: payload.patientPayload.phoneNumber,
          dob: payload.patientPayload.dob || "",
          age: payload.patientPayload.age || 0,
          gender: payload.patientPayload.gender || "OTHER",
          bloodGroup: payload.patientPayload.bloodGroup
            ? mapBloodGroupToApi(payload.patientPayload.bloodGroup)
            : "UNKNOWN",
        },
        patientAddress: {
          completeAddress,
          addressLine1: payload.patientAddress.addressLine1,
          addressLine2: payload.patientAddress.addressLine2,
          city: payload.patientAddress.city,
          state: payload.patientAddress.state,
          country: payload.patientAddress.country,
          zipcode: payload.patientAddress.zipcode,
          landmark: payload.patientAddress.landmark,
          countryCode: payload.patientAddress.countryCode || "",
          phoneNumber: payload.patientAddress.phoneNumber || "",
          patientId: payload.patientAddress.patientId || 0,
        },
      };
      if (
        bookingType === "PACKAGE_PURCHASE" ||
        bookingType === "USE_ACTIVE_PACKAGE"
      ) {
        unifiedPayload.packageConfigId = payload.packageConfigId;
        unifiedPayload.packageAmount = payload.packageAmount;
      }
      if (payload.patientPackageId) {
        unifiedPayload.patientPackageId = payload.patientPackageId;
      }
      return unifiedPayload;
    },
    async createLegacyAppointment(payload) {
      const client = await MedosClient.ensureInitialized();
      const legacyPayload = {
        workspaceAddressId: payload.workspaceAddressId,
        doctorId: payload.doctorId,
        mode: payload.mode || "OFFLINE",
        appointmentDate: payload.appointmentDate,
        fromDateTimeTs: payload.fromDateTimeTs,
        toDateTimeTs: payload.toDateTimeTs,
        consultationCharge: payload.consultationCharge,
        type: payload.type || "CONSULTATION",
        source: payload.source || "SDK_POWERED_WEBSITE",
        patientPayload: payload.patientPayload,
        patientAddress: payload.patientAddress,
      };
      if (payload.attachments && payload.attachments.length > 0) {
        const formData = new FormData();
        const payloadString = JSON.stringify(legacyPayload);
        formData.append("payload", payloadString);
        payload.attachments.forEach((file) => {
          formData.append("attachments", file);
        });
        const res = await client.post(
          "/appointments/book-appointment",
          formData,
        );
        return res.data;
      } else {
        const res = await client.post(
          "/appointments/book-appointment",
          legacyPayload,
          {
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
        return res.data;
      }
    },
    async createAppointment(payload) {
      const packagesConfigured = await this.arePackagesConfigured();
      if (packagesConfigured) {
        return this.createUnifiedAppointment(payload);
      } else {
        return this.createLegacyAppointment(payload);
      }
    },
    async createUnifiedAppointment(payload) {
      const client = await MedosClient.ensureInitialized();
      const unifiedPayload = this.transformToUnifiedPayload(payload);
      if (payload.attachments && payload.attachments.length > 0) {
        const formData = new FormData();
        const payloadString = JSON.stringify(unifiedPayload);
        formData.append("payload", payloadString);
        payload.attachments.forEach((file) => {
          formData.append("attachments", file);
        });
        const res = await client.post(
          "/appointments/book-appointment-unified",
          formData,
        );
        return res.data;
      } else {
        const res = await client.post(
          "/appointments/book-appointment-unified",
          unifiedPayload,
          {
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
        return res.data;
      }
    },
  };

  const PatientService = {
    async sendPhoneVerificationOtp(payload) {
      const client = await MedosClient.ensureInitialized();
      const res = await client.post(
        "/patients/send-phone-verification-otp",
        payload,
      );
      return res.data;
    },
    async verifyPhoneVerificationOtp(payload) {
      const client = await MedosClient.ensureInitialized();
      const res = await client.post(
        "/patients/verify-phone-verification-otp",
        payload,
      );
      return res.data;
    },
  };

  class MedosClient {
    static async init({ apiKey }) {
      if (!apiKey) {
        throw new Error("MedosClient.init() requires 'apiKey'");
      }
      if (this.initPromise) {
        return this.initPromise;
      }
      this.initPromise = (async () => {
        try {
          const sessionToken = await AuthService.init(apiKey);
          this.initializeAxiosInstance(sessionToken, API_BASE_URL);
        } catch (e) {
          this.initPromise = null;
          throw new Error(`MedosClient.init failed: ${e.message}`);
        }
      })();
      return this.initPromise;
    }
    static async initWithSession({ sessionToken }) {
      if (!sessionToken) {
        throw new Error(
          "MedosClient.initWithSession() requires 'sessionToken'",
        );
      }
      if (this.initPromise) {
        return this.initPromise;
      }
      this.initPromise = (async () => {
        try {
          this.initializeAxiosInstance(sessionToken, API_BASE_URL);
        } catch (e) {
          this.initPromise = null;
          throw new Error(`MedosClient.initWithSession failed: ${e.message}`);
        }
      })();
      return this.initPromise;
    }
    static initializeAxiosInstance(sessionToken, baseURL) {
      this.token = sessionToken;
      this.instance = axios.create({
        baseURL,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${sessionToken}`,
        },
      });
      this.instance.interceptors.request.use((config) => {
        if (!config.headers) config.headers = {};
        const headersAny = config.headers;
        const isFormData =
          config.data instanceof FormData ||
          (config.data &&
            typeof config.data === "object" &&
            config.data.constructor &&
            config.data.constructor.name === "FormData");
        if (isFormData) {
          delete headersAny["Content-Type"];
          if (config.headers.common) {
            delete config.headers.common["Content-Type"];
          }
        }
        if (this.token) {
          headersAny["Authorization"] = `Bearer ${this.token}`;
        }
        return config;
      });
      this.instance.interceptors.response.use(
        (response) => response,
        async (error) => {
          const originalRequest = error.config;
          if (
            error.response?.status === 401 &&
            !originalRequest._retry &&
            this.refreshHandler
          ) {
            originalRequest._retry = true;
            if (this.isRefreshing) {
              return new Promise((resolve, reject) => {
                this.pendingRequests.push((token) => {
                  if (token && originalRequest.headers) {
                    originalRequest.headers["Authorization"] =
                      `Bearer ${token}`;
                  }
                  resolve(this.instance.request(originalRequest));
                });
              });
            }
            this.isRefreshing = true;
            try {
              const newToken = await this.refreshHandler();
              this.isRefreshing = false;
              if (newToken) {
                this.setToken(newToken);
              }
              this.pendingRequests.forEach((cb) => cb(newToken));
              this.pendingRequests = [];
              if (newToken && originalRequest.headers) {
                originalRequest.headers["Authorization"] = `Bearer ${newToken}`;
              }
              return this.instance.request(originalRequest);
            } catch (refreshErr) {
              this.isRefreshing = false;
              this.pendingRequests.forEach((cb) => cb(null));
              this.pendingRequests = [];
              return Promise.reject(refreshErr);
            }
          }
          return Promise.reject(error);
        },
      );
    }
    static async fetchAllAddressesAndDoctors() {
      if (!this.instance) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() first.",
        );
      }
      return AppointmentService.getAddresses();
    }
    static async fetchAppointments(
      workspaceId,
      addressId,
      doctorId,
      appointmentDate,
    ) {
      if (!this.instance) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() first.",
        );
      }
      return AppointmentService.fetchSlots(
        workspaceId,
        addressId,
        doctorId,
        appointmentDate,
      );
    }
    static async sendPhoneVerificationOtp(payload) {
      if (!this.instance) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() first.",
        );
      }
      return PatientService.sendPhoneVerificationOtp(payload);
    }
    static async verifyPhoneVerificationOtp(payload) {
      if (!this.instance) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() first.",
        );
      }
      return PatientService.verifyPhoneVerificationOtp(payload);
    }
    static async fetchTheme() {
      if (!this.instance) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() first.",
        );
      }
      const { WorkspaceService } = await Promise.resolve().then(function () {
        return WorkspaceService$1;
      });
      return WorkspaceService.fetchTheme();
    }
    static get client() {
      if (!this.instance && !this.initPromise) {
        throw new Error(
          "MedosClient not initialized. Call MedosClient.init() or MedosClient.initWithSession() first.",
        );
      }
      if (!this.instance && this.initPromise) {
        throw new Error(
          "MedosClient initialization is in progress. Please wait for initialization to complete before accessing the client.",
        );
      }
      return this.instance;
    }
    static async ensureInitialized() {
      if (this.instance) {
        return this.instance;
      }
      if (this.initPromise) {
        await this.initPromise;
        if (this.instance) {
          return this.instance;
        }
      }
      throw new Error(
        "MedosClient not initialized. Call MedosClient.init() or MedosClient.initWithSession() first.",
      );
    }
    static isInitialized() {
      return this.instance !== null;
    }
    static setToken(token) {
      this.token = token;
      if (this.instance) {
        const defaults = this.instance.defaults;
        if (!defaults.headers) defaults.headers = {};
        if (!defaults.headers.common) defaults.headers.common = {};
        defaults.headers.common["Authorization"] = `Bearer ${token}`;
      }
    }
    static setRefreshHandler(handler) {
      this.refreshHandler = handler;
    }
  }
  MedosClient.instance = null;
  MedosClient.token = null;
  MedosClient.refreshHandler = null;
  MedosClient.isRefreshing = false;
  MedosClient.pendingRequests = [];
  MedosClient.initPromise = null;

  const ThemeContext$1 = reactExports.createContext(undefined);
  function MedosThemeProvider({
    children,
    theme,
    cssVariablePrefix = "medos",
    onThemeError,
  }) {
    const [apiTheme, setApiTheme] = React.useState(null);
    React.useEffect(() => {
      if (theme !== undefined) {
        return;
      }
      let isMounted = true;
      const fetchThemeFromApi = async () => {
        try {
          const fetchedTheme = await MedosClient.fetchTheme();
          if (isMounted) {
            if (
              fetchedTheme &&
              (fetchedTheme === "default" || fetchedTheme === "modern")
            ) {
              setApiTheme(fetchedTheme);
            } else {
              setApiTheme(null);
            }
          }
        } catch (error) {
          if (isMounted) {
            if (onThemeError) {
              onThemeError(error);
            } else {
              console.warn(
                "Failed to fetch theme from API, using default theme:",
                error,
              );
            }
          }
        }
      };
      fetchThemeFromApi();
      return () => {
        isMounted = false;
      };
    }, [theme, onThemeError]);
    const resolvedTheme = reactExports.useMemo(() => {
      if (theme !== undefined) {
        if (typeof theme === "string") {
          return themes[theme] || defaultTheme$1;
        }
        if ("name" in theme && "colors" in theme && "typography" in theme) {
          return theme;
        }
        return mergeTheme(theme);
      }
      if (apiTheme) {
        return themes[apiTheme] || defaultTheme$1;
      }
      return defaultTheme$1;
    }, [theme, apiTheme]);
    const cssVars = reactExports.useMemo(
      () => generateCssVariablesObject(resolvedTheme, cssVariablePrefix),
      [resolvedTheme, cssVariablePrefix],
    );
    const contextValue = reactExports.useMemo(
      () => ({
        theme: resolvedTheme,
        cssVars,
        prefix: cssVariablePrefix,
      }),
      [resolvedTheme, cssVars, cssVariablePrefix],
    );
    return jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: contextValue,
      children: jsxRuntimeExports.jsx("div", {
        style: cssVars,
        children: children,
      }),
    });
  }
  function useTheme() {
    const context = React.useContext(ThemeContext$1);
    return context?.theme || defaultTheme$1;
  }

  function useMediaQuery(query) {
    const [matches, setMatches] = reactExports.useState(false);
    reactExports.useEffect(() => {
      const mediaQuery = window.matchMedia(query);
      setMatches(mediaQuery.matches);
      const handler = (event) => {
        setMatches(event.matches);
      };
      if (mediaQuery.addEventListener) {
        mediaQuery.addEventListener("change", handler);
        return () => mediaQuery.removeEventListener("change", handler);
      } else {
        mediaQuery.addListener(handler);
        return () => mediaQuery.removeListener(handler);
      }
    }, [query]);
    return matches;
  }
  function useBreakpoint(theme) {
    const isWide = useMediaQuery(`(min-width: ${theme.breakpoints.wide})`);
    const isDesktop = useMediaQuery(
      `(min-width: ${theme.breakpoints.desktop})`,
    );
    const isTablet = useMediaQuery(`(min-width: ${theme.breakpoints.tablet})`);
    if (isWide) return "wide";
    if (isDesktop) return "desktop";
    if (isTablet) return "tablet";
    return "mobile";
  }

  const BookingOptionStep = ({
    userSessionPacks,
    availablePackages,
    showPackageExplorer,
    selectedNewPackage,
    onSelectOption,
    onSelectPackage,
    onBack,
  }) => {
    const theme = useTheme();
    const breakpoint = useBreakpoint(theme);
    const styles = getStyles(theme, breakpoint);
    const [tempSelectedOption, setTempSelectedOption] = React.useState(null);
    const [tempSelectedPackage, setTempSelectedPackage] = React.useState(null);
    const activePack = userSessionPacks.find(
      (pack) => pack.remainingSessions > 0,
    );
    const hasAvailablePackages = availablePackages.length > 0;
    const handleOptionClick = (optionType, sessionPack) => {
      setTempSelectedOption({ type: optionType, sessionPack });
    };
    const handlePackageSelect = (pkg) => {
      setTempSelectedPackage(pkg);
    };
    const handlePackageNext = () => {
      if (tempSelectedPackage) {
        onSelectPackage(tempSelectedPackage);
      }
    };
    const handleNext = () => {
      if (tempSelectedOption) {
        onSelectOption(
          tempSelectedOption.type,
          tempSelectedOption.sessionPack,
          undefined,
        );
      }
    };
    if (showPackageExplorer) {
      return jsxRuntimeExports.jsxs("div", {
        style: styles.container,
        children: [
          jsxRuntimeExports.jsx("div", {
            style: styles.header,
            children: jsxRuntimeExports.jsx("h3", {
              style: styles.title,
              children: "Explore Packages",
            }),
          }),
          jsxRuntimeExports.jsx("p", {
            style: styles.subtitle,
            children: "Choose a package that suits your needs",
          }),
          hasAvailablePackages
            ? jsxRuntimeExports.jsx("div", {
                style: styles.packagesGrid,
                children: availablePackages.map((pkg) =>
                  jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        ...styles.packageCard,
                        ...(tempSelectedPackage?.id === pkg.id
                          ? styles.packageCardSelected
                          : {}),
                      },
                      onClick: () => handlePackageSelect(pkg),
                      children: [
                        jsxRuntimeExports.jsx("h4", {
                          style: styles.packageName,
                          children: pkg.name,
                        }),
                        jsxRuntimeExports.jsx("p", {
                          style: styles.packageDescription,
                          children: pkg.description,
                        }),
                        pkg.allowedDoctors &&
                          pkg.allowedDoctors.length > 0 &&
                          jsxRuntimeExports.jsx("div", {
                            style: styles.packageDoctors,
                            children: pkg.allowedDoctors.map((doc) =>
                              jsxRuntimeExports.jsx(
                                "span",
                                {
                                  style: styles.doctorBadge,
                                  children: doc.fullName,
                                },
                                doc.id,
                              ),
                            ),
                          }),
                        pkg.allowedConsultationModes &&
                          pkg.allowedConsultationModes.length > 0 &&
                          jsxRuntimeExports.jsx("div", {
                            style: styles.consultationModes,
                            children: pkg.allowedConsultationModes.map((mode) =>
                              jsxRuntimeExports.jsx(
                                "span",
                                {
                                  style: styles.modeBadge,
                                  children:
                                    mode === "ONLINE"
                                      ? " Online"
                                      : " In-Person",
                                },
                                mode,
                              ),
                            ),
                          }),
                        jsxRuntimeExports.jsxs("div", {
                          style: styles.packageDetails,
                          children: [
                            jsxRuntimeExports.jsxs("span", {
                              style: styles.packageSessions,
                              children: [
                                pkg.totalSessions || pkg.sessions,
                                " session",
                                (pkg.totalSessions || pkg.sessions || 1) > 1
                                  ? "s"
                                  : "",
                              ],
                            }),
                            jsxRuntimeExports.jsx("div", {
                              style: styles.priceContainer,
                              children:
                                pkg.discountedPrice &&
                                pkg.discountedPrice < pkg.price
                                  ? jsxRuntimeExports.jsxs(
                                      jsxRuntimeExports.Fragment,
                                      {
                                        children: [
                                          jsxRuntimeExports.jsxs("span", {
                                            style: styles.originalPrice,
                                            children: [
                                              "\u20B9",
                                              pkg.price.toLocaleString(),
                                            ],
                                          }),
                                          jsxRuntimeExports.jsxs("span", {
                                            style: styles.packagePrice,
                                            children: [
                                              "\u20B9",
                                              pkg.discountedPrice.toLocaleString(),
                                            ],
                                          }),
                                          jsxRuntimeExports.jsxs("span", {
                                            style: styles.perSessionPrice,
                                            children: [
                                              "\u20B9",
                                              Math.round(
                                                pkg.discountedPrice /
                                                  (pkg.totalSessions ||
                                                    pkg.sessions ||
                                                    1),
                                              ).toLocaleString(),
                                              "/session",
                                            ],
                                          }),
                                          pkg.discount &&
                                            jsxRuntimeExports.jsx("span", {
                                              style: styles.discountBadge,
                                              children:
                                                pkg.discountType ===
                                                "PERCENTAGE"
                                                  ? `${pkg.discount}% OFF`
                                                  : `${pkg.discount} OFF`,
                                            }),
                                        ],
                                      },
                                    )
                                  : jsxRuntimeExports.jsxs(
                                      jsxRuntimeExports.Fragment,
                                      {
                                        children: [
                                          jsxRuntimeExports.jsxs("span", {
                                            style: styles.packagePrice,
                                            children: [
                                              "\u20B9",
                                              pkg.price.toLocaleString(),
                                            ],
                                          }),
                                          jsxRuntimeExports.jsxs("span", {
                                            style: styles.perSessionPrice,
                                            children: [
                                              "\u20B9",
                                              Math.round(
                                                pkg.price /
                                                  (pkg.totalSessions ||
                                                    pkg.sessions ||
                                                    1),
                                              ).toLocaleString(),
                                              "/session",
                                            ],
                                          }),
                                        ],
                                      },
                                    ),
                            }),
                          ],
                        }),
                        jsxRuntimeExports.jsxs("div", {
                          style: styles.packageValidity,
                          children: ["Valid for ", pkg.validityDays, " days"],
                        }),
                      ],
                    },
                    pkg.id,
                  ),
                ),
              })
            : jsxRuntimeExports.jsx("div", {
                style: styles.emptyState,
                children: jsxRuntimeExports.jsx("p", {
                  children: "No packages available at the moment.",
                }),
              }),
          jsxRuntimeExports.jsxs("div", {
            style: styles.actions,
            children: [
              jsxRuntimeExports.jsx("button", {
                style: styles.backBtn,
                onClick: onBack,
                children: "Back",
              }),
              jsxRuntimeExports.jsx("button", {
                style: {
                  ...styles.nextBtn,
                  ...(tempSelectedPackage ? {} : styles.nextBtnDisabled),
                },
                onClick: handlePackageNext,
                disabled: !tempSelectedPackage,
                children: "Next",
              }),
            ],
          }),
        ],
      });
    }
    return jsxRuntimeExports.jsxs("div", {
      style: styles.container,
      children: [
        jsxRuntimeExports.jsx("h3", {
          style: styles.title,
          children: "Choose Booking Option",
        }),
        jsxRuntimeExports.jsx("p", {
          style: styles.subtitle,
          children: "How would you like to book your appointment?",
        }),
        userSessionPacks.filter((p) => p.remainingSessions > 0).length > 1 &&
          jsxRuntimeExports.jsxs("div", {
            style: styles.sessionPacksSection,
            children: [
              jsxRuntimeExports.jsx("h4", {
                style: styles.sectionTitle,
                children: "Your Active Session Packs",
              }),
              jsxRuntimeExports.jsx("div", {
                style: styles.sessionPacksList,
                children: userSessionPacks
                  .filter((pack) => pack.remainingSessions > 0)
                  .map((pack) =>
                    jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          ...styles.sessionPackCard,
                          ...(tempSelectedOption?.type === "session-pack" &&
                          tempSelectedOption?.sessionPack?.id === pack.id
                            ? styles.sessionPackCardSelected
                            : {}),
                        },
                        onClick: () => handleOptionClick("session-pack", pack),
                        children: [
                          jsxRuntimeExports.jsxs("div", {
                            style: styles.sessionPackInfo,
                            children: [
                              jsxRuntimeExports.jsx("span", {
                                style: styles.sessionPackName,
                                children: pack.name,
                              }),
                              jsxRuntimeExports.jsxs("span", {
                                style: styles.sessionPackRemaining,
                                children: [
                                  pack.remainingSessions,
                                  "/",
                                  pack.totalSessions,
                                  " sessions",
                                ],
                              }),
                              pack.doctorName &&
                                jsxRuntimeExports.jsx("span", {
                                  style: styles.sessionPackDoctor,
                                  children: pack.doctorName,
                                }),
                            ],
                          }),
                          jsxRuntimeExports.jsxs("div", {
                            style: styles.sessionPackExpiry,
                            children: [
                              "Expires: ",
                              new Date(pack.expiryDate).toLocaleDateString(),
                            ],
                          }),
                        ],
                      },
                      pack.id,
                    ),
                  ),
              }),
            ],
          }),
        userSessionPacks.length > 0 &&
          jsxRuntimeExports.jsx("hr", {
            style: {
              margin: "6px 0 6px 0",
              borderTop: `1px solid ${theme.colors.border}`,
            },
          }),
        jsxRuntimeExports.jsxs("div", {
          style: styles.optionsGrid,
          children: [
            activePack &&
              jsxRuntimeExports.jsxs("div", {
                style: {
                  ...styles.optionCard,
                  ...(tempSelectedOption?.type === "session-pack" &&
                  tempSelectedOption?.sessionPack?.id === activePack.id
                    ? styles.optionCardSelected
                    : {}),
                },
                onClick: () => handleOptionClick("session-pack", activePack),
                children: [
                  jsxRuntimeExports.jsx("div", {
                    style: styles.optionIcon,
                    children: "\uD83D\uDCCB",
                  }),
                  jsxRuntimeExports.jsx("h4", {
                    style: styles.optionTitle,
                    children: "Use Session Pack",
                  }),
                  jsxRuntimeExports.jsxs("p", {
                    style: styles.optionDescription,
                    children: [
                      "You have ",
                      activePack.remainingSessions,
                      " session",
                      activePack.remainingSessions > 1 ? "s" : "",
                      " remaining",
                    ],
                  }),
                  jsxRuntimeExports.jsx("div", {
                    style: styles.sessionPackBadge,
                    children: activePack.name,
                  }),
                ],
              }),
            jsxRuntimeExports.jsxs("div", {
              style: {
                ...styles.optionCard,
                ...(tempSelectedOption?.type === "new-appointment"
                  ? styles.optionCardSelected
                  : {}),
              },
              onClick: () => handleOptionClick("new-appointment"),
              children: [
                jsxRuntimeExports.jsx("div", {
                  style: styles.optionIcon,
                  children: "\uD83D\uDCC5",
                }),
                jsxRuntimeExports.jsx("h4", {
                  style: styles.optionTitle,
                  children: "Book New Appointment",
                }),
                jsxRuntimeExports.jsx("p", {
                  style: styles.optionDescription,
                  children: "Schedule a single consultation visit",
                }),
              ],
            }),
            hasAvailablePackages &&
              jsxRuntimeExports.jsxs("div", {
                style: {
                  ...styles.optionCard,
                  ...(tempSelectedOption?.type === "explore-packages"
                    ? styles.optionCardSelected
                    : {}),
                },
                onClick: () => handleOptionClick("explore-packages"),
                children: [
                  jsxRuntimeExports.jsx("div", {
                    style: styles.optionIcon,
                    children: "\uD83C\uDF81",
                  }),
                  jsxRuntimeExports.jsx("h4", {
                    style: styles.optionTitle,
                    children: "Explore Packages",
                  }),
                  jsxRuntimeExports.jsx("p", {
                    style: styles.optionDescription,
                    children: "View and purchase consultation packages",
                  }),
                ],
              }),
          ],
        }),
        jsxRuntimeExports.jsxs("div", {
          style: styles.actions,
          children: [
            jsxRuntimeExports.jsx("button", {
              style: styles.backBtn,
              onClick: onBack,
              children: "Back",
            }),
            jsxRuntimeExports.jsx("button", {
              style: {
                ...styles.nextBtn,
                ...(tempSelectedOption ? {} : styles.nextBtnDisabled),
              },
              onClick: handleNext,
              disabled: !tempSelectedOption,
              children: "Next",
            }),
          ],
        }),
      ],
    });
  };
  const getStyles = (theme, breakpoint) => {
    const isMobile = breakpoint === "mobile";
    const borderRadius = "12px";
    const buttonRadius = "8px";
    const cardBorder = `1px solid ${theme.colors.border}`;
    return {
      container: {
        display: "flex",
        flexDirection: "column",
        gap: 20,
      },
      header: {
        marginBottom: 4,
      },
      title: {
        margin: 0,
        fontSize: isMobile ? 18 : 20,
        fontWeight: 600,
        color: theme.colors.text,
      },
      subtitle: {
        margin: 0,
        fontSize: 14,
        color: theme.colors.textSecondary,
        lineHeight: 1.5,
      },
      optionsGrid: {
        display: "grid",
        gridTemplateColumns: isMobile
          ? "1fr"
          : "repeat(auto-fit, minmax(200px, 1fr))",
        gap: 16,
      },
      optionCard: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        padding: 24,
        border: cardBorder,
        borderRadius,
        cursor: "pointer",
        transition: "all 0.2s ease",
        textAlign: "center",
        backgroundColor: theme.colors.surface,
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.04)",
      },
      optionCardSelected: {
        borderColor: theme.colors.primary,
        backgroundColor: `${theme.colors.primary}08`,
        boxShadow: `0 0 0 1px ${theme.colors.primary}`,
      },
      optionIcon: {
        fontSize: 32,
        marginBottom: 12,
      },
      optionTitle: {
        margin: "0 0 8px 0",
        fontSize: 16,
        fontWeight: 600,
        color: theme.colors.text,
      },
      optionDescription: {
        margin: 0,
        fontSize: 14,
        color: theme.colors.textSecondary,
        lineHeight: 1.5,
      },
      sessionPackBadge: {
        marginTop: 12,
        padding: "6px 14px",
        backgroundColor: theme.colors.successBackground || "#dcfce7",
        color: theme.colors.success || "#166534",
        borderRadius: 999,
        fontSize: 12,
        fontWeight: 500,
      },
      sessionPacksSection: {
        marginBottom: 8,
      },
      sectionTitle: {
        margin: "0 0 16px 0",
        fontSize: 15,
        fontWeight: 600,
        color: theme.colors.text,
      },
      sessionPacksList: {
        display: "flex",
        flexDirection: "column",
        gap: 12,
      },
      sessionPackCard: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: 16,
        border: cardBorder,
        borderRadius,
        cursor: "pointer",
        transition: "all 0.2s ease",
        backgroundColor: theme.colors.surface,
      },
      sessionPackCardSelected: {
        borderColor: theme.colors.primary,
        backgroundColor: `${theme.colors.primary}08`,
      },
      sessionPackInfo: {
        display: "flex",
        flexDirection: "column",
        gap: 4,
      },
      sessionPackName: {
        fontSize: 14,
        fontWeight: 600,
        color: theme.colors.text,
      },
      sessionPackRemaining: {
        fontSize: 13,
        color: theme.colors.textSecondary,
      },
      sessionPackDoctor: {
        fontSize: 13,
        color: theme.colors.textSecondary,
      },
      sessionPackExpiry: {
        fontSize: 12,
        color: theme.colors.error || "#dc2626",
        fontWeight: 500,
      },
      packagesGrid: {
        display: "grid",
        gridTemplateColumns: isMobile
          ? "1fr"
          : "repeat(auto-fit, minmax(250px, 1fr))",
        gap: 16,
      },
      packageCard: {
        display: "flex",
        flexDirection: "column",
        padding: 20,
        border: cardBorder,
        borderRadius,
        cursor: "pointer",
        transition: "all 0.2s ease",
        backgroundColor: theme.colors.surface,
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.04)",
      },
      packageCardSelected: {
        borderColor: theme.colors.primary,
        backgroundColor: `${theme.colors.primary}08`,
        boxShadow: `0 0 0 1px ${theme.colors.primary}`,
      },
      packageName: {
        margin: "0 0 8px 0",
        fontSize: 16,
        fontWeight: 600,
        color: theme.colors.text,
      },
      packageDescription: {
        margin: "0 0 16px 0",
        fontSize: 14,
        color: theme.colors.textSecondary,
        lineHeight: 1.5,
        flex: 1,
      },
      packageDetails: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        paddingTop: 16,
        borderTop: cardBorder,
      },
      packageSessions: {
        fontSize: 13,
        color: theme.colors.textSecondary,
      },
      priceContainer: {
        display: "flex",
        flexDirection: "column",
        alignItems: "flex-end",
        gap: 4,
      },
      originalPrice: {
        fontSize: 14,
        color: theme.colors.textSecondary,
        textDecoration: "line-through",
      },
      packagePrice: {
        fontSize: 18,
        fontWeight: 600,
        color: theme.colors.primary,
      },
      perSessionPrice: {
        fontSize: 12,
        color: theme.colors.textSecondary,
        fontWeight: 500,
      },
      discountBadge: {
        fontSize: 11,
        fontWeight: 600,
        color: "#fff",
        backgroundColor: theme.colors.success || "#16a34a",
        padding: "2px 8px",
        borderRadius: 999,
      },
      packageValidity: {
        marginTop: 8,
        fontSize: 12,
        color: theme.colors.textSecondary,
      },
      packageDoctors: {
        display: "flex",
        flexWrap: "wrap",
        gap: 6,
        marginBottom: 12,
      },
      doctorBadge: {
        fontSize: 12,
        color: theme.colors.text,
        backgroundColor: theme.colors.backgroundSecondary || "#f1f5f9",
        padding: "4px 10px",
        borderRadius: 999,
      },
      consultationModes: {
        display: "flex",
        gap: 8,
        marginBottom: 12,
      },
      modeBadge: {
        fontSize: 11,
        color: theme.colors.textSecondary,
        backgroundColor: theme.colors.backgroundSecondary || "#f1f5f9",
        padding: "4px 8px",
        borderRadius: 6,
      },
      emptyState: {
        textAlign: "center",
        padding: "40px 20px",
        color: theme.colors.textSecondary,
        fontSize: 14,
      },
      actions: {
        display: "flex",
        gap: 12,
        paddingTop: 20,
        justifyContent: "flex-end",
      },
      backBtn: {
        padding: "10px 20px",
        border: cardBorder,
        borderRadius: buttonRadius,
        backgroundColor: theme.colors.surface,
        color: theme.colors.text,
        cursor: "pointer",
        fontSize: 14,
        fontWeight: 600,
        transition: "all 0.2s ease",
        minHeight: 40,
      },
      nextBtn: {
        padding: "10px 24px",
        border: "none",
        borderRadius: buttonRadius,
        backgroundColor: theme.colors.primary,
        color: "#fff",
        cursor: "pointer",
        fontSize: 14,
        fontWeight: 600,
        transition: "all 0.2s ease",
        minHeight: 40,
      },
      nextBtnDisabled: {
        backgroundColor: theme.colors.textSecondary || "#9ca3af",
        cursor: "not-allowed",
        opacity: 0.6,
      },
    };
  };

  function getContainerStyles(theme, prefix = "medos", breakpoint) {
    return {
      container: {
        display: "flex",
        justifyContent: "center",
        padding: "20px",
        fontFamily: theme.typography.fontFamily,
        background: theme.colors.background,
      },
      card: {
        width: "100%",
        maxWidth: 720,
        background: theme.colors.surface,
        borderRadius: "12px",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.08)",
        padding: "24px",
        boxSizing: "border-box",
      },
      header: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "20px",
        flexWrap: "nowrap",
      },
      title: {
        marginLeft: 10,
        fontSize: "20px",
        fontWeight: 600,
        color: theme.colors.text,
        margin: 0,
      },
      section: {
        marginTop: "16px",
      },
      errorMessage: {
        marginBottom: "16px",
        padding: "12px 16px",
        borderRadius: "8px",
        backgroundColor: theme.colors.errorBackground,
        color: theme.colors.error,
        fontWeight: 500,
        fontSize: "14px",
        border: `1px solid ${theme.colors.error}20`,
      },
      content: {
        padding: "24px 0 24px 0",
      },
      actions: {
        display: "flex",
        gap: "12px",
        marginTop: "24px",
        paddingTop: "20px",
        borderTop: `1px solid ${theme.colors.border}`,
        justifyContent: "flex-end",
        flexDirection: "row",
      },
      branding: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "8px",
        marginTop: "24px",
        paddingTop: "16px",
        borderTop: `1px solid ${theme.colors.border}`,
        opacity: 0.8,
      },
      poweredBy: {
        fontSize: "12px",
        color: theme.colors.textSecondary,
        fontWeight: 500,
      },
    };
  }
  function getButtonStyles(theme, prefix = "medos", breakpoint) {
    const isMobile = breakpoint === "mobile";
    const minHeight = isMobile ? "44px" : "40px";
    const basePadding = isMobile ? "12px 20px" : "10px 20px";
    const borderRadius = "8px";
    return {
      primary: {
        background: theme.colors.secondary,
        color: theme.colors.textOnSecondary,
        border: "none",
        padding: basePadding,
        borderRadius,
        cursor: "pointer",
        fontWeight: 600,
        fontSize: "14px",
        transition: "all 0.2s ease",
        minHeight,
        width: isMobile ? "100%" : "auto",
        boxShadow: "0 1px 2px rgba(0, 0, 0, 0.05)",
        lineHeight: "1.5",
      },
      primaryHover: {
        background: theme.colors.secondaryHover,
        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
      },
      primaryDisabled: {
        opacity: 0.6,
        cursor: "not-allowed",
      },
      secondary: {
        background: theme.colors.surface,
        color: theme.colors.primary,
        border: `1px solid ${theme.colors.border}`,
        padding: basePadding,
        borderRadius,
        cursor: "pointer",
        fontWeight: 600,
        fontSize: "14px",
        transition: "all 0.2s ease",
        minHeight,
        width: isMobile ? "100%" : "auto",
        lineHeight: "1.5",
      },
      secondaryHover: {
        background: theme.colors.surfaceHover,
        borderColor: theme.colors.borderHover,
      },
      outline: {
        background: "transparent",
        color: theme.colors.text,
        border: `1px solid ${theme.colors.border}`,
        padding: basePadding,
        borderRadius,
        cursor: "pointer",
        fontWeight: 500,
        fontSize: "14px",
        transition: "all 0.2s ease",
        minHeight,
        width: isMobile ? "100%" : "auto",
        lineHeight: "1.5",
      },
      outlineHover: {
        background: theme.colors.backgroundSecondary,
        borderColor: theme.colors.borderHover,
      },
      ghost: {
        background: "transparent",
        color: theme.colors.primary,
        border: "none",
        padding: basePadding,
        borderRadius,
        cursor: "pointer",
        fontWeight: 500,
        fontSize: "14px",
        transition: "all 0.2s ease",
        minHeight,
        width: isMobile ? "100%" : "auto",
        lineHeight: "1.5",
      },
      ghostHover: {
        background: `${theme.colors.primary}10`,
      },
    };
  }
  function getPhoneVerifyStyles(theme, prefix = "medos", breakpoint) {
    const borderRadius = "12px";
    const cardBorder = `1px solid ${theme.colors.border}`;
    return {
      container: {
        border: cardBorder,
        borderRadius,
        backgroundColor: theme.colors.surface,
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.04)",
      },
      header: {
        padding: "18px 24px",
        borderBottom: cardBorder,
        backgroundColor: theme.colors.primary,
        color: theme.colors.textOnPrimary,
      },
      title: {
        fontSize: "18px",
        fontWeight: 600,
        margin: 0,
        color: theme.colors.textOnPrimary,
      },
      content: {
        padding: "24px",
      },
      label: {
        display: "block",
        fontSize: "14px",
        fontWeight: 500,
        color: theme.colors.text,
        marginBottom: "8px",
      },
      phoneInputContainer: {
        display: "flex",
        gap: "10px",
        flexDirection: "row",
      },
      phoneInput: {
        flex: 1,
        width: "100%",
        padding: "10px 14px",
        borderRadius: "8px",
        border: `1px solid ${theme.colors.border}`,
        fontSize: "14px",
        outline: "none",
        color: theme.colors.text,
        boxSizing: "border-box",
        transition: "border-color 0.2s ease, box-shadow 0.2s ease",
        minHeight: "40px",
        backgroundColor: theme.colors.surface,
      },
      phoneInputFocus: {
        borderColor: theme.colors.primary,
        boxShadow: `0 0 0 3px ${theme.colors.primary}15`,
      },
      phoneDisplay: {
        padding: "10px 14px",
        background: theme.colors.backgroundSecondary,
        borderRadius: "8px",
        fontSize: "14px",
        color: theme.colors.text,
        fontWeight: 500,
        border: `1px solid ${theme.colors.border}`,
      },
      otpInput: {
        width: "100%",
        padding: "10px 14px",
        border: `1px solid ${theme.colors.border}`,
        borderRadius: "8px",
        fontSize: "14px",
        outline: "none",
        color: theme.colors.text,
        boxSizing: "border-box",
        transition: "border-color 0.2s ease, box-shadow 0.2s ease",
        backgroundColor: theme.colors.surface,
      },
      otpInputFocus: {
        borderColor: theme.colors.primary,
        boxShadow: `0 0 0 3px ${theme.colors.primary}15`,
      },
      otpHint: {
        marginTop: "8px",
        fontSize: "12px",
        color: theme.colors.textSecondary,
      },
      successMessage: {
        marginTop: "20px",
        padding: "16px",
        borderRadius: "8px",
        backgroundColor: theme.colors.successBackground,
        border: `1px solid ${theme.colors.success}`,
        display: "flex",
        alignItems: "center",
        gap: "12px",
      },
      successIcon: {
        fontSize: "24px",
        color: theme.colors.success,
      },
      successTitle: {
        fontSize: "14px",
        fontWeight: 600,
        color: theme.colors.success,
      },
      successSubtitle: {
        fontSize: "12px",
        color: theme.colors.textSecondary,
        marginTop: "2px",
      },
      footer: {
        padding: "18px 24px",
        borderTop: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.surface,
        display: "flex",
        gap: "12px",
        justifyContent: "flex-end",
        flexDirection: "row",
      },
    };
  }
  function getPatientDetailsStyles(theme, prefix = "medos", breakpoint) {
    const borderRadius = "12px";
    const cardBorder = `1px solid ${theme.colors.border}`;
    return {
      sectionCard: {
        border: cardBorder,
        borderRadius,
        marginBottom: "24px",
        overflow: "visible",
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.04)",
      },
      sectionHeader: {
        backgroundColor: theme.colors.primary,
        padding: "18px 24px",
        display: "flex",
        alignItems: "center",
        gap: "12px",
        borderBottom: cardBorder,
        color: theme.colors.textOnPrimary,
      },
      sectionTitle: {
        fontSize: "18px",
        fontWeight: 600,
        margin: 0,
        color: theme.colors.textOnPrimary,
      },
      sectionBody: {
        padding: "24px",
      },
      gridRow: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "20px",
        marginTop: "20px",
      },
      label: {
        display: "block",
        fontSize: "14px",
        marginBottom: "8px",
        color: theme.colors.text,
        fontWeight: 500,
      },
      input: {
        width: "100%",
        padding: "10px 14px",
        borderRadius: "8px",
        border: cardBorder,
        outline: "none",
        fontSize: "14px",
        boxSizing: "border-box",
        color: theme.colors.text,
        transition: "border-color 0.2s ease, box-shadow 0.2s ease",
        minHeight: "40px",
        backgroundColor: theme.colors.surface,
      },
      inputFocus: {
        borderColor: theme.colors.primary,
        boxShadow: `0 0 0 3px ${theme.colors.primary}15`,
      },
      phoneDisplay: {
        display: "flex",
        gap: "10px",
        flexDirection: "row",
      },
      phoneCode: {
        width: "100px",
        padding: "10px 14px",
        borderRadius: "8px",
        border: cardBorder,
        backgroundColor: theme.colors.backgroundSecondary,
        fontSize: "14px",
        boxSizing: "border-box",
        color: theme.colors.textSecondary,
      },
      phoneNumber: {
        flex: 1,
        padding: "10px 14px",
        borderRadius: "8px",
        border: cardBorder,
        backgroundColor: theme.colors.backgroundSecondary,
        fontSize: "14px",
        boxSizing: "border-box",
        color: theme.colors.textSecondary,
      },
    };
  }
  function getSuccessStyles(theme, prefix = "medos") {
    return {
      container: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        padding: "32px 24px",
        textAlign: "center",
      },
      header: {
        marginBottom: "24px",
      },
      iconContainer: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: "72px",
        height: "72px",
        borderRadius: "50%",
        backgroundColor: theme.colors.successBackground,
        marginBottom: "20px",
      },
      detailsContainer: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: "12px",
        textAlign: "center",
      },
      detailsTitle: {
        fontWeight: 600,
        fontSize: "18px",
        color: theme.colors.success,
        margin: 0,
      },
      detailsList: {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        fontSize: "14px",
        width: "100%",
        maxWidth: "400px",
        textAlign: "center",
        color: theme.colors.textSecondary,
      },
      confirmationNote: {
        marginTop: "12px",
        fontSize: "14px",
        color: theme.colors.textSecondary,
        lineHeight: "1.5",
      },
      actionContainer: {
        marginTop: "32px",
        display: "flex",
        justifyContent: "center",
      },
    };
  }
  getContainerStyles(defaultTheme$1);
  getButtonStyles(defaultTheme$1);
  getPhoneVerifyStyles(defaultTheme$1);
  getPatientDetailsStyles(defaultTheme$1);
  getSuccessStyles(defaultTheme$1);

  const PHONE_MIN_LENGTH = 7;
  const PHONE_MAX_LENGTH = 15;
  const COUNTRY_CODE_REGEX = /^\+[1-9]\d{0,3}$/;

  const validatePhoneNumber = (phone) => {
    const cleaned = phone.replace(/\D/g, "");
    return (
      cleaned.length >= PHONE_MIN_LENGTH && cleaned.length <= PHONE_MAX_LENGTH
    );
  };
  const validateCountryCode = (code) => {
    return COUNTRY_CODE_REGEX.test(code);
  };

  function _typeof(o) {
    "@babel/helpers - typeof";

    return (
      (_typeof =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (o) {
              return typeof o;
            }
          : function (o) {
              return o &&
                "function" == typeof Symbol &&
                o.constructor === Symbol &&
                o !== Symbol.prototype
                ? "symbol"
                : typeof o;
            }),
      _typeof(o)
    );
  }

  function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != _typeof(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
  }

  function _defineProperty(e, r, t) {
    return (
      (r = toPropertyKey(r)) in e
        ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        : (e[r] = t),
      e
    );
  }

  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      (r &&
        (o = o.filter(function (r) {
          return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })),
        t.push.apply(t, o));
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2
        ? ownKeys(Object(t), true).forEach(function (r) {
            _defineProperty(e, r, t[r]);
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
          : ownKeys(Object(t)).forEach(function (r) {
              Object.defineProperty(
                e,
                r,
                Object.getOwnPropertyDescriptor(t, r),
              );
            });
    }
    return e;
  }

  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }

  function _iterableToArrayLimit(r, l) {
    var t =
      null == r
        ? null
        : ("undefined" != typeof Symbol && r[Symbol.iterator]) ||
          r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = true,
        o = false;
      try {
        if (((i = (t = t.call(r)).next), 0 === l)) {
          if (Object(t) !== t) return;
          f = !1;
        } else
          for (
            ;
            !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l);
            f = !0
          );
      } catch (r) {
        ((o = true), (n = r));
      } finally {
        try {
          if (
            !f &&
            null != t["return"] &&
            ((u = t["return"]()), Object(u) !== u)
          )
            return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }

  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return (
        "Object" === t && r.constructor && (t = r.constructor.name),
        "Map" === t || "Set" === t
          ? Array.from(r)
          : "Arguments" === t ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
            ? _arrayLikeToArray(r, a)
            : void 0
      );
    }
  }

  function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
    );
  }

  function _slicedToArray(r, e) {
    return (
      _arrayWithHoles(r) ||
      _iterableToArrayLimit(r, e) ||
      _unsupportedIterableToArray(r, e) ||
      _nonIterableRest()
    );
  }

  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r)
      if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
    return t;
  }

  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o,
      r,
      i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++)
        ((o = n[r]),
          -1 === t.indexOf(o) &&
            {}.propertyIsEnumerable.call(e, o) &&
            (i[o] = e[o]));
    }
    return i;
  }

  var _excluded$6 = [
    "defaultInputValue",
    "defaultMenuIsOpen",
    "defaultValue",
    "inputValue",
    "menuIsOpen",
    "onChange",
    "onInputChange",
    "onMenuClose",
    "onMenuOpen",
    "value",
  ];
  function useStateManager(_ref) {
    var _ref$defaultInputValu = _ref.defaultInputValue,
      defaultInputValue =
        _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu,
      _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
      defaultMenuIsOpen =
        _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
      _ref$defaultValue = _ref.defaultValue,
      defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
      propsInputValue = _ref.inputValue,
      propsMenuIsOpen = _ref.menuIsOpen,
      propsOnChange = _ref.onChange,
      propsOnInputChange = _ref.onInputChange,
      propsOnMenuClose = _ref.onMenuClose,
      propsOnMenuOpen = _ref.onMenuOpen,
      propsValue = _ref.value,
      restSelectProps = _objectWithoutProperties(_ref, _excluded$6);
    var _useState = reactExports.useState(
        propsInputValue !== undefined ? propsInputValue : defaultInputValue,
      ),
      _useState2 = _slicedToArray(_useState, 2),
      stateInputValue = _useState2[0],
      setStateInputValue = _useState2[1];
    var _useState3 = reactExports.useState(
        propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen,
      ),
      _useState4 = _slicedToArray(_useState3, 2),
      stateMenuIsOpen = _useState4[0],
      setStateMenuIsOpen = _useState4[1];
    var _useState5 = reactExports.useState(
        propsValue !== undefined ? propsValue : defaultValue,
      ),
      _useState6 = _slicedToArray(_useState5, 2),
      stateValue = _useState6[0],
      setStateValue = _useState6[1];
    var onChange = reactExports.useCallback(
      function (value, actionMeta) {
        if (typeof propsOnChange === "function") {
          propsOnChange(value, actionMeta);
        }
        setStateValue(value);
      },
      [propsOnChange],
    );
    var onInputChange = reactExports.useCallback(
      function (value, actionMeta) {
        var newValue;
        if (typeof propsOnInputChange === "function") {
          newValue = propsOnInputChange(value, actionMeta);
        }
        setStateInputValue(newValue !== undefined ? newValue : value);
      },
      [propsOnInputChange],
    );
    var onMenuOpen = reactExports.useCallback(
      function () {
        if (typeof propsOnMenuOpen === "function") {
          propsOnMenuOpen();
        }
        setStateMenuIsOpen(true);
      },
      [propsOnMenuOpen],
    );
    var onMenuClose = reactExports.useCallback(
      function () {
        if (typeof propsOnMenuClose === "function") {
          propsOnMenuClose();
        }
        setStateMenuIsOpen(false);
      },
      [propsOnMenuClose],
    );
    var inputValue =
      propsInputValue !== undefined ? propsInputValue : stateInputValue;
    var menuIsOpen =
      propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
    var value = propsValue !== undefined ? propsValue : stateValue;
    return _objectSpread2(
      _objectSpread2({}, restSelectProps),
      {},
      {
        inputValue: inputValue,
        menuIsOpen: menuIsOpen,
        onChange: onChange,
        onInputChange: onInputChange,
        onMenuClose: onMenuClose,
        onMenuOpen: onMenuOpen,
        value: value,
      },
    );
  }

  function _extends() {
    return (
      (_extends = Object.assign
        ? Object.assign.bind()
        : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }),
      _extends.apply(null, arguments)
    );
  }

  function _classCallCheck(a, n) {
    if (!(a instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }

  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      ((o.enumerable = o.enumerable || false),
        (o.configurable = true),
        "value" in o && (o.writable = true),
        Object.defineProperty(e, toPropertyKey(o.key), o));
    }
  }
  function _createClass(e, r, t) {
    return (
      r && _defineProperties(e.prototype, r),
      t && _defineProperties(e, t),
      Object.defineProperty(e, "prototype", {
        writable: false,
      }),
      e
    );
  }

  function _setPrototypeOf(t, e) {
    return (
      (_setPrototypeOf = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return ((t.__proto__ = e), t);
          }),
      _setPrototypeOf(t, e)
    );
  }

  function _inherits(t, e) {
    if ("function" != typeof e && null !== e)
      throw new TypeError("Super expression must either be null or a function");
    ((t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true,
      },
    })),
      Object.defineProperty(t, "prototype", {
        writable: false,
      }),
      e && _setPrototypeOf(t, e));
  }

  function _getPrototypeOf(t) {
    return (
      (_getPrototypeOf = Object.setPrototypeOf
        ? Object.getPrototypeOf.bind()
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          }),
      _getPrototypeOf(t)
    );
  }

  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {}),
      );
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }

  function _assertThisInitialized(e) {
    if (void 0 === e)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      );
    return e;
  }

  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e)
      throw new TypeError(
        "Derived constructors may only return object or undefined",
      );
    return _assertThisInitialized(t);
  }

  function _createSuper(t) {
    var r = _isNativeReflectConstruct();
    return function () {
      var e,
        o = _getPrototypeOf(t);
      if (r) {
        var s = _getPrototypeOf(this).constructor;
        e = Reflect.construct(o, arguments, s);
      } else e = o.apply(this, arguments);
      return _possibleConstructorReturn(this, e);
    };
  }

  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }

  function _iterableToArray(r) {
    if (
      ("undefined" != typeof Symbol && null != r[Symbol.iterator]) ||
      null != r["@@iterator"]
    )
      return Array.from(r);
  }

  function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
    );
  }

  function _toConsumableArray(r) {
    return (
      _arrayWithoutHoles(r) ||
      _iterableToArray(r) ||
      _unsupportedIterableToArray(r) ||
      _nonIterableSpread()
    );
  }

  /*

	Based off glamor's StyleSheet, thanks Sunil 

	high performance StyleSheet for css-in-js systems

	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance

	// usage

	import { StyleSheet } from '@emotion/sheet'

	let styleSheet = new StyleSheet({ key: '', container: document.head })

	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet

	styleSheet.flush()
	- empties the stylesheet of all its contents

	*/

  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    } // this weirdness brought to you by firefox

    /* istanbul ignore next */

    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    } // this function should always return with a value
    // TS can't understand it though so we make it stop complaining here

    return undefined;
  }

  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);

    if (options.nonce !== undefined) {
      tag.setAttribute("nonce", options.nonce);
    }

    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }

  var StyleSheet = /*#__PURE__*/ (function () {
    // Using Node instead of HTMLElement since container may be a ShadowRoot
    function StyleSheet(options) {
      var _this = this;

      this._insertTag = function (tag) {
        var before;

        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }

        _this.container.insertBefore(tag, before);

        _this.tags.push(tag);
      };

      this.isSpeedy = options.speedy === undefined ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }

    var _proto = StyleSheet.prototype;

    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };

    _proto.insert = function insert(rule) {
      // the max length is how many rules we have per style tag, it's 65000 in speedy mode
      // it's 1 in dev because we insert source maps that map a single rule to a location
      // and you can only have one source map per style tag
      if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }

      var tag = this.tags[this.tags.length - 1];

      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);

        try {
          // this is the ultrafast version, works across browsers
          // the big drawback is that the css won't be editable in devtools
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {}
      } else {
        tag.appendChild(document.createTextNode(rule));
      }

      this.ctr++;
    };

    _proto.flush = function flush() {
      this.tags.forEach(function (tag) {
        var _tag$parentNode;

        return (_tag$parentNode = tag.parentNode) == null
          ? void 0
          : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };

    return StyleSheet;
  })();

  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";

  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  /**
   * @param {number}
   * @return {number}
   */
  var abs = Math.abs;

  /**
   * @param {number}
   * @return {string}
   */
  var from = String.fromCharCode;

  /**
   * @param {object}
   * @return {object}
   */
  var assign = Object.assign;

  /**
   * @param {string} value
   * @param {number} length
   * @return {number}
   */
  function hash(value, length) {
    return charat(value, 0) ^ 45
      ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) <<
          2) ^
          charat(value, 2)) <<
          2) ^
          charat(value, 3)
      : 0;
  }

  /**
   * @param {string} value
   * @return {string}
   */
  function trim(value) {
    return value.trim();
  }

  /**
   * @param {string} value
   * @param {RegExp} pattern
   * @return {string?}
   */
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }

  /**
   * @param {string} value
   * @param {(string|RegExp)} pattern
   * @param {string} replacement
   * @return {string}
   */
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }

  /**
   * @param {string} value
   * @param {string} search
   * @return {number}
   */
  function indexof(value, search) {
    return value.indexOf(search);
  }

  /**
   * @param {string} value
   * @param {number} index
   * @return {number}
   */
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }

  /**
   * @param {string} value
   * @param {number} begin
   * @param {number} end
   * @return {string}
   */
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }

  /**
   * @param {string} value
   * @return {number}
   */
  function strlen(value) {
    return value.length;
  }

  /**
   * @param {any[]} value
   * @return {number}
   */
  function sizeof(value) {
    return value.length;
  }

  /**
   * @param {any} value
   * @param {any[]} array
   * @return {any}
   */
  function append(value, array) {
    return (array.push(value), value);
  }

  /**
   * @param {string[]} array
   * @param {function} callback
   * @return {string}
   */
  function combine(array, callback) {
    return array.map(callback).join("");
  }

  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";

  /**
   * @param {string} value
   * @param {object | null} root
   * @param {object | null} parent
   * @param {string} type
   * @param {string[] | string} props
   * @param {object[] | string} children
   * @param {number} length
   */
  function node(value, root, parent, type, props, children, length) {
    return {
      value: value,
      root: root,
      parent: parent,
      type: type,
      props: props,
      children: children,
      line: line,
      column: column,
      length: length,
      return: "",
    };
  }

  /**
   * @param {object} root
   * @param {object} props
   * @return {object}
   */
  function copy(root, props) {
    return assign(
      node("", null, null, "", null, null, 0),
      root,
      { length: -root.length },
      props,
    );
  }

  /**
   * @return {number}
   */
  function char() {
    return character;
  }

  /**
   * @return {number}
   */
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;

    if ((column--, character === 10)) ((column = 1), line--);

    return character;
  }

  /**
   * @return {number}
   */
  function next() {
    character = position < length ? charat(characters, position++) : 0;

    if ((column++, character === 10)) ((column = 1), line++);

    return character;
  }

  /**
   * @return {number}
   */
  function peek() {
    return charat(characters, position);
  }

  /**
   * @return {number}
   */
  function caret() {
    return position;
  }

  /**
   * @param {number} begin
   * @param {number} end
   * @return {string}
   */
  function slice(begin, end) {
    return substr(characters, begin, end);
  }

  /**
   * @param {number} type
   * @return {number}
   */
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }

    return 0;
  }

  /**
   * @param {string} value
   * @return {any[]}
   */
  function alloc(value) {
    return (
      (line = column = 1),
      (length = strlen((characters = value))),
      (position = 0),
      []
    );
  }

  /**
   * @param {any} value
   * @return {any}
   */
  function dealloc(value) {
    return ((characters = ""), value);
  }

  /**
   * @param {number} type
   * @return {string}
   */
  function delimit(type) {
    return trim(
      slice(
        position - 1,
        delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type),
      ),
    );
  }

  /**
   * @param {number} type
   * @return {string}
   */
  function whitespace(type) {
    while ((character = peek()))
      if (character < 33) next();
      else break;

    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }

  /**
   * @param {number} index
   * @param {number} count
   * @return {string}
   */
  function escaping(index, count) {
    while (--count && next())
      // not 0-9 A-F a-f
      if (
        character < 48 ||
        character > 102 ||
        (character > 57 && character < 65) ||
        (character > 70 && character < 97)
      )
        break;

    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }

  /**
   * @param {number} type
   * @return {number}
   */
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39) delimiter(character);
          break;
        // (
        case 40:
          if (type === 41) delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }

    return position;
  }

  /**
   * @param {number} type
   * @param {number} index
   * @return {number}
   */
  function commenter(type, index) {
    while (next())
      // //
      if (type + character === 47 + 10) break;
      // /*
      else if (type + character === 42 + 42 && peek() === 47) break;

    return (
      "/*" +
      slice(index, position - 1) +
      "*" +
      from(type === 47 ? type : next())
    );
  }

  /**
   * @param {number} index
   * @return {string}
   */
  function identifier(index) {
    while (!token(peek())) next();

    return slice(index, position);
  }

  /**
   * @param {string} value
   * @return {object[]}
   */
  function compile(value) {
    return dealloc(
      parse("", null, null, null, [""], (value = alloc(value)), 0, [0], value),
    );
  }

  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {string[]} rule
   * @param {string[]} rules
   * @param {string[]} rulesets
   * @param {number[]} pseudo
   * @param {number[]} points
   * @param {string[]} declarations
   * @return {object}
   */
  function parse(
    value,
    root,
    parent,
    rule,
    rules,
    rulesets,
    pseudo,
    points,
    declarations,
  ) {
    var index = 0;
    var offset = 0;
    var length = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters = type;

    while (scanning)
      switch (((previous = character), (character = next()))) {
        // (
        case 40:
          if (previous != 108 && charat(characters, length - 1) == 58) {
            if (
              indexof(
                (characters += replace(delimit(character), "&", "&\f")),
                "&\f",
              ) != -1
            )
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters += delimit(character);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters += whitespace(previous);
          break;
        // \
        case 92:
          characters += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(
                comment(commenter(next(), caret()), root, parent),
                declarations,
              );
              break;
            default:
              characters += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index++] = strlen(characters) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset:
              if (ampersand == -1) characters = replace(characters, /\f/g, "");
              if (property > 0 && strlen(characters) - length)
                append(
                  property > 32
                    ? declaration(characters + ";", rule, parent, length - 1)
                    : declaration(
                        replace(characters, " ", "") + ";",
                        rule,
                        parent,
                        length - 2,
                      ),
                  declarations,
                );
              break;
            // @ ;
            case 59:
              characters += ";";
            // { rule/at-rule
            default:
              append(
                (reference = ruleset(
                  characters,
                  root,
                  parent,
                  index,
                  offset,
                  rules,
                  points,
                  type,
                  (props = []),
                  (children = []),
                  length,
                )),
                rulesets,
              );

              if (character === 123)
                if (offset === 0)
                  parse(
                    characters,
                    root,
                    reference,
                    reference,
                    props,
                    rulesets,
                    length,
                    points,
                    children,
                  );
                else
                  switch (
                    atrule === 99 && charat(characters, 3) === 110
                      ? 100
                      : atrule
                  ) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(
                        value,
                        reference,
                        reference,
                        rule &&
                          append(
                            ruleset(
                              value,
                              reference,
                              reference,
                              0,
                              0,
                              rules,
                              points,
                              type,
                              rules,
                              (props = []),
                              length,
                            ),
                            children,
                          ),
                        rules,
                        children,
                        length,
                        points,
                        rule ? props : children,
                      );
                      break;
                    default:
                      parse(
                        characters,
                        reference,
                        reference,
                        reference,
                        [""],
                        children,
                        0,
                        points,
                        children,
                      );
                  }
          }

          ((index = offset = property = 0),
            (variable = ampersand = 1),
            (type = characters = ""),
            (length = pseudo));
          break;
        // :
        case 58:
          ((length = 1 + strlen(characters)), (property = previous));
        default:
          if (variable < 1)
            if (character == 123) --variable;
            else if (character == 125 && variable++ == 0 && prev() == 125)
              continue;

          switch (((characters += from(character)), character * variable)) {
            // &
            case 38:
              ampersand = offset > 0 ? 1 : ((characters += "\f"), -1);
              break;
            // ,
            case 44:
              ((points[index++] = (strlen(characters) - 1) * ampersand),
                (ampersand = 1));
              break;
            // @
            case 64:
              // -
              if (peek() === 45) characters += delimit(next());

              ((atrule = peek()),
                (offset = length =
                  strlen((type = characters += identifier(caret())))),
                character++);
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters) == 2) variable = 0;
          }
      }

    return rulesets;
  }

  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {number} index
   * @param {number} offset
   * @param {string[]} rules
   * @param {number[]} points
   * @param {string} type
   * @param {string[]} props
   * @param {string[]} children
   * @param {number} length
   * @return {object}
   */
  function ruleset(
    value,
    root,
    parent,
    index,
    offset,
    rules,
    points,
    type,
    props,
    children,
    length,
  ) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);

    for (var i = 0, j = 0, k = 0; i < index; ++i)
      for (
        var x = 0,
          y = substr(value, post + 1, (post = abs((j = points[i])))),
          z = value;
        x < size;
        ++x
      )
        if ((z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))))
          props[k++] = z;

    return node(
      value,
      root,
      parent,
      offset === 0 ? RULESET : type,
      props,
      children,
      length,
    );
  }

  /**
   * @param {number} value
   * @param {object} root
   * @param {object?} parent
   * @return {object}
   */
  function comment(value, root, parent) {
    return node(
      value,
      root,
      parent,
      COMMENT,
      from(char()),
      substr(value, 2, -2),
      0,
    );
  }

  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {number} length
   * @return {object}
   */
  function declaration(value, root, parent, length) {
    return node(
      value,
      root,
      parent,
      DECLARATION,
      substr(value, 0, length),
      substr(value, length + 1, -1),
      length,
    );
  }

  /**
   * @param {object[]} children
   * @param {function} callback
   * @return {string}
   */
  function serialize(children, callback) {
    var output = "";
    var length = sizeof(children);

    for (var i = 0; i < length; i++)
      output += callback(children[i], i, children, callback) || "";

    return output;
  }

  /**
   * @param {object} element
   * @param {number} index
   * @param {object[]} children
   * @param {function} callback
   * @return {string}
   */
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return (element.return = element.return || element.value);
      case COMMENT:
        return "";
      case KEYFRAMES:
        return (element.return =
          element.value + "{" + serialize(element.children, callback) + "}");
      case RULESET:
        element.value = element.props.join(",");
    }

    return strlen((children = serialize(element.children, callback)))
      ? (element.return = element.value + "{" + children + "}")
      : "";
  }

  /**
   * @param {function[]} collection
   * @return {function}
   */
  function middleware(collection) {
    var length = sizeof(collection);

    return function (element, index, children, callback) {
      var output = "";

      for (var i = 0; i < length; i++)
        output += collection[i](element, index, children, callback) || "";

      return output;
    };
  }

  /**
   * @param {function} callback
   * @return {function}
   */
  function rulesheet(callback) {
    return function (element) {
      if (!element.root) if ((element = element.return)) callback(element);
    };
  }

  function memoize(fn) {
    var cache = Object.create(null);
    return function (arg) {
      if (cache[arg] === undefined) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  var identifierWithPointTracking = function identifierWithPointTracking(
    begin,
    points,
    index,
  ) {
    var previous = 0;
    var character = 0;

    while (true) {
      previous = character;
      character = peek(); // &\f

      if (previous === 38 && character === 12) {
        points[index] = 1;
      }

      if (token(character)) {
        break;
      }

      next();
    }

    return slice(begin, position);
  };

  var toRules = function toRules(parsed, points) {
    // pretend we've started with a comma
    var index = -1;
    var character = 44;

    do {
      switch (token(character)) {
        case 0:
          // &\f
          if (character === 38 && peek() === 12) {
            // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
            // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
            // and when it should just concatenate the outer and inner selectors
            // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
            points[index] = 1;
          }

          parsed[index] += identifierWithPointTracking(
            position - 1,
            points,
            index,
          );
          break;

        case 2:
          parsed[index] += delimit(character);
          break;

        case 4:
          // comma
          if (character === 44) {
            // colon
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }

        // fallthrough

        default:
          parsed[index] += from(character);
      }
    } while ((character = next()));

    return parsed;
  };

  var getRules = function getRules(value, points) {
    return dealloc(toRules(alloc(value), points));
  }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

  var fixedElements = /* #__PURE__ */ new WeakMap();
  var compat = function compat(element) {
    if (
      element.type !== "rule" ||
      !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1
    ) {
      return;
    }

    var value = element.value;
    var parent = element.parent;
    var isImplicitRule =
      element.column === parent.column && element.line === parent.line;

    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    } // short-circuit for the simplest case

    if (
      element.props.length === 1 &&
      value.charCodeAt(0) !== 58 &&
      /* colon */
      !fixedElements.get(parent)
    ) {
      return;
    } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
    // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

    if (isImplicitRule) {
      return;
    }

    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;

    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i]
          ? rules[i].replace(/&\f/g, parentRules[j])
          : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel(element) {
    if (element.type === "decl") {
      var value = element.value;

      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        // this ignores label
        element["return"] = "";
        element.value = "";
      }
    }
  };

  /* eslint-disable no-fallthrough */

  function prefix(value, length) {
    switch (hash(value, length)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust

      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction

      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order

      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items

      case 5187:
        return (
          WEBKIT +
          value +
          replace(
            value,
            /(\w+).+(:[^]+)/,
            WEBKIT + "box-$1$2" + MS + "flex-$1$2",
          ) +
          value
        );
      // align-self

      case 5443:
        return (
          WEBKIT +
          value +
          MS +
          "flex-item-" +
          replace(value, /flex-|-self/, "") +
          value
        );
      // align-content

      case 4675:
        return (
          WEBKIT +
          value +
          MS +
          "flex-line-pack" +
          replace(value, /align-content|flex-|-self/, "") +
          value
        );
      // flex-shrink

      case 5548:
        return (
          WEBKIT + value + MS + replace(value, "shrink", "negative") + value
        );
      // flex-basis

      case 5292:
        return (
          WEBKIT +
          value +
          MS +
          replace(value, "basis", "preferred-size") +
          value
        );
      // flex-grow

      case 6060:
        return (
          WEBKIT +
          "box-" +
          replace(value, "-grow", "") +
          WEBKIT +
          value +
          MS +
          replace(value, "grow", "positive") +
          value
        );
      // transition

      case 4554:
        return (
          WEBKIT +
          replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") +
          value
        );
      // cursor

      case 6187:
        return (
          replace(
            replace(
              replace(value, /(zoom-|grab)/, WEBKIT + "$1"),
              /(image-set)/,
              WEBKIT + "$1",
            ),
            value,
            "",
          ) + value
        );
      // background, background-image

      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1" + "$`$1");
      // justify-content

      case 4968:
        return (
          replace(
            replace(
              value,
              /(.+:)(flex-)?(.*)/,
              WEBKIT + "box-pack:$3" + MS + "flex-pack:$3",
            ),
            /s.+-b[^;]+/,
            "justify",
          ) +
          WEBKIT +
          value +
          value
        );
      // (margin|padding)-inline-(start|end)

      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)

      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        // stretch, max-content, min-content, fill-available
        if (strlen(value) - 1 - length > 6)
          switch (charat(value, length + 1)) {
            // (m)ax-content, (m)in-content
            case 109:
              // -
              if (charat(value, length + 4) !== 45) break;
            // (f)ill-available, (f)it-content

            case 102:
              return (
                replace(
                  value,
                  /(.+:)(.+)-([^]+)/,
                  "$1" +
                    WEBKIT +
                    "$2-$3" +
                    "$1" +
                    MOZ +
                    (charat(value, length + 3) == 108 ? "$3" : "$2-$3"),
                ) + value
              );
            // (s)tretch

            case 115:
              return ~indexof(value, "stretch")
                ? prefix(replace(value, "stretch", "fill-available"), length) +
                    value
                : value;
          }
        break;
      // position: sticky

      case 4949:
        // (s)ticky?
        if (charat(value, length + 1) !== 115) break;
      // display: (flex|inline-flex)

      case 6444:
        switch (
          charat(
            value,
            strlen(value) - 3 - (~indexof(value, "!important") && 10),
          )
        ) {
          // stic(k)y
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x

          case 101:
            return (
              replace(
                value,
                /(.+:)([^;!]+)(;|!.+)?/,
                "$1" +
                  WEBKIT +
                  (charat(value, 14) === 45 ? "inline-" : "") +
                  "box$3" +
                  "$1" +
                  WEBKIT +
                  "$2$3" +
                  "$1" +
                  MS +
                  "$2box$3",
              ) + value
            );
        }

        break;
      // writing-mode

      case 5936:
        switch (charat(value, length + 11)) {
          // vertical-l(r)
          case 114:
            return (
              WEBKIT +
              value +
              MS +
              replace(value, /[svh]\w+-[tblr]{2}/, "tb") +
              value
            );
          // vertical-r(l)

          case 108:
            return (
              WEBKIT +
              value +
              MS +
              replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") +
              value
            );
          // horizontal(-)tb

          case 45:
            return (
              WEBKIT +
              value +
              MS +
              replace(value, /[svh]\w+-[tblr]{2}/, "lr") +
              value
            );
        }

        return WEBKIT + value + MS + value + value;
    }

    return value;
  }

  var prefixer = function prefixer(element, index, children, callback) {
    if (element.length > -1)
      if (!element["return"])
        switch (element.type) {
          case DECLARATION:
            element["return"] = prefix(element.value, element.length);
            break;

          case KEYFRAMES:
            return serialize(
              [
                copy(element, {
                  value: replace(element.value, "@", "@" + WEBKIT),
                }),
              ],
              callback,
            );

          case RULESET:
            if (element.length)
              return combine(element.props, function (value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ":read-only":
                  case ":read-write":
                    return serialize(
                      [
                        copy(element, {
                          props: [
                            replace(value, /:(read-\w+)/, ":" + MOZ + "$1"),
                          ],
                        }),
                      ],
                      callback,
                    );
                  // :placeholder

                  case "::placeholder":
                    return serialize(
                      [
                        copy(element, {
                          props: [
                            replace(
                              value,
                              /:(plac\w+)/,
                              ":" + WEBKIT + "input-$1",
                            ),
                          ],
                        }),
                        copy(element, {
                          props: [
                            replace(value, /:(plac\w+)/, ":" + MOZ + "$1"),
                          ],
                        }),
                        copy(element, {
                          props: [
                            replace(value, /:(plac\w+)/, MS + "input-$1"),
                          ],
                        }),
                      ],
                      callback,
                    );
                }

                return "";
              });
        }
  };

  var defaultStylisPlugins = [prefixer];

  var createCache = function createCache(options) {
    var key = options.key;

    if (key === "css") {
      var ssrStyles = document.querySelectorAll(
        "style[data-emotion]:not([data-s])",
      ); // get SSRed styles out of the way of React's hydration
      // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
      // note this very very intentionally targets all style elements regardless of the key to ensure
      // that creating a cache works inside of render of a React component

      Array.prototype.forEach.call(ssrStyles, function (node) {
        // we want to only move elements which have a space in the data-emotion attribute value
        // because that indicates that it is an Emotion 11 server-side rendered style elements
        // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
        // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
        // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
        // will not result in the Emotion 10 styles being destroyed
        var dataEmotionAttribute = node.getAttribute("data-emotion");

        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }

        document.head.appendChild(node);
        node.setAttribute("data-s", "");
      });
    }

    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

    var inserted = {};
    var container;
    var nodesToHydrate = [];

    {
      container = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function (node) {
          var attrib = node.getAttribute("data-emotion").split(" ");

          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }

          nodesToHydrate.push(node);
        },
      );
    }

    var _insert;

    var omnipresentPlugins = [compat, removeLabel];

    {
      var currentSheet;
      var finalizingPlugins = [
        stringify,
        rulesheet(function (rule) {
          currentSheet.insert(rule);
        }),
      ];
      var serializer = middleware(
        omnipresentPlugins.concat(stylisPlugins, finalizingPlugins),
      );

      var stylis = function stylis(styles) {
        return serialize(compile(styles), serializer);
      };

      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;

        stylis(
          selector
            ? selector + "{" + serialized.styles + "}"
            : serialized.styles,
        );

        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }

    var cache = {
      key: key,
      sheet: new StyleSheet({
        key: key,
        container: container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint,
      }),
      nonce: options.nonce,
      inserted: inserted,
      registered: {},
      insert: _insert,
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };

  var reactIs = { exports: {} };

  var reactIs_production_min = {};

  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredReactIs_production_min;

  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = "function" === typeof Symbol && Symbol.for,
      c = b ? Symbol.for("react.element") : 60103,
      d = b ? Symbol.for("react.portal") : 60106,
      e = b ? Symbol.for("react.fragment") : 60107,
      f = b ? Symbol.for("react.strict_mode") : 60108,
      g = b ? Symbol.for("react.profiler") : 60114,
      h = b ? Symbol.for("react.provider") : 60109,
      k = b ? Symbol.for("react.context") : 60110,
      l = b ? Symbol.for("react.async_mode") : 60111,
      m = b ? Symbol.for("react.concurrent_mode") : 60111,
      n = b ? Symbol.for("react.forward_ref") : 60112,
      p = b ? Symbol.for("react.suspense") : 60113,
      q = b ? Symbol.for("react.suspense_list") : 60120,
      r = b ? Symbol.for("react.memo") : 60115,
      t = b ? Symbol.for("react.lazy") : 60116,
      v = b ? Symbol.for("react.block") : 60121,
      w = b ? Symbol.for("react.fundamental") : 60117,
      x = b ? Symbol.for("react.responder") : 60118,
      y = b ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c:
            switch (((a = a.type), a)) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (((a = a && a.$$typeof), a)) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a) {
      return z(a) === m;
    }
    reactIs_production_min.AsyncMode = l;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c;
    reactIs_production_min.ForwardRef = n;
    reactIs_production_min.Fragment = e;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f;
    reactIs_production_min.Suspense = p;
    reactIs_production_min.isAsyncMode = function (a) {
      return A(a) || z(a) === l;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function (a) {
      return z(a) === k;
    };
    reactIs_production_min.isContextProvider = function (a) {
      return z(a) === h;
    };
    reactIs_production_min.isElement = function (a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    reactIs_production_min.isForwardRef = function (a) {
      return z(a) === n;
    };
    reactIs_production_min.isFragment = function (a) {
      return z(a) === e;
    };
    reactIs_production_min.isLazy = function (a) {
      return z(a) === t;
    };
    reactIs_production_min.isMemo = function (a) {
      return z(a) === r;
    };
    reactIs_production_min.isPortal = function (a) {
      return z(a) === d;
    };
    reactIs_production_min.isProfiler = function (a) {
      return z(a) === g;
    };
    reactIs_production_min.isStrictMode = function (a) {
      return z(a) === f;
    };
    reactIs_production_min.isSuspense = function (a) {
      return z(a) === p;
    };
    reactIs_production_min.isValidElementType = function (a) {
      return (
        "string" === typeof a ||
        "function" === typeof a ||
        a === e ||
        a === m ||
        a === g ||
        a === f ||
        a === p ||
        a === q ||
        ("object" === typeof a &&
          null !== a &&
          (a.$$typeof === t ||
            a.$$typeof === r ||
            a.$$typeof === h ||
            a.$$typeof === k ||
            a.$$typeof === n ||
            a.$$typeof === w ||
            a.$$typeof === x ||
            a.$$typeof === y ||
            a.$$typeof === v))
      );
    };
    reactIs_production_min.typeOf = z;
    return reactIs_production_min;
  }

  var hasRequiredReactIs;

  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;

    {
      reactIs.exports = requireReactIs_production_min();
    }
    return reactIs.exports;
  }

  var hoistNonReactStatics_cjs;
  var hasRequiredHoistNonReactStatics_cjs;

  function requireHoistNonReactStatics_cjs() {
    if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
    hasRequiredHoistNonReactStatics_cjs = 1;

    var reactIs = requireReactIs();

    /**
     * Copyright 2015, Yahoo! Inc.
     * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
     */
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true,
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true,
    };
    var FORWARD_REF_STATICS = {
      $$typeof: true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
    };
    var MEMO_STATICS = {
      $$typeof: true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true,
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

    function getStatics(component) {
      // React v16.11 and below
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      } // React v16.12 and above

      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }

    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        // don't hoist over string (html) components
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);

          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(
              targetComponent,
              inheritedComponent,
              blacklist,
            );
          }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];

          if (
            !KNOWN_STATICS[key] &&
            !(blacklist && blacklist[key]) &&
            !(sourceStatics && sourceStatics[key]) &&
            !(targetStatics && targetStatics[key])
          ) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

            try {
              // Avoid failures from read-only properties
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {}
          }
        }
      }

      return targetComponent;
    }

    hoistNonReactStatics_cjs = hoistNonReactStatics;
    return hoistNonReactStatics_cjs;
  }

  requireHoistNonReactStatics_cjs();

  var isBrowser = true;

  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function (className) {
      if (registered[className] !== undefined) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;

    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser === false) &&
      cache.registered[className] === undefined
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;

    if (cache.inserted[serialized.name] === undefined) {
      var current = serialized;

      do {
        cache.insert(
          serialized === current ? "." + className : "",
          current,
          cache.sheet,
          true,
        );

        current = current.next;
      } while (current !== undefined);
    }
  };

  /* eslint-disable */
  // Inspired by https://github.com/garycourt/murmurhash-js
  // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
  function murmur2(str) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    // const m = 0x5bd1e995;
    // const r = 24;
    // Initialize the hash
    var h = 0; // Mix 4 bytes at a time into the hash

    var k,
      i = 0,
      len = str.length;

    for (; len >= 4; ++i, len -= 4) {
      k =
        (str.charCodeAt(i) & 0xff) |
        ((str.charCodeAt(++i) & 0xff) << 8) |
        ((str.charCodeAt(++i) & 0xff) << 16) |
        ((str.charCodeAt(++i) & 0xff) << 24);
      k =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0xe995) << 16);
      k ^=
        /* k >>> r: */
        k >>> 24;
      h =
        /* Math.imul(k, m): */
        ((k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0xe995) << 16)) ^
        /* Math.imul(h, m): */
        ((h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16));
    } // Handle the last few bytes of the input array

    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h =
          /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16);
    } // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.

    h ^= h >>> 13;
    h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16);
    return ((h ^ (h >>> 15)) >>> 0).toString(36);
  }

  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  };

  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

  var isCustomProperty = function isCustomProperty(property) {
    return property.charCodeAt(1) === 45;
  };

  var isProcessableValue = function isProcessableValue(value) {
    return value != null && typeof value !== "boolean";
  };

  var processStyleName = /* #__PURE__ */ memoize(function (styleName) {
    return isCustomProperty(styleName)
      ? styleName
      : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });

  var processStyleValue = function processStyleValue(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor,
            };
            return p1;
          });
        }
      }
    }

    if (
      unitlessKeys[key] !== 1 &&
      !isCustomProperty(key) &&
      typeof value === "number" &&
      value !== 0
    ) {
      return value + "px";
    }

    return value;
  };

  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }

    var componentSelector = interpolation;

    if (componentSelector.__emotion_styles !== undefined) {
      return componentSelector;
    }

    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }

      case "object": {
        var keyframes = interpolation;

        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor,
          };
          return keyframes.name;
        }

        var serializedStyles = interpolation;

        if (serializedStyles.styles !== undefined) {
          var next = serializedStyles.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor,
              };
              next = next.next;
            }
          }

          var styles = serializedStyles.styles + ";";
          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

      case "function": {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }

        break;
      }
    } // finalize string values (regular strings and functions interpolated into css calls)

    var asString = interpolation;

    {
      return asString;
    }
  }

  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";

    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];

        if (typeof value !== "object") {
          var asString = value;

          if (isProcessableValue(asString)) {
            string +=
              processStyleName(key) +
              ":" +
              processStyleValue(key, asString) +
              ";";
          }
        } else {
          if (
            Array.isArray(value) &&
            typeof value[0] === "string" &&
            registered == null
          ) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string +=
                  processStyleName(key) +
                  ":" +
                  processStyleValue(key, value[_i]) +
                  ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(
              mergedProps,
              registered,
              value,
            );

            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }

              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }

    return string;
  }

  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
  // keyframes are stored on the SerializedStyles object as a linked list

  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (
      args.length === 1 &&
      typeof args[0] === "object" &&
      args[0] !== null &&
      args[0].styles !== undefined
    ) {
      return args[0];
    }

    var stringMode = true;
    var styles = "";
    cursor = undefined;
    var strings = args[0];

    if (strings == null || strings.raw === undefined) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;

      styles += asTemplateStringsArr[0];
    } // we start at 1 since we've already handled the first arg

    for (var i = 1; i < args.length; i++) {
      styles += handleInterpolation(mergedProps, registered, args[i]);

      if (stringMode) {
        var templateStringsArr = strings;

        styles += templateStringsArr[i];
      }
    } // using a global regex with .exec is stateful so lastIndex has to be reset each time

    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

    while ((match = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match[1];
    }

    var name = murmur2(styles) + identifierName;

    return {
      name: name,
      styles: styles,
      next: cursor,
    };
  }

  var syncFallback = function syncFallback(create) {
    return create();
  };

  var useInsertionEffect = React$1["useInsertion" + "Effect"]
    ? React$1["useInsertion" + "Effect"]
    : false;
  var useInsertionEffectAlwaysWithSyncFallback =
    useInsertionEffect || syncFallback;

  var EmotionCacheContext = /* #__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined"
      ? /* #__PURE__ */ createCache({
          key: "css",
        })
      : null,
  );

  EmotionCacheContext.Provider;

  var withEmotionCache = function withEmotionCache(func) {
    return /*#__PURE__*/ reactExports.forwardRef(function (props, ref) {
      // the cache will never be null in the browser
      var cache = reactExports.useContext(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };

  var ThemeContext = /* #__PURE__ */ reactExports.createContext({});

  var hasOwn = {}.hasOwnProperty;

  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps(type, props) {
    var newProps = {};

    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }

    newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:

    return newProps;
  };

  var Insertion = function Insertion(_ref) {
    var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function () {
      return insertStyles(cache, serialized, isStringTag);
    });

    return null;
  };

  var Emotion = /* #__PURE__ */ withEmotionCache(function (props, cache, ref) {
    var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
    // not passing the registered cache to serializeStyles because it would
    // make certain babel optimisations not possible

    if (
      typeof cssProp === "string" &&
      cache.registered[cssProp] !== undefined
    ) {
      cssProp = cache.registered[cssProp];
    }

    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";

    if (typeof props.className === "string") {
      className = getRegisteredStyles(
        cache.registered,
        registeredStyles,
        props.className,
      );
    } else if (props.className != null) {
      className = props.className + " ";
    }

    var serialized = serializeStyles(
      registeredStyles,
      undefined,
      reactExports.useContext(ThemeContext),
    );

    className += cache.key + "-" + serialized.name;
    var newProps = {};

    for (var _key2 in props) {
      if (
        hasOwn.call(props, _key2) &&
        _key2 !== "css" &&
        _key2 !== typePropName &&
        true
      ) {
        newProps[_key2] = props[_key2];
      }
    }

    newProps.className = className;

    if (ref) {
      newProps.ref = ref;
    }

    return /*#__PURE__*/ reactExports.createElement(
      reactExports.Fragment,
      null,
      /*#__PURE__*/ reactExports.createElement(Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof WrappedComponent === "string",
      }),
      /*#__PURE__*/ reactExports.createElement(WrappedComponent, newProps),
    );
  });

  var Emotion$1 = Emotion;

  var jsx = function jsx(type, props) {
    // eslint-disable-next-line prefer-rest-params
    var args = arguments;

    if (props == null || !hasOwn.call(props, "css")) {
      return reactExports.createElement.apply(undefined, args);
    }

    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);

    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = args[i];
    }

    return reactExports.createElement.apply(null, createElementArgArray);
  };

  (function (_jsx) {
    var JSX;

    (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx || (jsx = {}));

  function css$2() {
    for (
      var _len = arguments.length, args = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      args[_key] = arguments[_key];
    }

    return serializeStyles(args);
  }

  function keyframes() {
    var insertable = css$2.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name: name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  }

  function _taggedTemplateLiteral(e, t) {
    return (
      t || (t = e.slice(0)),
      Object.freeze(
        Object.defineProperties(e, {
          raw: {
            value: Object.freeze(t),
          },
        }),
      )
    );
  }

  var reactDomExports = requireReactDom();

  /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */

  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v,
  });
  function rectToClientRect(rect) {
    const { x, y, width, height } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y,
    };
  }

  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (
      (node == null || (_node$ownerDocument = node.ownerDocument) == null
        ? void 0
        : _node$ownerDocument.defaultView) || window
    );
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref =
      (isNode(node) ? node.ownerDocument : node.document) || window.document) ==
      null
      ? void 0
      : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return (
      value instanceof Element || value instanceof getWindow(value).Element
    );
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return (
      value instanceof HTMLElement ||
      value instanceof getWindow(value).HTMLElement
    );
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return (
      value instanceof ShadowRoot ||
      value instanceof getWindow(value).ShadowRoot
    );
  }
  const invalidOverflowDisplayValues = /*#__PURE__*/ new Set([
    "inline",
    "contents",
  ]);
  function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } =
      getComputedStyle$1(element);
    return (
      /auto|scroll|overlay|hidden|clip/.test(
        overflow + overflowY + overflowX,
      ) && !invalidOverflowDisplayValues.has(display)
    );
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  const lastTraversableNodeNames = /*#__PURE__*/ new Set([
    "html",
    "body",
    "#document",
  ]);
  function isLastTraversableNode(node) {
    return lastTraversableNodeNames.has(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result =
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot ||
      // DOM Element detected.
      node.parentNode ||
      // ShadowRoot detected.
      (isShadowRoot(node) && node.host) ||
      // Fallback.
      getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody =
      scrollableAncestor ===
      ((_node$ownerDocument2 = node.ownerDocument) == null
        ? void 0
        : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(
        win,
        win.visualViewport || [],
        isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
        frameElement && traverseIframes
          ? getOverflowAncestors(frameElement)
          : [],
      );
    }
    return list.concat(
      scrollableAncestor,
      getOverflowAncestors(scrollableAncestor, [], traverseIframes),
    );
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent)
      ? win.frameElement
      : null;
  }

  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback =
      round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback,
    };
  }

  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }

  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;

    // 0, NaN, or Infinity should always fallback to 1.

    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y,
    };
  }

  const noOffsets = /*#__PURE__*/ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop,
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    {
      return false;
    }
  }

  function getBoundingClientRect(
    element,
    includeScale,
    isFixedStrategy,
    offsetParent,
  ) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets()
      ? getVisualOffsets(domElement)
      : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left =
          iframeRect.left +
          (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) *
            iframeScale.x;
        const top =
          iframeRect.top +
          (currentIFrame.clientTop + parseFloat(css.paddingTop)) *
            iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y,
    });
  }

  function rectsAreEqual(a, b) {
    return (
      a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
    );
  }

  // https://samthor.au/2021/observing-dom/
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const { left, top, width, height } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin =
        -insetTop +
        "px " +
        -insetRight +
        "px " +
        -insetBottom +
        "px " +
        -insetLeft +
        "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1,
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            // If the reference is clipped, the ratio is 0. Throttle the refresh
            // to prevent an infinite loop of updates.
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1000);
          } else {
            refresh(false, ratio);
          }
        }
        if (
          ratio === 1 &&
          !rectsAreEqual(
            elementRectForRootMargin,
            element.getBoundingClientRect(),
          )
        ) {
          // It's possible that even though the ratio is reported as 1, the
          // element is not actually fully within the IntersectionObserver's root
          // area anymore. This can happen under performance constraints. This may
          // be a bug in the browser's IntersectionObserver implementation. To
          // work around this, we compare the element's bounding rect now with
          // what it was at the time we created the IntersectionObserver. If they
          // are not equal then the element moved, so we refresh.
          refresh();
        }
        isFirstUpdate = false;
      }

      // Older browsers don't support a `document` as the root and will throw an
      // error.
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument,
        });
      } catch (_e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }

  /**
   * Automatically updates the position of the floating element when necessary.
   * Should only be called when the floating element is mounted on the DOM or
   * visible on the screen.
   * @returns cleanup function that should be invoked when the floating element is
   * removed from the DOM or hidden from the screen.
   * @see https://floating-ui.com/docs/autoUpdate
   */
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false,
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors =
      ancestorScroll || ancestorResize
        ? [
            ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
            ...getOverflowAncestors(floating),
          ]
        : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll &&
        ancestor.addEventListener("scroll", update, {
          passive: true,
        });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo =
      referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          // Prevent update loops when using the `size` middleware.
          // https://github.com/floating-ui/floating-ui/issues/1740
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null ||
              _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null ||
        _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }

  var index = reactExports.useLayoutEffect;

  var _excluded$4 = [
    "className",
    "clearValue",
    "cx",
    "getStyles",
    "getClassNames",
    "getValue",
    "hasValue",
    "isMulti",
    "isRtl",
    "options",
    "selectOption",
    "selectProps",
    "setValue",
    "theme",
  ];
  // ==============================
  // NO OP
  // ==============================

  var noop = function noop() {};

  // ==============================
  // Class Name Prefixer
  // ==============================

  /**
	 String representation of component state for styling with class names.

	 Expects an array of strings OR a string/object pair:
	 - className(['comp', 'comp-arg', 'comp-arg-2'])
	   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
	 - className('comp', { some: true, state: false })
	   @returns 'react-select__comp react-select__comp--some'
	*/
  function applyPrefixToName(prefix, name) {
    if (!name) {
      return prefix;
    } else if (name[0] === "-") {
      return prefix + name;
    } else {
      return prefix + "__" + name;
    }
  }
  function classNames(prefix, state) {
    for (
      var _len = arguments.length,
        classNameList = new Array(_len > 2 ? _len - 2 : 0),
        _key = 2;
      _key < _len;
      _key++
    ) {
      classNameList[_key - 2] = arguments[_key];
    }
    var arr = [].concat(classNameList);
    if (state && prefix) {
      for (var key in state) {
        if (state.hasOwnProperty(key) && state[key]) {
          arr.push("".concat(applyPrefixToName(prefix, key)));
        }
      }
    }
    return arr
      .filter(function (i) {
        return i;
      })
      .map(function (i) {
        return String(i).trim();
      })
      .join(" ");
  }
  // ==============================
  // Clean Value
  // ==============================

  var cleanValue = function cleanValue(value) {
    if (isArray(value)) return value.filter(Boolean);
    if (_typeof(value) === "object" && value !== null) return [value];
    return [];
  };

  // ==============================
  // Clean Common Props
  // ==============================

  var cleanCommonProps = function cleanCommonProps(props) {
    //className
    props.className;
    props.clearValue;
    props.cx;
    props.getStyles;
    props.getClassNames;
    props.getValue;
    props.hasValue;
    props.isMulti;
    props.isRtl;
    props.options;
    props.selectOption;
    props.selectProps;
    props.setValue;
    props.theme;
    var innerProps = _objectWithoutProperties(props, _excluded$4);
    return _objectSpread2({}, innerProps);
  };

  // ==============================
  // Get Style Props
  // ==============================

  var getStyleProps = function getStyleProps(props, name, classNamesState) {
    var cx = props.cx,
      getStyles = props.getStyles,
      getClassNames = props.getClassNames,
      className = props.className;
    return {
      css: getStyles(name, props),
      className: cx(
        classNamesState !== null && classNamesState !== void 0
          ? classNamesState
          : {},
        getClassNames(name, props),
        className,
      ),
    };
  };

  // ==============================
  // Scroll Helpers
  // ==============================

  function isDocumentElement(el) {
    return [document.documentElement, document.body, window].indexOf(el) > -1;
  }

  // Normalized Scroll Top
  // ------------------------------

  function normalizedHeight(el) {
    if (isDocumentElement(el)) {
      return window.innerHeight;
    }
    return el.clientHeight;
  }

  // Normalized scrollTo & scrollTop
  // ------------------------------

  function getScrollTop(el) {
    if (isDocumentElement(el)) {
      return window.pageYOffset;
    }
    return el.scrollTop;
  }
  function scrollTo(el, top) {
    // with a scroll distance, we perform scroll on the element
    if (isDocumentElement(el)) {
      window.scrollTo(0, top);
      return;
    }
    el.scrollTop = top;
  }

  // Get Scroll Parent
  // ------------------------------

  function getScrollParent(element) {
    var style = getComputedStyle(element);
    var excludeStaticParent = style.position === "absolute";
    var overflowRx = /(auto|scroll)/;
    if (style.position === "fixed") return document.documentElement;
    for (var parent = element; (parent = parent.parentElement); ) {
      style = getComputedStyle(parent);
      if (excludeStaticParent && style.position === "static") {
        continue;
      }
      if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
        return parent;
      }
    }
    return document.documentElement;
  }

  // Animated Scroll To
  // ------------------------------

  /**
	  @param t: time (elapsed)
	  @param b: initial value
	  @param c: amount of change
	  @param d: duration
	*/
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }
  function animatedScrollTo(element, to) {
    var duration =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
    var callback =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
    var start = getScrollTop(element);
    var change = to - start;
    var increment = 10;
    var currentTime = 0;
    function animateScroll() {
      currentTime += increment;
      var val = easeOutCubic(currentTime, start, change, duration);
      scrollTo(element, val);
      if (currentTime < duration) {
        window.requestAnimationFrame(animateScroll);
      } else {
        callback(element);
      }
    }
    animateScroll();
  }

  // Scroll Into View
  // ------------------------------

  function scrollIntoView(menuEl, focusedEl) {
    var menuRect = menuEl.getBoundingClientRect();
    var focusedRect = focusedEl.getBoundingClientRect();
    var overScroll = focusedEl.offsetHeight / 3;
    if (focusedRect.bottom + overScroll > menuRect.bottom) {
      scrollTo(
        menuEl,
        Math.min(
          focusedEl.offsetTop +
            focusedEl.clientHeight -
            menuEl.offsetHeight +
            overScroll,
          menuEl.scrollHeight,
        ),
      );
    } else if (focusedRect.top - overScroll < menuRect.top) {
      scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
    }
  }

  // ==============================
  // Get bounding client object
  // ==============================

  // cannot get keys using array notation with DOMRect
  function getBoundingClientObj(element) {
    var rect = element.getBoundingClientRect();
    return {
      bottom: rect.bottom,
      height: rect.height,
      left: rect.left,
      right: rect.right,
      top: rect.top,
      width: rect.width,
    };
  }

  // ==============================
  // Touch Capability Detector
  // ==============================

  function isTouchCapable() {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }

  // ==============================
  // Mobile Device Detector
  // ==============================

  function isMobileDevice() {
    try {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent,
      );
    } catch (e) {
      return false;
    }
  }

  // ==============================
  // Passive Event Detector
  // ==============================

  // https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36
  var passiveOptionAccessed = false;
  var options = {
    get passive() {
      return (passiveOptionAccessed = true);
    },
  };
  // check for SSR
  var w = typeof window !== "undefined" ? window : {};
  if (w.addEventListener && w.removeEventListener) {
    w.addEventListener("p", noop, options);
    w.removeEventListener("p", noop, false);
  }
  var supportsPassiveEvents = passiveOptionAccessed;
  function notNullish(item) {
    return item != null;
  }
  function isArray(arg) {
    return Array.isArray(arg);
  }
  function valueTernary(isMulti, multiValue, singleValue) {
    return isMulti ? multiValue : singleValue;
  }
  function singleValueAsValue(singleValue) {
    return singleValue;
  }
  function multiValueAsValue(multiValue) {
    return multiValue;
  }
  var removeProps = function removeProps(propsObj) {
    for (
      var _len2 = arguments.length,
        properties = new Array(_len2 > 1 ? _len2 - 1 : 0),
        _key2 = 1;
      _key2 < _len2;
      _key2++
    ) {
      properties[_key2 - 1] = arguments[_key2];
    }
    var propsMap = Object.entries(propsObj).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
        key = _ref2[0];
      return !properties.includes(key);
    });
    return propsMap.reduce(function (newProps, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        val = _ref4[1];
      newProps[key] = val;
      return newProps;
    }, {});
  };

  var _excluded$3 = ["children", "innerProps"],
    _excluded2$1 = ["children", "innerProps"];
  function getMenuPlacement(_ref) {
    var preferredMaxHeight = _ref.maxHeight,
      menuEl = _ref.menuEl,
      minHeight = _ref.minHeight,
      preferredPlacement = _ref.placement,
      shouldScroll = _ref.shouldScroll,
      isFixedPosition = _ref.isFixedPosition,
      controlHeight = _ref.controlHeight;
    var scrollParent = getScrollParent(menuEl);
    var defaultState = {
      placement: "bottom",
      maxHeight: preferredMaxHeight,
    };

    // something went wrong, return default state
    if (!menuEl || !menuEl.offsetParent) return defaultState;

    // we can't trust `scrollParent.scrollHeight` --> it may increase when
    // the menu is rendered
    var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
      scrollHeight = _scrollParent$getBoun.height;
    var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
      menuBottom = _menuEl$getBoundingCl.bottom,
      menuHeight = _menuEl$getBoundingCl.height,
      menuTop = _menuEl$getBoundingCl.top;
    var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
      containerTop = _menuEl$offsetParent$.top;
    var viewHeight = isFixedPosition
      ? window.innerHeight
      : normalizedHeight(scrollParent);
    var scrollTop = getScrollTop(scrollParent);
    var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
    var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
    var viewSpaceAbove = containerTop - marginTop;
    var viewSpaceBelow = viewHeight - menuTop;
    var scrollSpaceAbove = viewSpaceAbove + scrollTop;
    var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
    var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
    var scrollUp = scrollTop + menuTop - marginTop;
    var scrollDuration = 160;
    switch (preferredPlacement) {
      case "auto":
      case "bottom":
        // 1: the menu will fit, do nothing
        if (viewSpaceBelow >= menuHeight) {
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight,
          };
        }

        // 2: the menu will fit, if scrolled
        if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollDown, scrollDuration);
          }
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight,
          };
        }

        // 3: the menu will fit, if constrained
        if (
          (!isFixedPosition && scrollSpaceBelow >= minHeight) ||
          (isFixedPosition && viewSpaceBelow >= minHeight)
        ) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollDown, scrollDuration);
          }

          // we want to provide as much of the menu as possible to the user,
          // so give them whatever is available below rather than the minHeight.
          var constrainedHeight = isFixedPosition
            ? viewSpaceBelow - marginBottom
            : scrollSpaceBelow - marginBottom;
          return {
            placement: "bottom",
            maxHeight: constrainedHeight,
          };
        }

        // 4. Forked beviour when there isn't enough space below

        // AUTO: flip the menu, render above
        if (preferredPlacement === "auto" || isFixedPosition) {
          // may need to be constrained after flipping
          var _constrainedHeight = preferredMaxHeight;
          var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
          if (spaceAbove >= minHeight) {
            _constrainedHeight = Math.min(
              spaceAbove - marginBottom - controlHeight,
              preferredMaxHeight,
            );
          }
          return {
            placement: "top",
            maxHeight: _constrainedHeight,
          };
        }

        // BOTTOM: allow browser to increase scrollable area and immediately set scroll
        if (preferredPlacement === "bottom") {
          if (shouldScroll) {
            scrollTo(scrollParent, scrollDown);
          }
          return {
            placement: "bottom",
            maxHeight: preferredMaxHeight,
          };
        }
        break;
      case "top":
        // 1: the menu will fit, do nothing
        if (viewSpaceAbove >= menuHeight) {
          return {
            placement: "top",
            maxHeight: preferredMaxHeight,
          };
        }

        // 2: the menu will fit, if scrolled
        if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollUp, scrollDuration);
          }
          return {
            placement: "top",
            maxHeight: preferredMaxHeight,
          };
        }

        // 3: the menu will fit, if constrained
        if (
          (!isFixedPosition && scrollSpaceAbove >= minHeight) ||
          (isFixedPosition && viewSpaceAbove >= minHeight)
        ) {
          var _constrainedHeight2 = preferredMaxHeight;

          // we want to provide as much of the menu as possible to the user,
          // so give them whatever is available below rather than the minHeight.
          if (
            (!isFixedPosition && scrollSpaceAbove >= minHeight) ||
            (isFixedPosition && viewSpaceAbove >= minHeight)
          ) {
            _constrainedHeight2 = isFixedPosition
              ? viewSpaceAbove - marginTop
              : scrollSpaceAbove - marginTop;
          }
          if (shouldScroll) {
            animatedScrollTo(scrollParent, scrollUp, scrollDuration);
          }
          return {
            placement: "top",
            maxHeight: _constrainedHeight2,
          };
        }

        // 4. not enough space, the browser WILL NOT increase scrollable area when
        // absolutely positioned element rendered above the viewport (only below).
        // Flip the menu, render below
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight,
        };
      default:
        throw new Error(
          'Invalid placement provided "'.concat(preferredPlacement, '".'),
        );
    }
    return defaultState;
  }

  // Menu Component
  // ------------------------------

  function alignToControl(placement) {
    var placementToCSSProp = {
      bottom: "top",
      top: "bottom",
    };
    return placement ? placementToCSSProp[placement] : "bottom";
  }
  var coercePlacement = function coercePlacement(p) {
    return p === "auto" ? "bottom" : p;
  };
  var menuCSS = function menuCSS(_ref2, unstyled) {
    var _objectSpread2$1;
    var placement = _ref2.placement,
      _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      spacing = _ref2$theme.spacing,
      colors = _ref2$theme.colors;
    return _objectSpread2(
      ((_objectSpread2$1 = {
        label: "menu",
      }),
      _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"),
      _defineProperty(_objectSpread2$1, "position", "absolute"),
      _defineProperty(_objectSpread2$1, "width", "100%"),
      _defineProperty(_objectSpread2$1, "zIndex", 1),
      _objectSpread2$1),
      unstyled
        ? {}
        : {
            backgroundColor: colors.neutral0,
            borderRadius: borderRadius,
            boxShadow:
              "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
            marginBottom: spacing.menuGutter,
            marginTop: spacing.menuGutter,
          },
    );
  };
  var PortalPlacementContext = /*#__PURE__*/ reactExports.createContext(null);

  // NOTE: internal only
  var MenuPlacer = function MenuPlacer(props) {
    var children = props.children,
      minMenuHeight = props.minMenuHeight,
      maxMenuHeight = props.maxMenuHeight,
      menuPlacement = props.menuPlacement,
      menuPosition = props.menuPosition,
      menuShouldScrollIntoView = props.menuShouldScrollIntoView,
      theme = props.theme;
    var _ref3 = reactExports.useContext(PortalPlacementContext) || {},
      setPortalPlacement = _ref3.setPortalPlacement;
    var ref = reactExports.useRef(null);
    var _useState = reactExports.useState(maxMenuHeight),
      _useState2 = _slicedToArray(_useState, 2),
      maxHeight = _useState2[0],
      setMaxHeight = _useState2[1];
    var _useState3 = reactExports.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      placement = _useState4[0],
      setPlacement = _useState4[1];
    var controlHeight = theme.spacing.controlHeight;
    index(
      function () {
        var menuEl = ref.current;
        if (!menuEl) return;

        // DO NOT scroll if position is fixed
        var isFixedPosition = menuPosition === "fixed";
        var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
        var state = getMenuPlacement({
          maxHeight: maxMenuHeight,
          menuEl: menuEl,
          minHeight: minMenuHeight,
          placement: menuPlacement,
          shouldScroll: shouldScroll,
          isFixedPosition: isFixedPosition,
          controlHeight: controlHeight,
        });
        setMaxHeight(state.maxHeight);
        setPlacement(state.placement);
        setPortalPlacement === null || setPortalPlacement === void 0
          ? void 0
          : setPortalPlacement(state.placement);
      },
      [
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView,
        minMenuHeight,
        setPortalPlacement,
        controlHeight,
      ],
    );
    return children({
      ref: ref,
      placerProps: _objectSpread2(
        _objectSpread2({}, props),
        {},
        {
          placement: placement || coercePlacement(menuPlacement),
          maxHeight: maxHeight,
        },
      ),
    });
  };
  var Menu = function Menu(props) {
    var children = props.children,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "menu", {
          menu: true,
        }),
        {
          ref: innerRef,
        },
        innerProps,
      ),
      children,
    );
  };
  var Menu$1 = Menu;

  // ==============================
  // Menu List
  // ==============================

  var menuListCSS = function menuListCSS(_ref4, unstyled) {
    var maxHeight = _ref4.maxHeight,
      baseUnit = _ref4.theme.spacing.baseUnit;
    return _objectSpread2(
      {
        maxHeight: maxHeight,
        overflowY: "auto",
        position: "relative",
        // required for offset[Height, Top] > keyboard scroll
        WebkitOverflowScrolling: "touch",
      },
      unstyled
        ? {}
        : {
            paddingBottom: baseUnit,
            paddingTop: baseUnit,
          },
    );
  };
  var MenuList = function MenuList(props) {
    var children = props.children,
      innerProps = props.innerProps,
      innerRef = props.innerRef,
      isMulti = props.isMulti;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "menuList", {
          "menu-list": true,
          "menu-list--is-multi": isMulti,
        }),
        {
          ref: innerRef,
        },
        innerProps,
      ),
      children,
    );
  };

  // ==============================
  // Menu Notices
  // ==============================

  var noticeCSS = function noticeCSS(_ref5, unstyled) {
    var _ref5$theme = _ref5.theme,
      baseUnit = _ref5$theme.spacing.baseUnit,
      colors = _ref5$theme.colors;
    return _objectSpread2(
      {
        textAlign: "center",
      },
      unstyled
        ? {}
        : {
            color: colors.neutral40,
            padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px"),
          },
    );
  };
  var noOptionsMessageCSS = noticeCSS;
  var loadingMessageCSS = noticeCSS;
  var NoOptionsMessage = function NoOptionsMessage(_ref6) {
    var _ref6$children = _ref6.children,
      children = _ref6$children === void 0 ? "No options" : _ref6$children,
      innerProps = _ref6.innerProps,
      restProps = _objectWithoutProperties(_ref6, _excluded$3);
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(
          _objectSpread2(
            _objectSpread2({}, restProps),
            {},
            {
              children: children,
              innerProps: innerProps,
            },
          ),
          "noOptionsMessage",
          {
            "menu-notice": true,
            "menu-notice--no-options": true,
          },
        ),
        innerProps,
      ),
      children,
    );
  };
  var LoadingMessage = function LoadingMessage(_ref7) {
    var _ref7$children = _ref7.children,
      children = _ref7$children === void 0 ? "Loading..." : _ref7$children,
      innerProps = _ref7.innerProps,
      restProps = _objectWithoutProperties(_ref7, _excluded2$1);
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(
          _objectSpread2(
            _objectSpread2({}, restProps),
            {},
            {
              children: children,
              innerProps: innerProps,
            },
          ),
          "loadingMessage",
          {
            "menu-notice": true,
            "menu-notice--loading": true,
          },
        ),
        innerProps,
      ),
      children,
    );
  };

  // ==============================
  // Menu Portal
  // ==============================

  var menuPortalCSS = function menuPortalCSS(_ref8) {
    var rect = _ref8.rect,
      offset = _ref8.offset,
      position = _ref8.position;
    return {
      left: rect.left,
      position: position,
      top: offset,
      width: rect.width,
      zIndex: 1,
    };
  };
  var MenuPortal = function MenuPortal(props) {
    var appendTo = props.appendTo,
      children = props.children,
      controlElement = props.controlElement,
      innerProps = props.innerProps,
      menuPlacement = props.menuPlacement,
      menuPosition = props.menuPosition;
    var menuPortalRef = reactExports.useRef(null);
    var cleanupRef = reactExports.useRef(null);
    var _useState5 = reactExports.useState(coercePlacement(menuPlacement)),
      _useState6 = _slicedToArray(_useState5, 2),
      placement = _useState6[0],
      setPortalPlacement = _useState6[1];
    var portalPlacementContext = reactExports.useMemo(function () {
      return {
        setPortalPlacement: setPortalPlacement,
      };
    }, []);
    var _useState7 = reactExports.useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      computedPosition = _useState8[0],
      setComputedPosition = _useState8[1];
    var updateComputedPosition = reactExports.useCallback(
      function () {
        if (!controlElement) return;
        var rect = getBoundingClientObj(controlElement);
        var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
        var offset = rect[placement] + scrollDistance;
        if (
          offset !==
            (computedPosition === null || computedPosition === void 0
              ? void 0
              : computedPosition.offset) ||
          rect.left !==
            (computedPosition === null || computedPosition === void 0
              ? void 0
              : computedPosition.rect.left) ||
          rect.width !==
            (computedPosition === null || computedPosition === void 0
              ? void 0
              : computedPosition.rect.width)
        ) {
          setComputedPosition({
            offset: offset,
            rect: rect,
          });
        }
      },
      [
        controlElement,
        menuPosition,
        placement,
        computedPosition === null || computedPosition === void 0
          ? void 0
          : computedPosition.offset,
        computedPosition === null || computedPosition === void 0
          ? void 0
          : computedPosition.rect.left,
        computedPosition === null || computedPosition === void 0
          ? void 0
          : computedPosition.rect.width,
      ],
    );
    index(
      function () {
        updateComputedPosition();
      },
      [updateComputedPosition],
    );
    var runAutoUpdate = reactExports.useCallback(
      function () {
        if (typeof cleanupRef.current === "function") {
          cleanupRef.current();
          cleanupRef.current = null;
        }
        if (controlElement && menuPortalRef.current) {
          cleanupRef.current = autoUpdate(
            controlElement,
            menuPortalRef.current,
            updateComputedPosition,
            {
              elementResize: "ResizeObserver" in window,
            },
          );
        }
      },
      [controlElement, updateComputedPosition],
    );
    index(
      function () {
        runAutoUpdate();
      },
      [runAutoUpdate],
    );
    var setMenuPortalElement = reactExports.useCallback(
      function (menuPortalElement) {
        menuPortalRef.current = menuPortalElement;
        runAutoUpdate();
      },
      [runAutoUpdate],
    );

    // bail early if required elements aren't present
    if ((!appendTo && menuPosition !== "fixed") || !computedPosition)
      return null;

    // same wrapper element whether fixed or portalled
    var menuWrapper = jsx(
      "div",
      _extends(
        {
          ref: setMenuPortalElement,
        },
        getStyleProps(
          _objectSpread2(
            _objectSpread2({}, props),
            {},
            {
              offset: computedPosition.offset,
              position: menuPosition,
              rect: computedPosition.rect,
            },
          ),
          "menuPortal",
          {
            "menu-portal": true,
          },
        ),
        innerProps,
      ),
      children,
    );
    return jsx(
      PortalPlacementContext.Provider,
      {
        value: portalPlacementContext,
      },
      appendTo
        ? /*#__PURE__*/ reactDomExports.createPortal(menuWrapper, appendTo)
        : menuWrapper,
    );
  };

  // ==============================
  // Root Container
  // ==============================

  var containerCSS = function containerCSS(_ref) {
    var isDisabled = _ref.isDisabled,
      isRtl = _ref.isRtl;
    return {
      label: "container",
      direction: isRtl ? "rtl" : undefined,
      pointerEvents: isDisabled ? "none" : undefined,
      // cancel mouse events when disabled
      position: "relative",
    };
  };
  var SelectContainer = function SelectContainer(props) {
    var children = props.children,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      isRtl = props.isRtl;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "container", {
          "--is-disabled": isDisabled,
          "--is-rtl": isRtl,
        }),
        innerProps,
      ),
      children,
    );
  };

  // ==============================
  // Value Container
  // ==============================

  var valueContainerCSS = function valueContainerCSS(_ref2, unstyled) {
    var spacing = _ref2.theme.spacing,
      isMulti = _ref2.isMulti,
      hasValue = _ref2.hasValue,
      controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
    return _objectSpread2(
      {
        alignItems: "center",
        display:
          isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
        flex: 1,
        flexWrap: "wrap",
        WebkitOverflowScrolling: "touch",
        position: "relative",
        overflow: "hidden",
      },
      unstyled
        ? {}
        : {
            padding: ""
              .concat(spacing.baseUnit / 2, "px ")
              .concat(spacing.baseUnit * 2, "px"),
          },
    );
  };
  var ValueContainer = function ValueContainer(props) {
    var children = props.children,
      innerProps = props.innerProps,
      isMulti = props.isMulti,
      hasValue = props.hasValue;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "valueContainer", {
          "value-container": true,
          "value-container--is-multi": isMulti,
          "value-container--has-value": hasValue,
        }),
        innerProps,
      ),
      children,
    );
  };

  // ==============================
  // Indicator Container
  // ==============================

  var indicatorsContainerCSS = function indicatorsContainerCSS() {
    return {
      alignItems: "center",
      alignSelf: "stretch",
      display: "flex",
      flexShrink: 0,
    };
  };
  var IndicatorsContainer = function IndicatorsContainer(props) {
    var children = props.children,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "indicatorsContainer", {
          indicators: true,
        }),
        innerProps,
      ),
      children,
    );
  };

  var _templateObject;
  var _excluded$2 = ["size"],
    _excluded2 = ["innerProps", "isRtl", "size"];

  // ==============================
  // Dropdown & Clear Icons
  // ==============================
  var _ref2$2 = {
    name: "8mmkcg",
    styles:
      "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0",
  };
  var Svg = function Svg(_ref) {
    var size = _ref.size,
      props = _objectWithoutProperties(_ref, _excluded$2);
    return jsx(
      "svg",
      _extends(
        {
          height: size,
          width: size,
          viewBox: "0 0 20 20",
          "aria-hidden": "true",
          focusable: "false",
          css: _ref2$2,
        },
        props,
      ),
    );
  };
  var CrossIcon = function CrossIcon(props) {
    return jsx(
      Svg,
      _extends(
        {
          size: 20,
        },
        props,
      ),
      jsx("path", {
        d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z",
      }),
    );
  };
  var DownChevron = function DownChevron(props) {
    return jsx(
      Svg,
      _extends(
        {
          size: 20,
        },
        props,
      ),
      jsx("path", {
        d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z",
      }),
    );
  };

  // ==============================
  // Dropdown & Clear Buttons
  // ==============================

  var baseCSS = function baseCSS(_ref3, unstyled) {
    var isFocused = _ref3.isFocused,
      _ref3$theme = _ref3.theme,
      baseUnit = _ref3$theme.spacing.baseUnit,
      colors = _ref3$theme.colors;
    return _objectSpread2(
      {
        label: "indicatorContainer",
        display: "flex",
        transition: "color 150ms",
      },
      unstyled
        ? {}
        : {
            color: isFocused ? colors.neutral60 : colors.neutral20,
            padding: baseUnit * 2,
            ":hover": {
              color: isFocused ? colors.neutral80 : colors.neutral40,
            },
          },
    );
  };
  var dropdownIndicatorCSS = baseCSS;
  var DropdownIndicator = function DropdownIndicator(props) {
    var children = props.children,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "dropdownIndicator", {
          indicator: true,
          "dropdown-indicator": true,
        }),
        innerProps,
      ),
      children || jsx(DownChevron, null),
    );
  };
  var clearIndicatorCSS = baseCSS;
  var ClearIndicator = function ClearIndicator(props) {
    var children = props.children,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "clearIndicator", {
          indicator: true,
          "clear-indicator": true,
        }),
        innerProps,
      ),
      children || jsx(CrossIcon, null),
    );
  };

  // ==============================
  // Separator
  // ==============================

  var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4, unstyled) {
    var isDisabled = _ref4.isDisabled,
      _ref4$theme = _ref4.theme,
      baseUnit = _ref4$theme.spacing.baseUnit,
      colors = _ref4$theme.colors;
    return _objectSpread2(
      {
        label: "indicatorSeparator",
        alignSelf: "stretch",
        width: 1,
      },
      unstyled
        ? {}
        : {
            backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
            marginBottom: baseUnit * 2,
            marginTop: baseUnit * 2,
          },
    );
  };
  var IndicatorSeparator = function IndicatorSeparator(props) {
    var innerProps = props.innerProps;
    return jsx(
      "span",
      _extends(
        {},
        innerProps,
        getStyleProps(props, "indicatorSeparator", {
          "indicator-separator": true,
        }),
      ),
    );
  };

  // ==============================
  // Loading
  // ==============================

  var loadingDotAnimations = keyframes(
    _templateObject ||
      (_templateObject = _taggedTemplateLiteral([
        "\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n",
      ])),
  );
  var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5, unstyled) {
    var isFocused = _ref5.isFocused,
      size = _ref5.size,
      _ref5$theme = _ref5.theme,
      colors = _ref5$theme.colors,
      baseUnit = _ref5$theme.spacing.baseUnit;
    return _objectSpread2(
      {
        label: "loadingIndicator",
        display: "flex",
        transition: "color 150ms",
        alignSelf: "center",
        fontSize: size,
        lineHeight: 1,
        marginRight: size,
        textAlign: "center",
        verticalAlign: "middle",
      },
      unstyled
        ? {}
        : {
            color: isFocused ? colors.neutral60 : colors.neutral20,
            padding: baseUnit * 2,
          },
    );
  };
  var LoadingDot = function LoadingDot(_ref6) {
    var delay = _ref6.delay,
      offset = _ref6.offset;
    return jsx("span", {
      css: /*#__PURE__*/ css$2(
        {
          animation: ""
            .concat(loadingDotAnimations, " 1s ease-in-out ")
            .concat(delay, "ms infinite;"),
          backgroundColor: "currentColor",
          borderRadius: "1em",
          display: "inline-block",
          marginLeft: offset ? "1em" : undefined,
          height: "1em",
          verticalAlign: "top",
          width: "1em",
        },
        "",
        "",
      ),
    });
  };
  var LoadingIndicator = function LoadingIndicator(_ref7) {
    var innerProps = _ref7.innerProps,
      isRtl = _ref7.isRtl,
      _ref7$size = _ref7.size,
      size = _ref7$size === void 0 ? 4 : _ref7$size,
      restProps = _objectWithoutProperties(_ref7, _excluded2);
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(
          _objectSpread2(
            _objectSpread2({}, restProps),
            {},
            {
              innerProps: innerProps,
              isRtl: isRtl,
              size: size,
            },
          ),
          "loadingIndicator",
          {
            indicator: true,
            "loading-indicator": true,
          },
        ),
        innerProps,
      ),
      jsx(LoadingDot, {
        delay: 0,
        offset: isRtl,
      }),
      jsx(LoadingDot, {
        delay: 160,
        offset: true,
      }),
      jsx(LoadingDot, {
        delay: 320,
        offset: !isRtl,
      }),
    );
  };

  var css$1 = function css(_ref, unstyled) {
    var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      _ref$theme = _ref.theme,
      colors = _ref$theme.colors,
      borderRadius = _ref$theme.borderRadius,
      spacing = _ref$theme.spacing;
    return _objectSpread2(
      {
        label: "control",
        alignItems: "center",
        cursor: "default",
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-between",
        minHeight: spacing.controlHeight,
        outline: "0 !important",
        position: "relative",
        transition: "all 100ms",
      },
      unstyled
        ? {}
        : {
            backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
            borderColor: isDisabled
              ? colors.neutral10
              : isFocused
                ? colors.primary
                : colors.neutral20,
            borderRadius: borderRadius,
            borderStyle: "solid",
            borderWidth: 1,
            boxShadow: isFocused
              ? "0 0 0 1px ".concat(colors.primary)
              : undefined,
            "&:hover": {
              borderColor: isFocused ? colors.primary : colors.neutral30,
            },
          },
    );
  };
  var Control = function Control(props) {
    var children = props.children,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      innerRef = props.innerRef,
      innerProps = props.innerProps,
      menuIsOpen = props.menuIsOpen;
    return jsx(
      "div",
      _extends(
        {
          ref: innerRef,
        },
        getStyleProps(props, "control", {
          control: true,
          "control--is-disabled": isDisabled,
          "control--is-focused": isFocused,
          "control--menu-is-open": menuIsOpen,
        }),
        innerProps,
        {
          "aria-disabled": isDisabled || undefined,
        },
      ),
      children,
    );
  };
  var Control$1 = Control;

  var _excluded$1 = ["data"];
  var groupCSS = function groupCSS(_ref, unstyled) {
    var spacing = _ref.theme.spacing;
    return unstyled
      ? {}
      : {
          paddingBottom: spacing.baseUnit * 2,
          paddingTop: spacing.baseUnit * 2,
        };
  };
  var Group = function Group(props) {
    var children = props.children,
      cx = props.cx,
      getStyles = props.getStyles,
      getClassNames = props.getClassNames,
      Heading = props.Heading,
      headingProps = props.headingProps,
      innerProps = props.innerProps,
      label = props.label,
      theme = props.theme,
      selectProps = props.selectProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "group", {
          group: true,
        }),
        innerProps,
      ),
      jsx(
        Heading,
        _extends({}, headingProps, {
          selectProps: selectProps,
          theme: theme,
          getStyles: getStyles,
          getClassNames: getClassNames,
          cx: cx,
        }),
        label,
      ),
      jsx("div", null, children),
    );
  };
  var groupHeadingCSS = function groupHeadingCSS(_ref2, unstyled) {
    var _ref2$theme = _ref2.theme,
      colors = _ref2$theme.colors,
      spacing = _ref2$theme.spacing;
    return _objectSpread2(
      {
        label: "group",
        cursor: "default",
        display: "block",
      },
      unstyled
        ? {}
        : {
            color: colors.neutral40,
            fontSize: "75%",
            fontWeight: 500,
            marginBottom: "0.25em",
            paddingLeft: spacing.baseUnit * 3,
            paddingRight: spacing.baseUnit * 3,
            textTransform: "uppercase",
          },
    );
  };
  var GroupHeading = function GroupHeading(props) {
    var _cleanCommonProps = cleanCommonProps(props);
    _cleanCommonProps.data;
    var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "groupHeading", {
          "group-heading": true,
        }),
        innerProps,
      ),
    );
  };
  var Group$1 = Group;

  var _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
  var inputCSS = function inputCSS(_ref, unstyled) {
    var isDisabled = _ref.isDisabled,
      value = _ref.value,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
    return _objectSpread2(
      _objectSpread2(
        {
          visibility: isDisabled ? "hidden" : "visible",
          // force css to recompute when value change due to @emotion bug.
          // We can remove it whenever the bug is fixed.
          transform: value ? "translateZ(0)" : "",
        },
        containerStyle,
      ),
      unstyled
        ? {}
        : {
            margin: spacing.baseUnit / 2,
            paddingBottom: spacing.baseUnit / 2,
            paddingTop: spacing.baseUnit / 2,
            color: colors.neutral80,
          },
    );
  };
  var spacingStyle = {
    gridArea: "1 / 2",
    font: "inherit",
    minWidth: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0,
  };
  var containerStyle = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    "&:after": _objectSpread2(
      {
        content: 'attr(data-value) " "',
        visibility: "hidden",
        whiteSpace: "pre",
      },
      spacingStyle,
    ),
  };
  var inputStyle = function inputStyle(isHidden) {
    return _objectSpread2(
      {
        label: "input",
        color: "inherit",
        background: 0,
        opacity: isHidden ? 0 : 1,
        width: "100%",
      },
      spacingStyle,
    );
  };
  var Input = function Input(props) {
    var cx = props.cx,
      value = props.value;
    var _cleanCommonProps = cleanCommonProps(props),
      innerRef = _cleanCommonProps.innerRef,
      isDisabled = _cleanCommonProps.isDisabled,
      isHidden = _cleanCommonProps.isHidden,
      inputClassName = _cleanCommonProps.inputClassName,
      innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "input", {
          "input-container": true,
        }),
        {
          "data-value": value || "",
        },
      ),
      jsx(
        "input",
        _extends(
          {
            className: cx(
              {
                input: true,
              },
              inputClassName,
            ),
            ref: innerRef,
            style: inputStyle(isHidden),
            disabled: isDisabled,
          },
          innerProps,
        ),
      ),
    );
  };
  var Input$1 = Input;

  var multiValueCSS = function multiValueCSS(_ref, unstyled) {
    var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      borderRadius = _ref$theme.borderRadius,
      colors = _ref$theme.colors;
    return _objectSpread2(
      {
        label: "multiValue",
        display: "flex",
        minWidth: 0,
      },
      unstyled
        ? {}
        : {
            backgroundColor: colors.neutral10,
            borderRadius: borderRadius / 2,
            margin: spacing.baseUnit / 2,
          },
    );
  };
  var multiValueLabelCSS = function multiValueLabelCSS(_ref2, unstyled) {
    var _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      colors = _ref2$theme.colors,
      cropWithEllipsis = _ref2.cropWithEllipsis;
    return _objectSpread2(
      {
        overflow: "hidden",
        textOverflow:
          cropWithEllipsis || cropWithEllipsis === undefined
            ? "ellipsis"
            : undefined,
        whiteSpace: "nowrap",
      },
      unstyled
        ? {}
        : {
            borderRadius: borderRadius / 2,
            color: colors.neutral80,
            fontSize: "85%",
            padding: 3,
            paddingLeft: 6,
          },
    );
  };
  var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3, unstyled) {
    var _ref3$theme = _ref3.theme,
      spacing = _ref3$theme.spacing,
      borderRadius = _ref3$theme.borderRadius,
      colors = _ref3$theme.colors,
      isFocused = _ref3.isFocused;
    return _objectSpread2(
      {
        alignItems: "center",
        display: "flex",
      },
      unstyled
        ? {}
        : {
            borderRadius: borderRadius / 2,
            backgroundColor: isFocused ? colors.dangerLight : undefined,
            paddingLeft: spacing.baseUnit,
            paddingRight: spacing.baseUnit,
            ":hover": {
              backgroundColor: colors.dangerLight,
              color: colors.danger,
            },
          },
    );
  };
  var MultiValueGeneric = function MultiValueGeneric(_ref4) {
    var children = _ref4.children,
      innerProps = _ref4.innerProps;
    return jsx("div", innerProps, children);
  };
  var MultiValueContainer = MultiValueGeneric;
  var MultiValueLabel = MultiValueGeneric;
  function MultiValueRemove(_ref5) {
    var children = _ref5.children,
      innerProps = _ref5.innerProps;
    return jsx(
      "div",
      _extends(
        {
          role: "button",
        },
        innerProps,
      ),
      children ||
        jsx(CrossIcon, {
          size: 14,
        }),
    );
  }
  var MultiValue = function MultiValue(props) {
    var children = props.children,
      components = props.components,
      data = props.data,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      removeProps = props.removeProps,
      selectProps = props.selectProps;
    var Container = components.Container,
      Label = components.Label,
      Remove = components.Remove;
    return jsx(
      Container,
      {
        data: data,
        innerProps: _objectSpread2(
          _objectSpread2(
            {},
            getStyleProps(props, "multiValue", {
              "multi-value": true,
              "multi-value--is-disabled": isDisabled,
            }),
          ),
          innerProps,
        ),
        selectProps: selectProps,
      },
      jsx(
        Label,
        {
          data: data,
          innerProps: _objectSpread2(
            {},
            getStyleProps(props, "multiValueLabel", {
              "multi-value__label": true,
            }),
          ),
          selectProps: selectProps,
        },
        children,
      ),
      jsx(Remove, {
        data: data,
        innerProps: _objectSpread2(
          _objectSpread2(
            {},
            getStyleProps(props, "multiValueRemove", {
              "multi-value__remove": true,
            }),
          ),
          {},
          {
            "aria-label": "Remove ".concat(children || "option"),
          },
          removeProps,
        ),
        selectProps: selectProps,
      }),
    );
  };
  var MultiValue$1 = MultiValue;

  var optionCSS = function optionCSS(_ref, unstyled) {
    var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      isSelected = _ref.isSelected,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
    return _objectSpread2(
      {
        label: "option",
        cursor: "default",
        display: "block",
        fontSize: "inherit",
        width: "100%",
        userSelect: "none",
        WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
      },
      unstyled
        ? {}
        : {
            backgroundColor: isSelected
              ? colors.primary
              : isFocused
                ? colors.primary25
                : "transparent",
            color: isDisabled
              ? colors.neutral20
              : isSelected
                ? colors.neutral0
                : "inherit",
            padding: ""
              .concat(spacing.baseUnit * 2, "px ")
              .concat(spacing.baseUnit * 3, "px"),
            // provide some affordance on touch devices
            ":active": {
              backgroundColor: !isDisabled
                ? isSelected
                  ? colors.primary
                  : colors.primary50
                : undefined,
            },
          },
    );
  };
  var Option = function Option(props) {
    var children = props.children,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      isSelected = props.isSelected,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "option", {
          option: true,
          "option--is-disabled": isDisabled,
          "option--is-focused": isFocused,
          "option--is-selected": isSelected,
        }),
        {
          ref: innerRef,
          "aria-disabled": isDisabled,
        },
        innerProps,
      ),
      children,
    );
  };
  var Option$1 = Option;

  var placeholderCSS = function placeholderCSS(_ref, unstyled) {
    var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
    return _objectSpread2(
      {
        label: "placeholder",
        gridArea: "1 / 1 / 2 / 3",
      },
      unstyled
        ? {}
        : {
            color: colors.neutral50,
            marginLeft: spacing.baseUnit / 2,
            marginRight: spacing.baseUnit / 2,
          },
    );
  };
  var Placeholder = function Placeholder(props) {
    var children = props.children,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "placeholder", {
          placeholder: true,
        }),
        innerProps,
      ),
      children,
    );
  };
  var Placeholder$1 = Placeholder;

  var css = function css(_ref, unstyled) {
    var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
    return _objectSpread2(
      {
        label: "singleValue",
        gridArea: "1 / 1 / 2 / 3",
        maxWidth: "100%",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
      },
      unstyled
        ? {}
        : {
            color: isDisabled ? colors.neutral40 : colors.neutral80,
            marginLeft: spacing.baseUnit / 2,
            marginRight: spacing.baseUnit / 2,
          },
    );
  };
  var SingleValue = function SingleValue(props) {
    var children = props.children,
      isDisabled = props.isDisabled,
      innerProps = props.innerProps;
    return jsx(
      "div",
      _extends(
        {},
        getStyleProps(props, "singleValue", {
          "single-value": true,
          "single-value--is-disabled": isDisabled,
        }),
        innerProps,
      ),
      children,
    );
  };
  var SingleValue$1 = SingleValue;

  var components = {
    ClearIndicator: ClearIndicator,
    Control: Control$1,
    DropdownIndicator: DropdownIndicator,
    DownChevron: DownChevron,
    CrossIcon: CrossIcon,
    Group: Group$1,
    GroupHeading: GroupHeading,
    IndicatorsContainer: IndicatorsContainer,
    IndicatorSeparator: IndicatorSeparator,
    Input: Input$1,
    LoadingIndicator: LoadingIndicator,
    Menu: Menu$1,
    MenuList: MenuList,
    MenuPortal: MenuPortal,
    LoadingMessage: LoadingMessage,
    NoOptionsMessage: NoOptionsMessage,
    MultiValue: MultiValue$1,
    MultiValueContainer: MultiValueContainer,
    MultiValueLabel: MultiValueLabel,
    MultiValueRemove: MultiValueRemove,
    Option: Option$1,
    Placeholder: Placeholder$1,
    SelectContainer: SelectContainer,
    SingleValue: SingleValue$1,
    ValueContainer: ValueContainer,
  };
  var defaultComponents = function defaultComponents(props) {
    return _objectSpread2(_objectSpread2({}, components), props.components);
  };

  var safeIsNaN =
    Number.isNaN ||
    function ponyfill(value) {
      return typeof value === "number" && value !== value;
    };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }

  function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) {
      isEqual = areInputsEqual;
    }
    var cache = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (
        cache &&
        cache.lastThis === this &&
        isEqual(newArgs, cache.lastArgs)
      ) {
        return cache.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache = {
        lastResult: lastResult,
        lastArgs: newArgs,
        lastThis: this,
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache = null;
    };
    return memoized;
  }

  // Assistive text to describe visual elements. Hidden for sighted users.
  var _ref = {
    name: "7pg0cj-a11yText",
    styles:
      "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap",
  };
  var A11yText = function A11yText(props) {
    return jsx(
      "span",
      _extends(
        {
          css: _ref,
        },
        props,
      ),
    );
  };
  var A11yText$1 = A11yText;

  var defaultAriaLiveMessages = {
    guidance: function guidance(props) {
      var isSearchable = props.isSearchable,
        isMulti = props.isMulti,
        tabSelectsValue = props.tabSelectsValue,
        context = props.context,
        isInitialFocus = props.isInitialFocus;
      switch (context) {
        case "menu":
          return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(
            tabSelectsValue
              ? ", press Tab to select the option and exit the menu"
              : "",
            ".",
          );
        case "input":
          return isInitialFocus
            ? ""
                .concat(props["aria-label"] || "Select", " is focused ")
                .concat(
                  isSearchable ? ",type to refine list" : "",
                  ", press Down to open the menu, ",
                )
                .concat(isMulti ? " press left to focus selected values" : "")
            : "";
        case "value":
          return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
        default:
          return "";
      }
    },
    onChange: function onChange(props) {
      var action = props.action,
        _props$label = props.label,
        label = _props$label === void 0 ? "" : _props$label,
        labels = props.labels,
        isDisabled = props.isDisabled;
      switch (action) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return "option ".concat(label, ", deselected.");
        case "clear":
          return "All selected options have been cleared.";
        case "initial-input-focus":
          return "option"
            .concat(labels.length > 1 ? "s" : "", " ")
            .concat(labels.join(","), ", selected.");
        case "select-option":
          return isDisabled
            ? "option ".concat(label, " is disabled. Select another option.")
            : "option ".concat(label, ", selected.");
        default:
          return "";
      }
    },
    onFocus: function onFocus(props) {
      var context = props.context,
        focused = props.focused,
        options = props.options,
        _props$label2 = props.label,
        label = _props$label2 === void 0 ? "" : _props$label2,
        selectValue = props.selectValue,
        isDisabled = props.isDisabled,
        isSelected = props.isSelected,
        isAppleDevice = props.isAppleDevice;
      var getArrayIndex = function getArrayIndex(arr, item) {
        return arr && arr.length
          ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length)
          : "";
      };
      if (context === "value" && selectValue) {
        return "value "
          .concat(label, " focused, ")
          .concat(getArrayIndex(selectValue, focused), ".");
      }
      if (context === "menu" && isAppleDevice) {
        var disabled = isDisabled ? " disabled" : "";
        var status = "".concat(isSelected ? " selected" : "").concat(disabled);
        return ""
          .concat(label)
          .concat(status, ", ")
          .concat(getArrayIndex(options, focused), ".");
      }
      return "";
    },
    onFilter: function onFilter(props) {
      var inputValue = props.inputValue,
        resultsMessage = props.resultsMessage;
      return ""
        .concat(resultsMessage)
        .concat(inputValue ? " for search term " + inputValue : "", ".");
    },
  };

  var LiveRegion = function LiveRegion(props) {
    var ariaSelection = props.ariaSelection,
      focusedOption = props.focusedOption,
      focusedValue = props.focusedValue,
      focusableOptions = props.focusableOptions,
      isFocused = props.isFocused,
      selectValue = props.selectValue,
      selectProps = props.selectProps,
      id = props.id,
      isAppleDevice = props.isAppleDevice;
    var ariaLiveMessages = selectProps.ariaLiveMessages,
      getOptionLabel = selectProps.getOptionLabel,
      inputValue = selectProps.inputValue,
      isMulti = selectProps.isMulti,
      isOptionDisabled = selectProps.isOptionDisabled,
      isSearchable = selectProps.isSearchable,
      menuIsOpen = selectProps.menuIsOpen,
      options = selectProps.options,
      screenReaderStatus = selectProps.screenReaderStatus,
      tabSelectsValue = selectProps.tabSelectsValue,
      isLoading = selectProps.isLoading;
    var ariaLabel = selectProps["aria-label"];
    var ariaLive = selectProps["aria-live"];

    // Update aria live message configuration when prop changes
    var messages = reactExports.useMemo(
      function () {
        return _objectSpread2(
          _objectSpread2({}, defaultAriaLiveMessages),
          ariaLiveMessages || {},
        );
      },
      [ariaLiveMessages],
    );

    // Update aria live selected option when prop changes
    var ariaSelected = reactExports.useMemo(
      function () {
        var message = "";
        if (ariaSelection && messages.onChange) {
          var option = ariaSelection.option,
            selectedOptions = ariaSelection.options,
            removedValue = ariaSelection.removedValue,
            removedValues = ariaSelection.removedValues,
            value = ariaSelection.value;
          // select-option when !isMulti does not return option so we assume selected option is value
          var asOption = function asOption(val) {
            return !Array.isArray(val) ? val : null;
          };

          // If there is just one item from the action then get its label
          var selected = removedValue || option || asOption(value);
          var label = selected ? getOptionLabel(selected) : "";

          // If there are multiple items from the action then return an array of labels
          var multiSelected = selectedOptions || removedValues || undefined;
          var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];
          var onChangeProps = _objectSpread2(
            {
              // multiSelected items are usually items that have already been selected
              // or set by the user as a default value so we assume they are not disabled
              isDisabled: selected && isOptionDisabled(selected, selectValue),
              label: label,
              labels: labels,
            },
            ariaSelection,
          );
          message = messages.onChange(onChangeProps);
        }
        return message;
      },
      [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel],
    );
    var ariaFocused = reactExports.useMemo(
      function () {
        var focusMsg = "";
        var focused = focusedOption || focusedValue;
        var isSelected = !!(
          focusedOption &&
          selectValue &&
          selectValue.includes(focusedOption)
        );
        if (focused && messages.onFocus) {
          var onFocusProps = {
            focused: focused,
            label: getOptionLabel(focused),
            isDisabled: isOptionDisabled(focused, selectValue),
            isSelected: isSelected,
            options: focusableOptions,
            context: focused === focusedOption ? "menu" : "value",
            selectValue: selectValue,
            isAppleDevice: isAppleDevice,
          };
          focusMsg = messages.onFocus(onFocusProps);
        }
        return focusMsg;
      },
      [
        focusedOption,
        focusedValue,
        getOptionLabel,
        isOptionDisabled,
        messages,
        focusableOptions,
        selectValue,
        isAppleDevice,
      ],
    );
    var ariaResults = reactExports.useMemo(
      function () {
        var resultsMsg = "";
        if (menuIsOpen && options.length && !isLoading && messages.onFilter) {
          var resultsMessage = screenReaderStatus({
            count: focusableOptions.length,
          });
          resultsMsg = messages.onFilter({
            inputValue: inputValue,
            resultsMessage: resultsMessage,
          });
        }
        return resultsMsg;
      },
      [
        focusableOptions,
        inputValue,
        menuIsOpen,
        messages,
        options,
        screenReaderStatus,
        isLoading,
      ],
    );
    var isInitialFocus =
      (ariaSelection === null || ariaSelection === void 0
        ? void 0
        : ariaSelection.action) === "initial-input-focus";
    var ariaGuidance = reactExports.useMemo(
      function () {
        var guidanceMsg = "";
        if (messages.guidance) {
          var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
          guidanceMsg = messages.guidance({
            "aria-label": ariaLabel,
            context: context,
            isDisabled:
              focusedOption && isOptionDisabled(focusedOption, selectValue),
            isMulti: isMulti,
            isSearchable: isSearchable,
            tabSelectsValue: tabSelectsValue,
            isInitialFocus: isInitialFocus,
          });
        }
        return guidanceMsg;
      },
      [
        ariaLabel,
        focusedOption,
        focusedValue,
        isMulti,
        isOptionDisabled,
        isSearchable,
        menuIsOpen,
        messages,
        selectValue,
        tabSelectsValue,
        isInitialFocus,
      ],
    );
    var ScreenReaderText = jsx(
      reactExports.Fragment,
      null,
      jsx(
        "span",
        {
          id: "aria-selection",
        },
        ariaSelected,
      ),
      jsx(
        "span",
        {
          id: "aria-focused",
        },
        ariaFocused,
      ),
      jsx(
        "span",
        {
          id: "aria-results",
        },
        ariaResults,
      ),
      jsx(
        "span",
        {
          id: "aria-guidance",
        },
        ariaGuidance,
      ),
    );
    return jsx(
      reactExports.Fragment,
      null,
      jsx(
        A11yText$1,
        {
          id: id,
        },
        isInitialFocus && ScreenReaderText,
      ),
      jsx(
        A11yText$1,
        {
          "aria-live": ariaLive,
          "aria-atomic": "false",
          "aria-relevant": "additions text",
          role: "log",
        },
        isFocused && !isInitialFocus && ScreenReaderText,
      ),
    );
  };
  var LiveRegion$1 = LiveRegion;

  var diacritics = [
    {
      base: "A",
      letters:
        "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F",
    },
    {
      base: "AA",
      letters: "\uA732",
    },
    {
      base: "AE",
      letters: "\xC6\u01FC\u01E2",
    },
    {
      base: "AO",
      letters: "\uA734",
    },
    {
      base: "AU",
      letters: "\uA736",
    },
    {
      base: "AV",
      letters: "\uA738\uA73A",
    },
    {
      base: "AY",
      letters: "\uA73C",
    },
    {
      base: "B",
      letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181",
    },
    {
      base: "C",
      letters:
        "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E",
    },
    {
      base: "D",
      letters:
        "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779",
    },
    {
      base: "DZ",
      letters: "\u01F1\u01C4",
    },
    {
      base: "Dz",
      letters: "\u01F2\u01C5",
    },
    {
      base: "E",
      letters:
        "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E",
    },
    {
      base: "F",
      letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B",
    },
    {
      base: "G",
      letters:
        "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E",
    },
    {
      base: "H",
      letters:
        "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D",
    },
    {
      base: "I",
      letters:
        "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197",
    },
    {
      base: "J",
      letters: "J\u24BF\uFF2A\u0134\u0248",
    },
    {
      base: "K",
      letters:
        "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2",
    },
    {
      base: "L",
      letters:
        "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780",
    },
    {
      base: "LJ",
      letters: "\u01C7",
    },
    {
      base: "Lj",
      letters: "\u01C8",
    },
    {
      base: "M",
      letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C",
    },
    {
      base: "N",
      letters:
        "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4",
    },
    {
      base: "NJ",
      letters: "\u01CA",
    },
    {
      base: "Nj",
      letters: "\u01CB",
    },
    {
      base: "O",
      letters:
        "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C",
    },
    {
      base: "OI",
      letters: "\u01A2",
    },
    {
      base: "OO",
      letters: "\uA74E",
    },
    {
      base: "OU",
      letters: "\u0222",
    },
    {
      base: "P",
      letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754",
    },
    {
      base: "Q",
      letters: "Q\u24C6\uFF31\uA756\uA758\u024A",
    },
    {
      base: "R",
      letters:
        "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782",
    },
    {
      base: "S",
      letters:
        "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784",
    },
    {
      base: "T",
      letters:
        "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786",
    },
    {
      base: "TZ",
      letters: "\uA728",
    },
    {
      base: "U",
      letters:
        "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244",
    },
    {
      base: "V",
      letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245",
    },
    {
      base: "VY",
      letters: "\uA760",
    },
    {
      base: "W",
      letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72",
    },
    {
      base: "X",
      letters: "X\u24CD\uFF38\u1E8A\u1E8C",
    },
    {
      base: "Y",
      letters:
        "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE",
    },
    {
      base: "Z",
      letters:
        "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762",
    },
    {
      base: "a",
      letters:
        "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250",
    },
    {
      base: "aa",
      letters: "\uA733",
    },
    {
      base: "ae",
      letters: "\xE6\u01FD\u01E3",
    },
    {
      base: "ao",
      letters: "\uA735",
    },
    {
      base: "au",
      letters: "\uA737",
    },
    {
      base: "av",
      letters: "\uA739\uA73B",
    },
    {
      base: "ay",
      letters: "\uA73D",
    },
    {
      base: "b",
      letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253",
    },
    {
      base: "c",
      letters:
        "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184",
    },
    {
      base: "d",
      letters:
        "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A",
    },
    {
      base: "dz",
      letters: "\u01F3\u01C6",
    },
    {
      base: "e",
      letters:
        "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD",
    },
    {
      base: "f",
      letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C",
    },
    {
      base: "g",
      letters:
        "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F",
    },
    {
      base: "h",
      letters:
        "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265",
    },
    {
      base: "hv",
      letters: "\u0195",
    },
    {
      base: "i",
      letters:
        "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131",
    },
    {
      base: "j",
      letters: "j\u24D9\uFF4A\u0135\u01F0\u0249",
    },
    {
      base: "k",
      letters:
        "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
    },
    {
      base: "l",
      letters:
        "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747",
    },
    {
      base: "lj",
      letters: "\u01C9",
    },
    {
      base: "m",
      letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F",
    },
    {
      base: "n",
      letters:
        "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5",
    },
    {
      base: "nj",
      letters: "\u01CC",
    },
    {
      base: "o",
      letters:
        "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275",
    },
    {
      base: "oi",
      letters: "\u01A3",
    },
    {
      base: "ou",
      letters: "\u0223",
    },
    {
      base: "oo",
      letters: "\uA74F",
    },
    {
      base: "p",
      letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755",
    },
    {
      base: "q",
      letters: "q\u24E0\uFF51\u024B\uA757\uA759",
    },
    {
      base: "r",
      letters:
        "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783",
    },
    {
      base: "s",
      letters:
        "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B",
    },
    {
      base: "t",
      letters:
        "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787",
    },
    {
      base: "tz",
      letters: "\uA729",
    },
    {
      base: "u",
      letters:
        "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289",
    },
    {
      base: "v",
      letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C",
    },
    {
      base: "vy",
      letters: "\uA761",
    },
    {
      base: "w",
      letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73",
    },
    {
      base: "x",
      letters: "x\u24E7\uFF58\u1E8B\u1E8D",
    },
    {
      base: "y",
      letters:
        "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF",
    },
    {
      base: "z",
      letters:
        "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763",
    },
  ];
  var anyDiacritic = new RegExp(
    "[" +
      diacritics
        .map(function (d) {
          return d.letters;
        })
        .join("") +
      "]",
    "g",
  );
  var diacriticToBase = {};
  for (var i = 0; i < diacritics.length; i++) {
    var diacritic = diacritics[i];
    for (var j = 0; j < diacritic.letters.length; j++) {
      diacriticToBase[diacritic.letters[j]] = diacritic.base;
    }
  }
  var stripDiacritics = function stripDiacritics(str) {
    return str.replace(anyDiacritic, function (match) {
      return diacriticToBase[match];
    });
  };

  var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
  var trimString = function trimString(str) {
    return str.replace(/^\s+|\s+$/g, "");
  };
  var defaultStringify = function defaultStringify(option) {
    return "".concat(option.label, " ").concat(option.value);
  };
  var createFilter = function createFilter(config) {
    return function (option, rawInput) {
      // eslint-disable-next-line no-underscore-dangle
      if (option.data.__isNew__) return true;
      var _ignoreCase$ignoreAcc = _objectSpread2(
          {
            ignoreCase: true,
            ignoreAccents: true,
            stringify: defaultStringify,
            trim: true,
            matchFrom: "any",
          },
          config,
        ),
        ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
        ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
        stringify = _ignoreCase$ignoreAcc.stringify,
        trim = _ignoreCase$ignoreAcc.trim,
        matchFrom = _ignoreCase$ignoreAcc.matchFrom;
      var input = trim ? trimString(rawInput) : rawInput;
      var candidate = trim ? trimString(stringify(option)) : stringify(option);
      if (ignoreCase) {
        input = input.toLowerCase();
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        input = memoizedStripDiacriticsForInput(input);
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start"
        ? candidate.substr(0, input.length) === input
        : candidate.indexOf(input) > -1;
    };
  };

  var _excluded = ["innerRef"];
  function DummyInput(_ref) {
    var innerRef = _ref.innerRef,
      props = _objectWithoutProperties(_ref, _excluded);
    // Remove animation props not meant for HTML elements
    var filteredProps = removeProps(
      props,
      "onExited",
      "in",
      "enter",
      "exit",
      "appear",
    );
    return jsx(
      "input",
      _extends(
        {
          ref: innerRef,
        },
        filteredProps,
        {
          css: /*#__PURE__*/ css$2(
            {
              label: "dummyInput",
              // get rid of any default styles
              background: 0,
              border: 0,
              // important! this hides the flashing cursor
              caretColor: "transparent",
              fontSize: "inherit",
              gridArea: "1 / 1 / 2 / 3",
              outline: 0,
              padding: 0,
              // important! without `width` browsers won't allow focus
              width: 1,
              // remove cursor on desktop
              color: "transparent",
              // remove cursor on mobile whilst maintaining "scroll into view" behaviour
              left: -100,
              opacity: 0,
              position: "relative",
              transform: "scale(.01)",
            },
            "",
            "",
          ),
        },
      ),
    );
  }

  var cancelScroll = function cancelScroll(event) {
    if (event.cancelable) event.preventDefault();
    event.stopPropagation();
  };
  function useScrollCapture(_ref) {
    var isEnabled = _ref.isEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
    var isBottom = reactExports.useRef(false);
    var isTop = reactExports.useRef(false);
    var touchStart = reactExports.useRef(0);
    var scrollTarget = reactExports.useRef(null);
    var handleEventDelta = reactExports.useCallback(
      function (event, delta) {
        if (scrollTarget.current === null) return;
        var _scrollTarget$current = scrollTarget.current,
          scrollTop = _scrollTarget$current.scrollTop,
          scrollHeight = _scrollTarget$current.scrollHeight,
          clientHeight = _scrollTarget$current.clientHeight;
        var target = scrollTarget.current;
        var isDeltaPositive = delta > 0;
        var availableScroll = scrollHeight - clientHeight - scrollTop;
        var shouldCancelScroll = false;

        // reset bottom/top flags
        if (availableScroll > delta && isBottom.current) {
          if (onBottomLeave) onBottomLeave(event);
          isBottom.current = false;
        }
        if (isDeltaPositive && isTop.current) {
          if (onTopLeave) onTopLeave(event);
          isTop.current = false;
        }

        // bottom limit
        if (isDeltaPositive && delta > availableScroll) {
          if (onBottomArrive && !isBottom.current) {
            onBottomArrive(event);
          }
          target.scrollTop = scrollHeight;
          shouldCancelScroll = true;
          isBottom.current = true;

          // top limit
        } else if (!isDeltaPositive && -delta > scrollTop) {
          if (onTopArrive && !isTop.current) {
            onTopArrive(event);
          }
          target.scrollTop = 0;
          shouldCancelScroll = true;
          isTop.current = true;
        }

        // cancel scroll
        if (shouldCancelScroll) {
          cancelScroll(event);
        }
      },
      [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave],
    );
    var onWheel = reactExports.useCallback(
      function (event) {
        handleEventDelta(event, event.deltaY);
      },
      [handleEventDelta],
    );
    var onTouchStart = reactExports.useCallback(function (event) {
      // set touch start so we can calculate touchmove delta
      touchStart.current = event.changedTouches[0].clientY;
    }, []);
    var onTouchMove = reactExports.useCallback(
      function (event) {
        var deltaY = touchStart.current - event.changedTouches[0].clientY;
        handleEventDelta(event, deltaY);
      },
      [handleEventDelta],
    );
    var startListening = reactExports.useCallback(
      function (el) {
        // bail early if no element is available to attach to
        if (!el) return;
        var notPassive = supportsPassiveEvents
          ? {
              passive: false,
            }
          : false;
        el.addEventListener("wheel", onWheel, notPassive);
        el.addEventListener("touchstart", onTouchStart, notPassive);
        el.addEventListener("touchmove", onTouchMove, notPassive);
      },
      [onTouchMove, onTouchStart, onWheel],
    );
    var stopListening = reactExports.useCallback(
      function (el) {
        // bail early if no element is available to detach from
        if (!el) return;
        el.removeEventListener("wheel", onWheel, false);
        el.removeEventListener("touchstart", onTouchStart, false);
        el.removeEventListener("touchmove", onTouchMove, false);
      },
      [onTouchMove, onTouchStart, onWheel],
    );
    reactExports.useEffect(
      function () {
        if (!isEnabled) return;
        var element = scrollTarget.current;
        startListening(element);
        return function () {
          stopListening(element);
        };
      },
      [isEnabled, startListening, stopListening],
    );
    return function (element) {
      scrollTarget.current = element;
    };
  }

  var STYLE_KEYS = [
    "boxSizing",
    "height",
    "overflow",
    "paddingRight",
    "position",
  ];
  var LOCK_STYLES = {
    boxSizing: "border-box",
    // account for possible declaration `width: 100%;` on body
    overflow: "hidden",
    position: "relative",
    height: "100%",
  };
  function preventTouchMove(e) {
    if (e.cancelable) e.preventDefault();
  }
  function allowTouchMove(e) {
    e.stopPropagation();
  }
  function preventInertiaScroll() {
    var top = this.scrollTop;
    var totalScroll = this.scrollHeight;
    var currentScroll = top + this.offsetHeight;
    if (top === 0) {
      this.scrollTop = 1;
    } else if (currentScroll === totalScroll) {
      this.scrollTop = top - 1;
    }
  }

  // `ontouchstart` check works on most browsers
  // `maxTouchPoints` works on IE10/11 and Surface
  function isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints;
  }
  var canUseDOM = !!(
    typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
  );
  var activeScrollLocks = 0;
  var listenerOptions = {
    capture: false,
    passive: false,
  };
  function useScrollLock(_ref) {
    var isEnabled = _ref.isEnabled,
      _ref$accountForScroll = _ref.accountForScrollbars,
      accountForScrollbars =
        _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
    var originalStyles = reactExports.useRef({});
    var scrollTarget = reactExports.useRef(null);
    var addScrollLock = reactExports.useCallback(
      function (touchScrollTarget) {
        if (!canUseDOM) return;
        var target = document.body;
        var targetStyle = target && target.style;
        if (accountForScrollbars) {
          // store any styles already applied to the body
          STYLE_KEYS.forEach(function (key) {
            var val = targetStyle && targetStyle[key];
            originalStyles.current[key] = val;
          });
        }

        // apply the lock styles and padding if this is the first scroll lock
        if (accountForScrollbars && activeScrollLocks < 1) {
          var currentPadding =
            parseInt(originalStyles.current.paddingRight, 10) || 0;
          var clientWidth = document.body ? document.body.clientWidth : 0;
          var adjustedPadding =
            window.innerWidth - clientWidth + currentPadding || 0;
          Object.keys(LOCK_STYLES).forEach(function (key) {
            var val = LOCK_STYLES[key];
            if (targetStyle) {
              targetStyle[key] = val;
            }
          });
          if (targetStyle) {
            targetStyle.paddingRight = "".concat(adjustedPadding, "px");
          }
        }

        // account for touch devices
        if (target && isTouchDevice()) {
          // Mobile Safari ignores { overflow: hidden } declaration on the body.
          target.addEventListener(
            "touchmove",
            preventTouchMove,
            listenerOptions,
          );

          // Allow scroll on provided target
          if (touchScrollTarget) {
            touchScrollTarget.addEventListener(
              "touchstart",
              preventInertiaScroll,
              listenerOptions,
            );
            touchScrollTarget.addEventListener(
              "touchmove",
              allowTouchMove,
              listenerOptions,
            );
          }
        }

        // increment active scroll locks
        activeScrollLocks += 1;
      },
      [accountForScrollbars],
    );
    var removeScrollLock = reactExports.useCallback(
      function (touchScrollTarget) {
        if (!canUseDOM) return;
        var target = document.body;
        var targetStyle = target && target.style;

        // safely decrement active scroll locks
        activeScrollLocks = Math.max(activeScrollLocks - 1, 0);

        // reapply original body styles, if any
        if (accountForScrollbars && activeScrollLocks < 1) {
          STYLE_KEYS.forEach(function (key) {
            var val = originalStyles.current[key];
            if (targetStyle) {
              targetStyle[key] = val;
            }
          });
        }

        // remove touch listeners
        if (target && isTouchDevice()) {
          target.removeEventListener(
            "touchmove",
            preventTouchMove,
            listenerOptions,
          );
          if (touchScrollTarget) {
            touchScrollTarget.removeEventListener(
              "touchstart",
              preventInertiaScroll,
              listenerOptions,
            );
            touchScrollTarget.removeEventListener(
              "touchmove",
              allowTouchMove,
              listenerOptions,
            );
          }
        }
      },
      [accountForScrollbars],
    );
    reactExports.useEffect(
      function () {
        if (!isEnabled) return;
        var element = scrollTarget.current;
        addScrollLock(element);
        return function () {
          removeScrollLock(element);
        };
      },
      [isEnabled, addScrollLock, removeScrollLock],
    );
    return function (element) {
      scrollTarget.current = element;
    };
  }
  var blurSelectInput = function blurSelectInput(event) {
    var element = event.target;
    return (
      element.ownerDocument.activeElement &&
      element.ownerDocument.activeElement.blur()
    );
  };
  var _ref2$1 = {
    name: "1kfdb0e",
    styles: "position:fixed;left:0;bottom:0;right:0;top:0",
  };
  function ScrollManager(_ref) {
    var children = _ref.children,
      lockEnabled = _ref.lockEnabled,
      _ref$captureEnabled = _ref.captureEnabled,
      captureEnabled =
        _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
    var setScrollCaptureTarget = useScrollCapture({
      isEnabled: captureEnabled,
      onBottomArrive: onBottomArrive,
      onBottomLeave: onBottomLeave,
      onTopArrive: onTopArrive,
      onTopLeave: onTopLeave,
    });
    var setScrollLockTarget = useScrollLock({
      isEnabled: lockEnabled,
    });
    var targetRef = function targetRef(element) {
      setScrollCaptureTarget(element);
      setScrollLockTarget(element);
    };
    return jsx(
      reactExports.Fragment,
      null,
      lockEnabled &&
        jsx("div", {
          onClick: blurSelectInput,
          css: _ref2$1,
        }),
      children(targetRef),
    );
  }
  var _ref2 = {
    name: "1a0ro4n-requiredInput",
    styles:
      "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%",
  };
  var RequiredInput = function RequiredInput(_ref) {
    var name = _ref.name,
      onFocus = _ref.onFocus;
    return jsx("input", {
      required: true,
      name: name,
      tabIndex: -1,
      "aria-hidden": "true",
      onFocus: onFocus,
      css: _ref2,
      // Prevent `Switching from uncontrolled to controlled` error
      value: "",
      onChange: function onChange() {},
    });
  };
  var RequiredInput$1 = RequiredInput;

  /// <reference types="user-agent-data-types" />

  function testPlatform(re) {
    var _window$navigator$use;
    return typeof window !== "undefined" && window.navigator != null
      ? re.test(
          ((_window$navigator$use = window.navigator["userAgentData"]) ===
            null || _window$navigator$use === void 0
            ? void 0
            : _window$navigator$use.platform) || window.navigator.platform,
        )
      : false;
  }
  function isIPhone() {
    return testPlatform(/^iPhone/i);
  }
  function isMac() {
    return testPlatform(/^Mac/i);
  }
  function isIPad() {
    return (
      testPlatform(/^iPad/i) ||
      // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
      (isMac() && navigator.maxTouchPoints > 1)
    );
  }
  function isIOS() {
    return isIPhone() || isIPad();
  }
  function isAppleDevice() {
    return isMac() || isIOS();
  }

  var formatGroupLabel = function formatGroupLabel(group) {
    return group.label;
  };
  var getOptionLabel$1 = function getOptionLabel(option) {
    return option.label;
  };
  var getOptionValue$1 = function getOptionValue(option) {
    return option.value;
  };
  var isOptionDisabled = function isOptionDisabled(option) {
    return !!option.isDisabled;
  };

  var defaultStyles = {
    clearIndicator: clearIndicatorCSS,
    container: containerCSS,
    control: css$1,
    dropdownIndicator: dropdownIndicatorCSS,
    group: groupCSS,
    groupHeading: groupHeadingCSS,
    indicatorsContainer: indicatorsContainerCSS,
    indicatorSeparator: indicatorSeparatorCSS,
    input: inputCSS,
    loadingIndicator: loadingIndicatorCSS,
    loadingMessage: loadingMessageCSS,
    menu: menuCSS,
    menuList: menuListCSS,
    menuPortal: menuPortalCSS,
    multiValue: multiValueCSS,
    multiValueLabel: multiValueLabelCSS,
    multiValueRemove: multiValueRemoveCSS,
    noOptionsMessage: noOptionsMessageCSS,
    option: optionCSS,
    placeholder: placeholderCSS,
    singleValue: css,
    valueContainer: valueContainerCSS,
  };

  var colors = {
    primary: "#2684FF",
    primary75: "#4C9AFF",
    primary50: "#B2D4FF",
    primary25: "#DEEBFF",
    danger: "#DE350B",
    dangerLight: "#FFBDAD",
    neutral0: "hsl(0, 0%, 100%)",
    neutral5: "hsl(0, 0%, 95%)",
    neutral10: "hsl(0, 0%, 90%)",
    neutral20: "hsl(0, 0%, 80%)",
    neutral30: "hsl(0, 0%, 70%)",
    neutral40: "hsl(0, 0%, 60%)",
    neutral50: "hsl(0, 0%, 50%)",
    neutral60: "hsl(0, 0%, 40%)",
    neutral70: "hsl(0, 0%, 30%)",
    neutral80: "hsl(0, 0%, 20%)",
    neutral90: "hsl(0, 0%, 10%)",
  };
  var borderRadius = 4;
  // Used to calculate consistent margin/padding on elements
  var baseUnit = 4;
  // The minimum height of the control
  var controlHeight = 38;
  // The amount of space between the control and menu */
  var menuGutter = baseUnit * 2;
  var spacing = {
    baseUnit: baseUnit,
    controlHeight: controlHeight,
    menuGutter: menuGutter,
  };
  var defaultTheme = {
    borderRadius: borderRadius,
    colors: colors,
    spacing: spacing,
  };

  var defaultProps = {
    "aria-live": "polite",
    backspaceRemovesValue: true,
    blurInputOnSelect: isTouchCapable(),
    captureMenuScroll: !isTouchCapable(),
    classNames: {},
    closeMenuOnSelect: true,
    closeMenuOnScroll: false,
    components: {},
    controlShouldRenderValue: true,
    escapeClearsValue: false,
    filterOption: createFilter(),
    formatGroupLabel: formatGroupLabel,
    getOptionLabel: getOptionLabel$1,
    getOptionValue: getOptionValue$1,
    isDisabled: false,
    isLoading: false,
    isMulti: false,
    isRtl: false,
    isSearchable: true,
    isOptionDisabled: isOptionDisabled,
    loadingMessage: function loadingMessage() {
      return "Loading...";
    },
    maxMenuHeight: 300,
    minMenuHeight: 140,
    menuIsOpen: false,
    menuPlacement: "bottom",
    menuPosition: "absolute",
    menuShouldBlockScroll: false,
    menuShouldScrollIntoView: !isMobileDevice(),
    noOptionsMessage: function noOptionsMessage() {
      return "No options";
    },
    openMenuOnFocus: false,
    openMenuOnClick: true,
    options: [],
    pageSize: 5,
    placeholder: "Select...",
    screenReaderStatus: function screenReaderStatus(_ref) {
      var count = _ref.count;
      return ""
        .concat(count, " result")
        .concat(count !== 1 ? "s" : "", " available");
    },
    styles: {},
    tabIndex: 0,
    tabSelectsValue: true,
    unstyled: false,
  };
  function toCategorizedOption(props, option, selectValue, index) {
    var isDisabled = _isOptionDisabled(props, option, selectValue);
    var isSelected = _isOptionSelected(props, option, selectValue);
    var label = getOptionLabel(props, option);
    var value = getOptionValue(props, option);
    return {
      type: "option",
      data: option,
      isDisabled: isDisabled,
      isSelected: isSelected,
      label: label,
      value: value,
      index: index,
    };
  }
  function buildCategorizedOptions(props, selectValue) {
    return props.options
      .map(function (groupOrOption, groupOrOptionIndex) {
        if ("options" in groupOrOption) {
          var categorizedOptions = groupOrOption.options
            .map(function (option, optionIndex) {
              return toCategorizedOption(
                props,
                option,
                selectValue,
                optionIndex,
              );
            })
            .filter(function (categorizedOption) {
              return isFocusable(props, categorizedOption);
            });
          return categorizedOptions.length > 0
            ? {
                type: "group",
                data: groupOrOption,
                options: categorizedOptions,
                index: groupOrOptionIndex,
              }
            : undefined;
        }
        var categorizedOption = toCategorizedOption(
          props,
          groupOrOption,
          selectValue,
          groupOrOptionIndex,
        );
        return isFocusable(props, categorizedOption)
          ? categorizedOption
          : undefined;
      })
      .filter(notNullish);
  }
  function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
    return categorizedOptions.reduce(function (
      optionsAccumulator,
      categorizedOption,
    ) {
      if (categorizedOption.type === "group") {
        optionsAccumulator.push.apply(
          optionsAccumulator,
          _toConsumableArray(
            categorizedOption.options.map(function (option) {
              return option.data;
            }),
          ),
        );
      } else {
        optionsAccumulator.push(categorizedOption.data);
      }
      return optionsAccumulator;
    }, []);
  }
  function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
    return categorizedOptions.reduce(function (
      optionsAccumulator,
      categorizedOption,
    ) {
      if (categorizedOption.type === "group") {
        optionsAccumulator.push.apply(
          optionsAccumulator,
          _toConsumableArray(
            categorizedOption.options.map(function (option) {
              return {
                data: option.data,
                id: ""
                  .concat(optionId, "-")
                  .concat(categorizedOption.index, "-")
                  .concat(option.index),
              };
            }),
          ),
        );
      } else {
        optionsAccumulator.push({
          data: categorizedOption.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index),
        });
      }
      return optionsAccumulator;
    }, []);
  }
  function buildFocusableOptions(props, selectValue) {
    return buildFocusableOptionsFromCategorizedOptions(
      buildCategorizedOptions(props, selectValue),
    );
  }
  function isFocusable(props, categorizedOption) {
    var _props$inputValue = props.inputValue,
      inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
    var data = categorizedOption.data,
      isSelected = categorizedOption.isSelected,
      label = categorizedOption.label,
      value = categorizedOption.value;
    return (
      (!shouldHideSelectedOptions(props) || !isSelected) &&
      _filterOption(
        props,
        {
          label: label,
          value: value,
          data: data,
        },
        inputValue,
      )
    );
  }
  function getNextFocusedValue(state, nextSelectValue) {
    var focusedValue = state.focusedValue,
      lastSelectValue = state.selectValue;
    var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
    if (lastFocusedIndex > -1) {
      var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
      if (nextFocusedIndex > -1) {
        // the focused value is still in the selectValue, return it
        return focusedValue;
      } else if (lastFocusedIndex < nextSelectValue.length) {
        // the focusedValue is not present in the next selectValue array by
        // reference, so return the new value at the same index
        return nextSelectValue[lastFocusedIndex];
      }
    }
    return null;
  }
  function getNextFocusedOption(state, options) {
    var lastFocusedOption = state.focusedOption;
    return lastFocusedOption && options.indexOf(lastFocusedOption) > -1
      ? lastFocusedOption
      : options[0];
  }
  var getFocusedOptionId = function getFocusedOptionId(
    focusableOptionsWithIds,
    focusedOption,
  ) {
    var _focusableOptionsWith;
    var focusedOptionId =
      (_focusableOptionsWith = focusableOptionsWithIds.find(function (option) {
        return option.data === focusedOption;
      })) === null || _focusableOptionsWith === void 0
        ? void 0
        : _focusableOptionsWith.id;
    return focusedOptionId || null;
  };
  var getOptionLabel = function getOptionLabel(props, data) {
    return props.getOptionLabel(data);
  };
  var getOptionValue = function getOptionValue(props, data) {
    return props.getOptionValue(data);
  };
  function _isOptionDisabled(props, option, selectValue) {
    return typeof props.isOptionDisabled === "function"
      ? props.isOptionDisabled(option, selectValue)
      : false;
  }
  function _isOptionSelected(props, option, selectValue) {
    if (selectValue.indexOf(option) > -1) return true;
    if (typeof props.isOptionSelected === "function") {
      return props.isOptionSelected(option, selectValue);
    }
    var candidate = getOptionValue(props, option);
    return selectValue.some(function (i) {
      return getOptionValue(props, i) === candidate;
    });
  }
  function _filterOption(props, option, inputValue) {
    return props.filterOption ? props.filterOption(option, inputValue) : true;
  }
  var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
    var hideSelectedOptions = props.hideSelectedOptions,
      isMulti = props.isMulti;
    if (hideSelectedOptions === undefined) return isMulti;
    return hideSelectedOptions;
  };
  var instanceId = 1;
  var Select = /*#__PURE__*/ (function (_Component) {
    _inherits(Select, _Component);
    var _super = _createSuper(Select);
    // Misc. Instance Properties
    // ------------------------------

    // TODO

    // Refs
    // ------------------------------

    // Lifecycle
    // ------------------------------

    function Select(_props) {
      var _this;
      _classCallCheck(this, Select);
      _this = _super.call(this, _props);
      _this.state = {
        ariaSelection: null,
        focusedOption: null,
        focusedOptionId: null,
        focusableOptionsWithIds: [],
        focusedValue: null,
        inputIsHidden: false,
        isFocused: false,
        selectValue: [],
        clearFocusValueOnUpdate: false,
        prevWasFocused: false,
        inputIsHiddenAfterUpdate: undefined,
        prevProps: undefined,
        instancePrefix: "",
        isAppleDevice: false,
      };
      _this.blockOptionHover = false;
      _this.isComposing = false;
      _this.commonProps = void 0;
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
      _this.openAfterFocus = false;
      _this.scrollToFocusedOptionOnUpdate = false;
      _this.userIsDragging = void 0;
      _this.controlRef = null;
      _this.getControlRef = function (ref) {
        _this.controlRef = ref;
      };
      _this.focusedOptionRef = null;
      _this.getFocusedOptionRef = function (ref) {
        _this.focusedOptionRef = ref;
      };
      _this.menuListRef = null;
      _this.getMenuListRef = function (ref) {
        _this.menuListRef = ref;
      };
      _this.inputRef = null;
      _this.getInputRef = function (ref) {
        _this.inputRef = ref;
      };
      _this.focus = _this.focusInput;
      _this.blur = _this.blurInput;
      _this.onChange = function (newValue, actionMeta) {
        var _this$props = _this.props,
          onChange = _this$props.onChange,
          name = _this$props.name;
        actionMeta.name = name;
        _this.ariaOnChange(newValue, actionMeta);
        onChange(newValue, actionMeta);
      };
      _this.setValue = function (newValue, action, option) {
        var _this$props2 = _this.props,
          closeMenuOnSelect = _this$props2.closeMenuOnSelect,
          isMulti = _this$props2.isMulti,
          inputValue = _this$props2.inputValue;
        _this.onInputChange("", {
          action: "set-value",
          prevInputValue: inputValue,
        });
        if (closeMenuOnSelect) {
          _this.setState({
            inputIsHiddenAfterUpdate: !isMulti,
          });
          _this.onMenuClose();
        }
        // when the select value should change, we should reset focusedValue
        _this.setState({
          clearFocusValueOnUpdate: true,
        });
        _this.onChange(newValue, {
          action: action,
          option: option,
        });
      };
      _this.selectOption = function (newValue) {
        var _this$props3 = _this.props,
          blurInputOnSelect = _this$props3.blurInputOnSelect,
          isMulti = _this$props3.isMulti,
          name = _this$props3.name;
        var selectValue = _this.state.selectValue;
        var deselected =
          isMulti && _this.isOptionSelected(newValue, selectValue);
        var isDisabled = _this.isOptionDisabled(newValue, selectValue);
        if (deselected) {
          var candidate = _this.getOptionValue(newValue);
          _this.setValue(
            multiValueAsValue(
              selectValue.filter(function (i) {
                return _this.getOptionValue(i) !== candidate;
              }),
            ),
            "deselect-option",
            newValue,
          );
        } else if (!isDisabled) {
          // Select option if option is not disabled
          if (isMulti) {
            _this.setValue(
              multiValueAsValue(
                [].concat(_toConsumableArray(selectValue), [newValue]),
              ),
              "select-option",
              newValue,
            );
          } else {
            _this.setValue(singleValueAsValue(newValue), "select-option");
          }
        } else {
          _this.ariaOnChange(singleValueAsValue(newValue), {
            action: "select-option",
            option: newValue,
            name: name,
          });
          return;
        }
        if (blurInputOnSelect) {
          _this.blurInput();
        }
      };
      _this.removeValue = function (removedValue) {
        var isMulti = _this.props.isMulti;
        var selectValue = _this.state.selectValue;
        var candidate = _this.getOptionValue(removedValue);
        var newValueArray = selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        });
        var newValue = valueTernary(
          isMulti,
          newValueArray,
          newValueArray[0] || null,
        );
        _this.onChange(newValue, {
          action: "remove-value",
          removedValue: removedValue,
        });
        _this.focusInput();
      };
      _this.clearValue = function () {
        var selectValue = _this.state.selectValue;
        _this.onChange(valueTernary(_this.props.isMulti, [], null), {
          action: "clear",
          removedValues: selectValue,
        });
      };
      _this.popValue = function () {
        var isMulti = _this.props.isMulti;
        var selectValue = _this.state.selectValue;
        var lastSelectedValue = selectValue[selectValue.length - 1];
        var newValueArray = selectValue.slice(0, selectValue.length - 1);
        var newValue = valueTernary(
          isMulti,
          newValueArray,
          newValueArray[0] || null,
        );
        if (lastSelectedValue) {
          _this.onChange(newValue, {
            action: "pop-value",
            removedValue: lastSelectedValue,
          });
        }
      };
      _this.getFocusedOptionId = function (focusedOption) {
        return getFocusedOptionId(
          _this.state.focusableOptionsWithIds,
          focusedOption,
        );
      };
      _this.getFocusableOptionsWithIds = function () {
        return buildFocusableOptionsWithIds(
          buildCategorizedOptions(_this.props, _this.state.selectValue),
          _this.getElementId("option"),
        );
      };
      _this.getValue = function () {
        return _this.state.selectValue;
      };
      _this.cx = function () {
        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        return classNames.apply(
          void 0,
          [_this.props.classNamePrefix].concat(args),
        );
      };
      _this.getOptionLabel = function (data) {
        return getOptionLabel(_this.props, data);
      };
      _this.getOptionValue = function (data) {
        return getOptionValue(_this.props, data);
      };
      _this.getStyles = function (key, props) {
        var unstyled = _this.props.unstyled;
        var base = defaultStyles[key](props, unstyled);
        base.boxSizing = "border-box";
        var custom = _this.props.styles[key];
        return custom ? custom(base, props) : base;
      };
      _this.getClassNames = function (key, props) {
        var _this$props$className, _this$props$className2;
        return (_this$props$className = (_this$props$className2 =
          _this.props.classNames)[key]) === null ||
          _this$props$className === void 0
          ? void 0
          : _this$props$className.call(_this$props$className2, props);
      };
      _this.getElementId = function (element) {
        return "".concat(_this.state.instancePrefix, "-").concat(element);
      };
      _this.getComponents = function () {
        return defaultComponents(_this.props);
      };
      _this.buildCategorizedOptions = function () {
        return buildCategorizedOptions(_this.props, _this.state.selectValue);
      };
      _this.getCategorizedOptions = function () {
        return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
      };
      _this.buildFocusableOptions = function () {
        return buildFocusableOptionsFromCategorizedOptions(
          _this.buildCategorizedOptions(),
        );
      };
      _this.getFocusableOptions = function () {
        return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
      };
      _this.ariaOnChange = function (value, actionMeta) {
        _this.setState({
          ariaSelection: _objectSpread2(
            {
              value: value,
            },
            actionMeta,
          ),
        });
      };
      _this.onMenuMouseDown = function (event) {
        if (event.button !== 0) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        _this.focusInput();
      };
      _this.onMenuMouseMove = function (event) {
        _this.blockOptionHover = false;
      };
      _this.onControlMouseDown = function (event) {
        // Event captured by dropdown indicator
        if (event.defaultPrevented) {
          return;
        }
        var openMenuOnClick = _this.props.openMenuOnClick;
        if (!_this.state.isFocused) {
          if (openMenuOnClick) {
            _this.openAfterFocus = true;
          }
          _this.focusInput();
        } else if (!_this.props.menuIsOpen) {
          if (openMenuOnClick) {
            _this.openMenu("first");
          }
        } else {
          if (
            event.target.tagName !== "INPUT" &&
            event.target.tagName !== "TEXTAREA"
          ) {
            _this.onMenuClose();
          }
        }
        if (
          event.target.tagName !== "INPUT" &&
          event.target.tagName !== "TEXTAREA"
        ) {
          event.preventDefault();
        }
      };
      _this.onDropdownIndicatorMouseDown = function (event) {
        // ignore mouse events that weren't triggered by the primary button
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        if (_this.props.isDisabled) return;
        var _this$props4 = _this.props,
          isMulti = _this$props4.isMulti,
          menuIsOpen = _this$props4.menuIsOpen;
        _this.focusInput();
        if (menuIsOpen) {
          _this.setState({
            inputIsHiddenAfterUpdate: !isMulti,
          });
          _this.onMenuClose();
        } else {
          _this.openMenu("first");
        }
        event.preventDefault();
      };
      _this.onClearIndicatorMouseDown = function (event) {
        // ignore mouse events that weren't triggered by the primary button
        if (event && event.type === "mousedown" && event.button !== 0) {
          return;
        }
        _this.clearValue();
        event.preventDefault();
        _this.openAfterFocus = false;
        if (event.type === "touchend") {
          _this.focusInput();
        } else {
          setTimeout(function () {
            return _this.focusInput();
          });
        }
      };
      _this.onScroll = function (event) {
        if (typeof _this.props.closeMenuOnScroll === "boolean") {
          if (
            event.target instanceof HTMLElement &&
            isDocumentElement(event.target)
          ) {
            _this.props.onMenuClose();
          }
        } else if (typeof _this.props.closeMenuOnScroll === "function") {
          if (_this.props.closeMenuOnScroll(event)) {
            _this.props.onMenuClose();
          }
        }
      };
      _this.onCompositionStart = function () {
        _this.isComposing = true;
      };
      _this.onCompositionEnd = function () {
        _this.isComposing = false;
      };
      _this.onTouchStart = function (_ref2) {
        var touches = _ref2.touches;
        var touch = touches && touches.item(0);
        if (!touch) {
          return;
        }
        _this.initialTouchX = touch.clientX;
        _this.initialTouchY = touch.clientY;
        _this.userIsDragging = false;
      };
      _this.onTouchMove = function (_ref3) {
        var touches = _ref3.touches;
        var touch = touches && touches.item(0);
        if (!touch) {
          return;
        }
        var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
        var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
        var moveThreshold = 5;
        _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
      };
      _this.onTouchEnd = function (event) {
        if (_this.userIsDragging) return;

        // close the menu if the user taps outside
        // we're checking on event.target here instead of event.currentTarget, because we want to assert information
        // on events on child elements, not the document (which we've attached this handler to).
        if (
          _this.controlRef &&
          !_this.controlRef.contains(event.target) &&
          _this.menuListRef &&
          !_this.menuListRef.contains(event.target)
        ) {
          _this.blurInput();
        }

        // reset move vars
        _this.initialTouchX = 0;
        _this.initialTouchY = 0;
      };
      _this.onControlTouchEnd = function (event) {
        if (_this.userIsDragging) return;
        _this.onControlMouseDown(event);
      };
      _this.onClearIndicatorTouchEnd = function (event) {
        if (_this.userIsDragging) return;
        _this.onClearIndicatorMouseDown(event);
      };
      _this.onDropdownIndicatorTouchEnd = function (event) {
        if (_this.userIsDragging) return;
        _this.onDropdownIndicatorMouseDown(event);
      };
      _this.handleInputChange = function (event) {
        var prevInputValue = _this.props.inputValue;
        var inputValue = event.currentTarget.value;
        _this.setState({
          inputIsHiddenAfterUpdate: false,
        });
        _this.onInputChange(inputValue, {
          action: "input-change",
          prevInputValue: prevInputValue,
        });
        if (!_this.props.menuIsOpen) {
          _this.onMenuOpen();
        }
      };
      _this.onInputFocus = function (event) {
        if (_this.props.onFocus) {
          _this.props.onFocus(event);
        }
        _this.setState({
          inputIsHiddenAfterUpdate: false,
          isFocused: true,
        });
        if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
          _this.openMenu("first");
        }
        _this.openAfterFocus = false;
      };
      _this.onInputBlur = function (event) {
        var prevInputValue = _this.props.inputValue;
        if (
          _this.menuListRef &&
          _this.menuListRef.contains(document.activeElement)
        ) {
          _this.inputRef.focus();
          return;
        }
        if (_this.props.onBlur) {
          _this.props.onBlur(event);
        }
        _this.onInputChange("", {
          action: "input-blur",
          prevInputValue: prevInputValue,
        });
        _this.onMenuClose();
        _this.setState({
          focusedValue: null,
          isFocused: false,
        });
      };
      _this.onOptionHover = function (focusedOption) {
        if (
          _this.blockOptionHover ||
          _this.state.focusedOption === focusedOption
        ) {
          return;
        }
        var options = _this.getFocusableOptions();
        var focusedOptionIndex = options.indexOf(focusedOption);
        _this.setState({
          focusedOption: focusedOption,
          focusedOptionId:
            focusedOptionIndex > -1
              ? _this.getFocusedOptionId(focusedOption)
              : null,
        });
      };
      _this.shouldHideSelectedOptions = function () {
        return shouldHideSelectedOptions(_this.props);
      };
      _this.onValueInputFocus = function (e) {
        e.preventDefault();
        e.stopPropagation();
        _this.focus();
      };
      _this.onKeyDown = function (event) {
        var _this$props5 = _this.props,
          isMulti = _this$props5.isMulti,
          backspaceRemovesValue = _this$props5.backspaceRemovesValue,
          escapeClearsValue = _this$props5.escapeClearsValue,
          inputValue = _this$props5.inputValue,
          isClearable = _this$props5.isClearable,
          isDisabled = _this$props5.isDisabled,
          menuIsOpen = _this$props5.menuIsOpen,
          onKeyDown = _this$props5.onKeyDown,
          tabSelectsValue = _this$props5.tabSelectsValue,
          openMenuOnFocus = _this$props5.openMenuOnFocus;
        var _this$state = _this.state,
          focusedOption = _this$state.focusedOption,
          focusedValue = _this$state.focusedValue,
          selectValue = _this$state.selectValue;
        if (isDisabled) return;
        if (typeof onKeyDown === "function") {
          onKeyDown(event);
          if (event.defaultPrevented) {
            return;
          }
        }

        // Block option hover events when the user has just pressed a key
        _this.blockOptionHover = true;
        switch (event.key) {
          case "ArrowLeft":
            if (!isMulti || inputValue) return;
            _this.focusValue("previous");
            break;
          case "ArrowRight":
            if (!isMulti || inputValue) return;
            _this.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (inputValue) return;
            if (focusedValue) {
              _this.removeValue(focusedValue);
            } else {
              if (!backspaceRemovesValue) return;
              if (isMulti) {
                _this.popValue();
              } else if (isClearable) {
                _this.clearValue();
              }
            }
            break;
          case "Tab":
            if (_this.isComposing) return;
            if (
              event.shiftKey ||
              !menuIsOpen ||
              !tabSelectsValue ||
              !focusedOption ||
              // don't capture the event if the menu opens on focus and the focused
              // option is already selected; it breaks the flow of navigation
              (openMenuOnFocus &&
                _this.isOptionSelected(focusedOption, selectValue))
            ) {
              return;
            }
            _this.selectOption(focusedOption);
            break;
          case "Enter":
            if (event.keyCode === 229) {
              // ignore the keydown event from an Input Method Editor(IME)
              // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
              break;
            }
            if (menuIsOpen) {
              if (!focusedOption) return;
              if (_this.isComposing) return;
              _this.selectOption(focusedOption);
              break;
            }
            return;
          case "Escape":
            if (menuIsOpen) {
              _this.setState({
                inputIsHiddenAfterUpdate: false,
              });
              _this.onInputChange("", {
                action: "menu-close",
                prevInputValue: inputValue,
              });
              _this.onMenuClose();
            } else if (isClearable && escapeClearsValue) {
              _this.clearValue();
            }
            break;
          case " ":
            // space
            if (inputValue) {
              return;
            }
            if (!menuIsOpen) {
              _this.openMenu("first");
              break;
            }
            if (!focusedOption) return;
            _this.selectOption(focusedOption);
            break;
          case "ArrowUp":
            if (menuIsOpen) {
              _this.focusOption("up");
            } else {
              _this.openMenu("last");
            }
            break;
          case "ArrowDown":
            if (menuIsOpen) {
              _this.focusOption("down");
            } else {
              _this.openMenu("first");
            }
            break;
          case "PageUp":
            if (!menuIsOpen) return;
            _this.focusOption("pageup");
            break;
          case "PageDown":
            if (!menuIsOpen) return;
            _this.focusOption("pagedown");
            break;
          case "Home":
            if (!menuIsOpen) return;
            _this.focusOption("first");
            break;
          case "End":
            if (!menuIsOpen) return;
            _this.focusOption("last");
            break;
          default:
            return;
        }
        event.preventDefault();
      };
      _this.state.instancePrefix =
        "react-select-" + (_this.props.instanceId || ++instanceId);
      _this.state.selectValue = cleanValue(_props.value);
      // Set focusedOption if menuIsOpen is set on init (e.g. defaultMenuIsOpen)
      if (_props.menuIsOpen && _this.state.selectValue.length) {
        var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
        var focusableOptions = _this.buildFocusableOptions();
        var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
        _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
        _this.state.focusedOption = focusableOptions[optionIndex];
        _this.state.focusedOptionId = getFocusedOptionId(
          focusableOptionsWithIds,
          focusableOptions[optionIndex],
        );
      }
      return _this;
    }
    _createClass(
      Select,
      [
        {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.startListeningComposition();
            this.startListeningToTouch();
            if (
              this.props.closeMenuOnScroll &&
              document &&
              document.addEventListener
            ) {
              // Listen to all scroll events, and filter them out inside of 'onScroll'
              document.addEventListener("scroll", this.onScroll, true);
            }
            if (this.props.autoFocus) {
              this.focusInput();
            }

            // Scroll focusedOption into view if menuIsOpen is set on mount (e.g. defaultMenuIsOpen)
            if (
              this.props.menuIsOpen &&
              this.state.focusedOption &&
              this.menuListRef &&
              this.focusedOptionRef
            ) {
              scrollIntoView(this.menuListRef, this.focusedOptionRef);
            }
            if (isAppleDevice()) {
              // eslint-disable-next-line react/no-did-mount-set-state
              this.setState({
                isAppleDevice: true,
              });
            }
          },
        },
        {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            var _this$props6 = this.props,
              isDisabled = _this$props6.isDisabled,
              menuIsOpen = _this$props6.menuIsOpen;
            var isFocused = this.state.isFocused;
            if (
              // ensure focus is restored correctly when the control becomes enabled
              (isFocused && !isDisabled && prevProps.isDisabled) ||
              // ensure focus is on the Input when the menu opens
              (isFocused && menuIsOpen && !prevProps.menuIsOpen)
            ) {
              this.focusInput();
            }
            if (isFocused && isDisabled && !prevProps.isDisabled) {
              // ensure select state gets blurred in case Select is programmatically disabled while focused
              // eslint-disable-next-line react/no-did-update-set-state
              this.setState(
                {
                  isFocused: false,
                },
                this.onMenuClose,
              );
            } else if (
              !isFocused &&
              !isDisabled &&
              prevProps.isDisabled &&
              this.inputRef === document.activeElement
            ) {
              // ensure select state gets focused in case Select is programatically re-enabled while focused (Firefox)
              // eslint-disable-next-line react/no-did-update-set-state
              this.setState({
                isFocused: true,
              });
            }

            // scroll the focused option into view if necessary
            if (
              this.menuListRef &&
              this.focusedOptionRef &&
              this.scrollToFocusedOptionOnUpdate
            ) {
              scrollIntoView(this.menuListRef, this.focusedOptionRef);
              this.scrollToFocusedOptionOnUpdate = false;
            }
          },
        },
        {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.stopListeningComposition();
            this.stopListeningToTouch();
            document.removeEventListener("scroll", this.onScroll, true);
          },

          // ==============================
          // Consumer Handlers
          // ==============================
        },
        {
          key: "onMenuOpen",
          value: function onMenuOpen() {
            this.props.onMenuOpen();
          },
        },
        {
          key: "onMenuClose",
          value: function onMenuClose() {
            this.onInputChange("", {
              action: "menu-close",
              prevInputValue: this.props.inputValue,
            });
            this.props.onMenuClose();
          },
        },
        {
          key: "onInputChange",
          value: function onInputChange(newValue, actionMeta) {
            this.props.onInputChange(newValue, actionMeta);
          },

          // ==============================
          // Methods
          // ==============================
        },
        {
          key: "focusInput",
          value: function focusInput() {
            if (!this.inputRef) return;
            this.inputRef.focus();
          },
        },
        {
          key: "blurInput",
          value: function blurInput() {
            if (!this.inputRef) return;
            this.inputRef.blur();
          },

          // aliased for consumers
        },
        {
          key: "openMenu",
          value: function openMenu(focusOption) {
            var _this2 = this;
            var _this$state2 = this.state,
              selectValue = _this$state2.selectValue,
              isFocused = _this$state2.isFocused;
            var focusableOptions = this.buildFocusableOptions();
            var openAtIndex =
              focusOption === "first" ? 0 : focusableOptions.length - 1;
            if (!this.props.isMulti) {
              var selectedIndex = focusableOptions.indexOf(selectValue[0]);
              if (selectedIndex > -1) {
                openAtIndex = selectedIndex;
              }
            }

            // only scroll if the menu isn't already open
            this.scrollToFocusedOptionOnUpdate = !(
              isFocused && this.menuListRef
            );
            this.setState(
              {
                inputIsHiddenAfterUpdate: false,
                focusedValue: null,
                focusedOption: focusableOptions[openAtIndex],
                focusedOptionId: this.getFocusedOptionId(
                  focusableOptions[openAtIndex],
                ),
              },
              function () {
                return _this2.onMenuOpen();
              },
            );
          },
        },
        {
          key: "focusValue",
          value: function focusValue(direction) {
            var _this$state3 = this.state,
              selectValue = _this$state3.selectValue,
              focusedValue = _this$state3.focusedValue;

            // Only multiselects support value focusing
            if (!this.props.isMulti) return;
            this.setState({
              focusedOption: null,
            });
            var focusedIndex = selectValue.indexOf(focusedValue);
            if (!focusedValue) {
              focusedIndex = -1;
            }
            var lastIndex = selectValue.length - 1;
            var nextFocus = -1;
            if (!selectValue.length) return;
            switch (direction) {
              case "previous":
                if (focusedIndex === 0) {
                  // don't cycle from the start to the end
                  nextFocus = 0;
                } else if (focusedIndex === -1) {
                  // if nothing is focused, focus the last value first
                  nextFocus = lastIndex;
                } else {
                  nextFocus = focusedIndex - 1;
                }
                break;
              case "next":
                if (focusedIndex > -1 && focusedIndex < lastIndex) {
                  nextFocus = focusedIndex + 1;
                }
                break;
            }
            this.setState({
              inputIsHidden: nextFocus !== -1,
              focusedValue: selectValue[nextFocus],
            });
          },
        },
        {
          key: "focusOption",
          value: function focusOption() {
            var direction =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : "first";
            var pageSize = this.props.pageSize;
            var focusedOption = this.state.focusedOption;
            var options = this.getFocusableOptions();
            if (!options.length) return;
            var nextFocus = 0; // handles 'first'
            var focusedIndex = options.indexOf(focusedOption);
            if (!focusedOption) {
              focusedIndex = -1;
            }
            if (direction === "up") {
              nextFocus =
                focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
            } else if (direction === "down") {
              nextFocus = (focusedIndex + 1) % options.length;
            } else if (direction === "pageup") {
              nextFocus = focusedIndex - pageSize;
              if (nextFocus < 0) nextFocus = 0;
            } else if (direction === "pagedown") {
              nextFocus = focusedIndex + pageSize;
              if (nextFocus > options.length - 1)
                nextFocus = options.length - 1;
            } else if (direction === "last") {
              nextFocus = options.length - 1;
            }
            this.scrollToFocusedOptionOnUpdate = true;
            this.setState({
              focusedOption: options[nextFocus],
              focusedValue: null,
              focusedOptionId: this.getFocusedOptionId(options[nextFocus]),
            });
          },
        },
        {
          key: "getTheme",
          value:
            // ==============================
            // Getters
            // ==============================

            function getTheme() {
              // Use the default theme if there are no customisations.
              if (!this.props.theme) {
                return defaultTheme;
              }
              // If the theme prop is a function, assume the function
              // knows how to merge the passed-in default theme with
              // its own modifications.
              if (typeof this.props.theme === "function") {
                return this.props.theme(defaultTheme);
              }
              // Otherwise, if a plain theme object was passed in,
              // overlay it with the default theme.
              return _objectSpread2(
                _objectSpread2({}, defaultTheme),
                this.props.theme,
              );
            },
        },
        {
          key: "getCommonProps",
          value: function getCommonProps() {
            var clearValue = this.clearValue,
              cx = this.cx,
              getStyles = this.getStyles,
              getClassNames = this.getClassNames,
              getValue = this.getValue,
              selectOption = this.selectOption,
              setValue = this.setValue,
              props = this.props;
            var isMulti = props.isMulti,
              isRtl = props.isRtl,
              options = props.options;
            var hasValue = this.hasValue();
            return {
              clearValue: clearValue,
              cx: cx,
              getStyles: getStyles,
              getClassNames: getClassNames,
              getValue: getValue,
              hasValue: hasValue,
              isMulti: isMulti,
              isRtl: isRtl,
              options: options,
              selectOption: selectOption,
              selectProps: props,
              setValue: setValue,
              theme: this.getTheme(),
            };
          },
        },
        {
          key: "hasValue",
          value: function hasValue() {
            var selectValue = this.state.selectValue;
            return selectValue.length > 0;
          },
        },
        {
          key: "hasOptions",
          value: function hasOptions() {
            return !!this.getFocusableOptions().length;
          },
        },
        {
          key: "isClearable",
          value: function isClearable() {
            var _this$props7 = this.props,
              isClearable = _this$props7.isClearable,
              isMulti = _this$props7.isMulti;

            // single select, by default, IS NOT clearable
            // multi select, by default, IS clearable
            if (isClearable === undefined) return isMulti;
            return isClearable;
          },
        },
        {
          key: "isOptionDisabled",
          value: function isOptionDisabled(option, selectValue) {
            return _isOptionDisabled(this.props, option, selectValue);
          },
        },
        {
          key: "isOptionSelected",
          value: function isOptionSelected(option, selectValue) {
            return _isOptionSelected(this.props, option, selectValue);
          },
        },
        {
          key: "filterOption",
          value: function filterOption(option, inputValue) {
            return _filterOption(this.props, option, inputValue);
          },
        },
        {
          key: "formatOptionLabel",
          value: function formatOptionLabel(data, context) {
            if (typeof this.props.formatOptionLabel === "function") {
              var _inputValue = this.props.inputValue;
              var _selectValue = this.state.selectValue;
              return this.props.formatOptionLabel(data, {
                context: context,
                inputValue: _inputValue,
                selectValue: _selectValue,
              });
            } else {
              return this.getOptionLabel(data);
            }
          },
        },
        {
          key: "formatGroupLabel",
          value: function formatGroupLabel(data) {
            return this.props.formatGroupLabel(data);
          },

          // ==============================
          // Mouse Handlers
          // ==============================
        },
        {
          key: "startListeningComposition",
          value:
            // ==============================
            // Composition Handlers
            // ==============================

            function startListeningComposition() {
              if (document && document.addEventListener) {
                document.addEventListener(
                  "compositionstart",
                  this.onCompositionStart,
                  false,
                );
                document.addEventListener(
                  "compositionend",
                  this.onCompositionEnd,
                  false,
                );
              }
            },
        },
        {
          key: "stopListeningComposition",
          value: function stopListeningComposition() {
            if (document && document.removeEventListener) {
              document.removeEventListener(
                "compositionstart",
                this.onCompositionStart,
              );
              document.removeEventListener(
                "compositionend",
                this.onCompositionEnd,
              );
            }
          },
        },
        {
          key: "startListeningToTouch",
          value:
            // ==============================
            // Touch Handlers
            // ==============================

            function startListeningToTouch() {
              if (document && document.addEventListener) {
                document.addEventListener(
                  "touchstart",
                  this.onTouchStart,
                  false,
                );
                document.addEventListener("touchmove", this.onTouchMove, false);
                document.addEventListener("touchend", this.onTouchEnd, false);
              }
            },
        },
        {
          key: "stopListeningToTouch",
          value: function stopListeningToTouch() {
            if (document && document.removeEventListener) {
              document.removeEventListener("touchstart", this.onTouchStart);
              document.removeEventListener("touchmove", this.onTouchMove);
              document.removeEventListener("touchend", this.onTouchEnd);
            }
          },
        },
        {
          key: "renderInput",
          value:
            // ==============================
            // Renderers
            // ==============================
            function renderInput() {
              var _this$props8 = this.props,
                isDisabled = _this$props8.isDisabled,
                isSearchable = _this$props8.isSearchable,
                inputId = _this$props8.inputId,
                inputValue = _this$props8.inputValue,
                tabIndex = _this$props8.tabIndex,
                form = _this$props8.form,
                menuIsOpen = _this$props8.menuIsOpen,
                required = _this$props8.required;
              var _this$getComponents = this.getComponents(),
                Input = _this$getComponents.Input;
              var _this$state4 = this.state,
                inputIsHidden = _this$state4.inputIsHidden,
                ariaSelection = _this$state4.ariaSelection;
              var commonProps = this.commonProps;
              var id = inputId || this.getElementId("input");

              // aria attributes makes the JSX "noisy", separated for clarity
              var ariaAttributes = _objectSpread2(
                _objectSpread2(
                  _objectSpread2(
                    {
                      "aria-autocomplete": "list",
                      "aria-expanded": menuIsOpen,
                      "aria-haspopup": true,
                      "aria-errormessage": this.props["aria-errormessage"],
                      "aria-invalid": this.props["aria-invalid"],
                      "aria-label": this.props["aria-label"],
                      "aria-labelledby": this.props["aria-labelledby"],
                      "aria-required": required,
                      role: "combobox",
                      "aria-activedescendant": this.state.isAppleDevice
                        ? undefined
                        : this.state.focusedOptionId || "",
                    },
                    menuIsOpen && {
                      "aria-controls": this.getElementId("listbox"),
                    },
                  ),
                  !isSearchable && {
                    "aria-readonly": true,
                  },
                ),
                this.hasValue()
                  ? (ariaSelection === null || ariaSelection === void 0
                      ? void 0
                      : ariaSelection.action) === "initial-input-focus" && {
                      "aria-describedby": this.getElementId("live-region"),
                    }
                  : {
                      "aria-describedby": this.getElementId("placeholder"),
                    },
              );
              if (!isSearchable) {
                // use a dummy input to maintain focus/blur functionality
                return /*#__PURE__*/ reactExports.createElement(
                  DummyInput,
                  _extends(
                    {
                      id: id,
                      innerRef: this.getInputRef,
                      onBlur: this.onInputBlur,
                      onChange: noop,
                      onFocus: this.onInputFocus,
                      disabled: isDisabled,
                      tabIndex: tabIndex,
                      inputMode: "none",
                      form: form,
                      value: "",
                    },
                    ariaAttributes,
                  ),
                );
              }
              return /*#__PURE__*/ reactExports.createElement(
                Input,
                _extends(
                  {},
                  commonProps,
                  {
                    autoCapitalize: "none",
                    autoComplete: "off",
                    autoCorrect: "off",
                    id: id,
                    innerRef: this.getInputRef,
                    isDisabled: isDisabled,
                    isHidden: inputIsHidden,
                    onBlur: this.onInputBlur,
                    onChange: this.handleInputChange,
                    onFocus: this.onInputFocus,
                    spellCheck: "false",
                    tabIndex: tabIndex,
                    form: form,
                    type: "text",
                    value: inputValue,
                  },
                  ariaAttributes,
                ),
              );
            },
        },
        {
          key: "renderPlaceholderOrValue",
          value: function renderPlaceholderOrValue() {
            var _this3 = this;
            var _this$getComponents2 = this.getComponents(),
              MultiValue = _this$getComponents2.MultiValue,
              MultiValueContainer = _this$getComponents2.MultiValueContainer,
              MultiValueLabel = _this$getComponents2.MultiValueLabel,
              MultiValueRemove = _this$getComponents2.MultiValueRemove,
              SingleValue = _this$getComponents2.SingleValue,
              Placeholder = _this$getComponents2.Placeholder;
            var commonProps = this.commonProps;
            var _this$props9 = this.props,
              controlShouldRenderValue = _this$props9.controlShouldRenderValue,
              isDisabled = _this$props9.isDisabled,
              isMulti = _this$props9.isMulti,
              inputValue = _this$props9.inputValue,
              placeholder = _this$props9.placeholder;
            var _this$state5 = this.state,
              selectValue = _this$state5.selectValue,
              focusedValue = _this$state5.focusedValue,
              isFocused = _this$state5.isFocused;
            if (!this.hasValue() || !controlShouldRenderValue) {
              return inputValue
                ? null
                : /*#__PURE__*/ reactExports.createElement(
                    Placeholder,
                    _extends({}, commonProps, {
                      key: "placeholder",
                      isDisabled: isDisabled,
                      isFocused: isFocused,
                      innerProps: {
                        id: this.getElementId("placeholder"),
                      },
                    }),
                    placeholder,
                  );
            }
            if (isMulti) {
              return selectValue.map(function (opt, index) {
                var isOptionFocused = opt === focusedValue;
                var key = ""
                  .concat(_this3.getOptionLabel(opt), "-")
                  .concat(_this3.getOptionValue(opt));
                return /*#__PURE__*/ reactExports.createElement(
                  MultiValue,
                  _extends({}, commonProps, {
                    components: {
                      Container: MultiValueContainer,
                      Label: MultiValueLabel,
                      Remove: MultiValueRemove,
                    },
                    isFocused: isOptionFocused,
                    isDisabled: isDisabled,
                    key: key,
                    index: index,
                    removeProps: {
                      onClick: function onClick() {
                        return _this3.removeValue(opt);
                      },
                      onTouchEnd: function onTouchEnd() {
                        return _this3.removeValue(opt);
                      },
                      onMouseDown: function onMouseDown(e) {
                        e.preventDefault();
                      },
                    },
                    data: opt,
                  }),
                  _this3.formatOptionLabel(opt, "value"),
                );
              });
            }
            if (inputValue) {
              return null;
            }
            var singleValue = selectValue[0];
            return /*#__PURE__*/ reactExports.createElement(
              SingleValue,
              _extends({}, commonProps, {
                data: singleValue,
                isDisabled: isDisabled,
              }),
              this.formatOptionLabel(singleValue, "value"),
            );
          },
        },
        {
          key: "renderClearIndicator",
          value: function renderClearIndicator() {
            var _this$getComponents3 = this.getComponents(),
              ClearIndicator = _this$getComponents3.ClearIndicator;
            var commonProps = this.commonProps;
            var _this$props10 = this.props,
              isDisabled = _this$props10.isDisabled,
              isLoading = _this$props10.isLoading;
            var isFocused = this.state.isFocused;
            if (
              !this.isClearable() ||
              !ClearIndicator ||
              isDisabled ||
              !this.hasValue() ||
              isLoading
            ) {
              return null;
            }
            var innerProps = {
              onMouseDown: this.onClearIndicatorMouseDown,
              onTouchEnd: this.onClearIndicatorTouchEnd,
              "aria-hidden": "true",
            };
            return /*#__PURE__*/ reactExports.createElement(
              ClearIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isFocused: isFocused,
              }),
            );
          },
        },
        {
          key: "renderLoadingIndicator",
          value: function renderLoadingIndicator() {
            var _this$getComponents4 = this.getComponents(),
              LoadingIndicator = _this$getComponents4.LoadingIndicator;
            var commonProps = this.commonProps;
            var _this$props11 = this.props,
              isDisabled = _this$props11.isDisabled,
              isLoading = _this$props11.isLoading;
            var isFocused = this.state.isFocused;
            if (!LoadingIndicator || !isLoading) return null;
            var innerProps = {
              "aria-hidden": "true",
            };
            return /*#__PURE__*/ reactExports.createElement(
              LoadingIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isDisabled: isDisabled,
                isFocused: isFocused,
              }),
            );
          },
        },
        {
          key: "renderIndicatorSeparator",
          value: function renderIndicatorSeparator() {
            var _this$getComponents5 = this.getComponents(),
              DropdownIndicator = _this$getComponents5.DropdownIndicator,
              IndicatorSeparator = _this$getComponents5.IndicatorSeparator;

            // separator doesn't make sense without the dropdown indicator
            if (!DropdownIndicator || !IndicatorSeparator) return null;
            var commonProps = this.commonProps;
            var isDisabled = this.props.isDisabled;
            var isFocused = this.state.isFocused;
            return /*#__PURE__*/ reactExports.createElement(
              IndicatorSeparator,
              _extends({}, commonProps, {
                isDisabled: isDisabled,
                isFocused: isFocused,
              }),
            );
          },
        },
        {
          key: "renderDropdownIndicator",
          value: function renderDropdownIndicator() {
            var _this$getComponents6 = this.getComponents(),
              DropdownIndicator = _this$getComponents6.DropdownIndicator;
            if (!DropdownIndicator) return null;
            var commonProps = this.commonProps;
            var isDisabled = this.props.isDisabled;
            var isFocused = this.state.isFocused;
            var innerProps = {
              onMouseDown: this.onDropdownIndicatorMouseDown,
              onTouchEnd: this.onDropdownIndicatorTouchEnd,
              "aria-hidden": "true",
            };
            return /*#__PURE__*/ reactExports.createElement(
              DropdownIndicator,
              _extends({}, commonProps, {
                innerProps: innerProps,
                isDisabled: isDisabled,
                isFocused: isFocused,
              }),
            );
          },
        },
        {
          key: "renderMenu",
          value: function renderMenu() {
            var _this4 = this;
            var _this$getComponents7 = this.getComponents(),
              Group = _this$getComponents7.Group,
              GroupHeading = _this$getComponents7.GroupHeading,
              Menu = _this$getComponents7.Menu,
              MenuList = _this$getComponents7.MenuList,
              MenuPortal = _this$getComponents7.MenuPortal,
              LoadingMessage = _this$getComponents7.LoadingMessage,
              NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
              Option = _this$getComponents7.Option;
            var commonProps = this.commonProps;
            var focusedOption = this.state.focusedOption;
            var _this$props12 = this.props,
              captureMenuScroll = _this$props12.captureMenuScroll,
              inputValue = _this$props12.inputValue,
              isLoading = _this$props12.isLoading,
              loadingMessage = _this$props12.loadingMessage,
              minMenuHeight = _this$props12.minMenuHeight,
              maxMenuHeight = _this$props12.maxMenuHeight,
              menuIsOpen = _this$props12.menuIsOpen,
              menuPlacement = _this$props12.menuPlacement,
              menuPosition = _this$props12.menuPosition,
              menuPortalTarget = _this$props12.menuPortalTarget,
              menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
              menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
              noOptionsMessage = _this$props12.noOptionsMessage,
              onMenuScrollToTop = _this$props12.onMenuScrollToTop,
              onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
            if (!menuIsOpen) return null;

            // TODO: Internal Option Type here
            var render = function render(props, id) {
              var type = props.type,
                data = props.data,
                isDisabled = props.isDisabled,
                isSelected = props.isSelected,
                label = props.label,
                value = props.value;
              var isFocused = focusedOption === data;
              var onHover = isDisabled
                ? undefined
                : function () {
                    return _this4.onOptionHover(data);
                  };
              var onSelect = isDisabled
                ? undefined
                : function () {
                    return _this4.selectOption(data);
                  };
              var optionId = ""
                .concat(_this4.getElementId("option"), "-")
                .concat(id);
              var innerProps = {
                id: optionId,
                onClick: onSelect,
                onMouseMove: onHover,
                onMouseOver: onHover,
                tabIndex: -1,
                role: "option",
                "aria-selected": _this4.state.isAppleDevice
                  ? undefined
                  : isSelected, // is not supported on Apple devices
              };

              return /*#__PURE__*/ reactExports.createElement(
                Option,
                _extends({}, commonProps, {
                  innerProps: innerProps,
                  data: data,
                  isDisabled: isDisabled,
                  isSelected: isSelected,
                  key: optionId,
                  label: label,
                  type: type,
                  value: value,
                  isFocused: isFocused,
                  innerRef: isFocused ? _this4.getFocusedOptionRef : undefined,
                }),
                _this4.formatOptionLabel(props.data, "menu"),
              );
            };
            var menuUI;
            if (this.hasOptions()) {
              menuUI = this.getCategorizedOptions().map(function (item) {
                if (item.type === "group") {
                  var _data = item.data,
                    options = item.options,
                    groupIndex = item.index;
                  var groupId = ""
                    .concat(_this4.getElementId("group"), "-")
                    .concat(groupIndex);
                  var headingId = "".concat(groupId, "-heading");
                  return /*#__PURE__*/ reactExports.createElement(
                    Group,
                    _extends({}, commonProps, {
                      key: groupId,
                      data: _data,
                      options: options,
                      Heading: GroupHeading,
                      headingProps: {
                        id: headingId,
                        data: item.data,
                      },
                      label: _this4.formatGroupLabel(item.data),
                    }),
                    item.options.map(function (option) {
                      return render(
                        option,
                        "".concat(groupIndex, "-").concat(option.index),
                      );
                    }),
                  );
                } else if (item.type === "option") {
                  return render(item, "".concat(item.index));
                }
              });
            } else if (isLoading) {
              var message = loadingMessage({
                inputValue: inputValue,
              });
              if (message === null) return null;
              menuUI = /*#__PURE__*/ reactExports.createElement(
                LoadingMessage,
                commonProps,
                message,
              );
            } else {
              var _message = noOptionsMessage({
                inputValue: inputValue,
              });
              if (_message === null) return null;
              menuUI = /*#__PURE__*/ reactExports.createElement(
                NoOptionsMessage,
                commonProps,
                _message,
              );
            }
            var menuPlacementProps = {
              minMenuHeight: minMenuHeight,
              maxMenuHeight: maxMenuHeight,
              menuPlacement: menuPlacement,
              menuPosition: menuPosition,
              menuShouldScrollIntoView: menuShouldScrollIntoView,
            };
            var menuElement = /*#__PURE__*/ reactExports.createElement(
              MenuPlacer,
              _extends({}, commonProps, menuPlacementProps),
              function (_ref4) {
                var ref = _ref4.ref,
                  _ref4$placerProps = _ref4.placerProps,
                  placement = _ref4$placerProps.placement,
                  maxHeight = _ref4$placerProps.maxHeight;
                return /*#__PURE__*/ reactExports.createElement(
                  Menu,
                  _extends({}, commonProps, menuPlacementProps, {
                    innerRef: ref,
                    innerProps: {
                      onMouseDown: _this4.onMenuMouseDown,
                      onMouseMove: _this4.onMenuMouseMove,
                    },
                    isLoading: isLoading,
                    placement: placement,
                  }),
                  /*#__PURE__*/ reactExports.createElement(
                    ScrollManager,
                    {
                      captureEnabled: captureMenuScroll,
                      onTopArrive: onMenuScrollToTop,
                      onBottomArrive: onMenuScrollToBottom,
                      lockEnabled: menuShouldBlockScroll,
                    },
                    function (scrollTargetRef) {
                      return /*#__PURE__*/ reactExports.createElement(
                        MenuList,
                        _extends({}, commonProps, {
                          innerRef: function innerRef(instance) {
                            _this4.getMenuListRef(instance);
                            scrollTargetRef(instance);
                          },
                          innerProps: {
                            role: "listbox",
                            "aria-multiselectable": commonProps.isMulti,
                            id: _this4.getElementId("listbox"),
                          },
                          isLoading: isLoading,
                          maxHeight: maxHeight,
                          focusedOption: focusedOption,
                        }),
                        menuUI,
                      );
                    },
                  ),
                );
              },
            );

            // positioning behaviour is almost identical for portalled and fixed,
            // so we use the same component. the actual portalling logic is forked
            // within the component based on `menuPosition`
            return menuPortalTarget || menuPosition === "fixed"
              ? /*#__PURE__*/ reactExports.createElement(
                  MenuPortal,
                  _extends({}, commonProps, {
                    appendTo: menuPortalTarget,
                    controlElement: this.controlRef,
                    menuPlacement: menuPlacement,
                    menuPosition: menuPosition,
                  }),
                  menuElement,
                )
              : menuElement;
          },
        },
        {
          key: "renderFormField",
          value: function renderFormField() {
            var _this5 = this;
            var _this$props13 = this.props,
              delimiter = _this$props13.delimiter,
              isDisabled = _this$props13.isDisabled,
              isMulti = _this$props13.isMulti,
              name = _this$props13.name,
              required = _this$props13.required;
            var selectValue = this.state.selectValue;
            if (required && !this.hasValue() && !isDisabled) {
              return /*#__PURE__*/ reactExports.createElement(RequiredInput$1, {
                name: name,
                onFocus: this.onValueInputFocus,
              });
            }
            if (!name || isDisabled) return;
            if (isMulti) {
              if (delimiter) {
                var value = selectValue
                  .map(function (opt) {
                    return _this5.getOptionValue(opt);
                  })
                  .join(delimiter);
                return /*#__PURE__*/ reactExports.createElement("input", {
                  name: name,
                  type: "hidden",
                  value: value,
                });
              } else {
                var input =
                  selectValue.length > 0
                    ? selectValue.map(function (opt, i) {
                        return /*#__PURE__*/ reactExports.createElement(
                          "input",
                          {
                            key: "i-".concat(i),
                            name: name,
                            type: "hidden",
                            value: _this5.getOptionValue(opt),
                          },
                        );
                      })
                    : /*#__PURE__*/ reactExports.createElement("input", {
                        name: name,
                        type: "hidden",
                        value: "",
                      });
                return /*#__PURE__*/ reactExports.createElement(
                  "div",
                  null,
                  input,
                );
              }
            } else {
              var _value = selectValue[0]
                ? this.getOptionValue(selectValue[0])
                : "";
              return /*#__PURE__*/ reactExports.createElement("input", {
                name: name,
                type: "hidden",
                value: _value,
              });
            }
          },
        },
        {
          key: "renderLiveRegion",
          value: function renderLiveRegion() {
            var commonProps = this.commonProps;
            var _this$state6 = this.state,
              ariaSelection = _this$state6.ariaSelection,
              focusedOption = _this$state6.focusedOption,
              focusedValue = _this$state6.focusedValue,
              isFocused = _this$state6.isFocused,
              selectValue = _this$state6.selectValue;
            var focusableOptions = this.getFocusableOptions();
            return /*#__PURE__*/ reactExports.createElement(
              LiveRegion$1,
              _extends({}, commonProps, {
                id: this.getElementId("live-region"),
                ariaSelection: ariaSelection,
                focusedOption: focusedOption,
                focusedValue: focusedValue,
                isFocused: isFocused,
                selectValue: selectValue,
                focusableOptions: focusableOptions,
                isAppleDevice: this.state.isAppleDevice,
              }),
            );
          },
        },
        {
          key: "render",
          value: function render() {
            var _this$getComponents8 = this.getComponents(),
              Control = _this$getComponents8.Control,
              IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
              SelectContainer = _this$getComponents8.SelectContainer,
              ValueContainer = _this$getComponents8.ValueContainer;
            var _this$props14 = this.props,
              className = _this$props14.className,
              id = _this$props14.id,
              isDisabled = _this$props14.isDisabled,
              menuIsOpen = _this$props14.menuIsOpen;
            var isFocused = this.state.isFocused;
            var commonProps = (this.commonProps = this.getCommonProps());
            return /*#__PURE__*/ reactExports.createElement(
              SelectContainer,
              _extends({}, commonProps, {
                className: className,
                innerProps: {
                  id: id,
                  onKeyDown: this.onKeyDown,
                },
                isDisabled: isDisabled,
                isFocused: isFocused,
              }),
              this.renderLiveRegion(),
              /*#__PURE__*/ reactExports.createElement(
                Control,
                _extends({}, commonProps, {
                  innerRef: this.getControlRef,
                  innerProps: {
                    onMouseDown: this.onControlMouseDown,
                    onTouchEnd: this.onControlTouchEnd,
                  },
                  isDisabled: isDisabled,
                  isFocused: isFocused,
                  menuIsOpen: menuIsOpen,
                }),
                /*#__PURE__*/ reactExports.createElement(
                  ValueContainer,
                  _extends({}, commonProps, {
                    isDisabled: isDisabled,
                  }),
                  this.renderPlaceholderOrValue(),
                  this.renderInput(),
                ),
                /*#__PURE__*/ reactExports.createElement(
                  IndicatorsContainer,
                  _extends({}, commonProps, {
                    isDisabled: isDisabled,
                  }),
                  this.renderClearIndicator(),
                  this.renderLoadingIndicator(),
                  this.renderIndicatorSeparator(),
                  this.renderDropdownIndicator(),
                ),
              ),
              this.renderMenu(),
              this.renderFormField(),
            );
          },
        },
      ],
      [
        {
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(props, state) {
            var prevProps = state.prevProps,
              clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
              inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
              ariaSelection = state.ariaSelection,
              isFocused = state.isFocused,
              prevWasFocused = state.prevWasFocused,
              instancePrefix = state.instancePrefix;
            var options = props.options,
              value = props.value,
              menuIsOpen = props.menuIsOpen,
              inputValue = props.inputValue,
              isMulti = props.isMulti;
            var selectValue = cleanValue(value);
            var newMenuOptionsState = {};
            if (
              prevProps &&
              (value !== prevProps.value ||
                options !== prevProps.options ||
                menuIsOpen !== prevProps.menuIsOpen ||
                inputValue !== prevProps.inputValue)
            ) {
              var focusableOptions = menuIsOpen
                ? buildFocusableOptions(props, selectValue)
                : [];
              var focusableOptionsWithIds = menuIsOpen
                ? buildFocusableOptionsWithIds(
                    buildCategorizedOptions(props, selectValue),
                    "".concat(instancePrefix, "-option"),
                  )
                : [];
              var focusedValue = clearFocusValueOnUpdate
                ? getNextFocusedValue(state, selectValue)
                : null;
              var focusedOption = getNextFocusedOption(state, focusableOptions);
              var focusedOptionId = getFocusedOptionId(
                focusableOptionsWithIds,
                focusedOption,
              );
              newMenuOptionsState = {
                selectValue: selectValue,
                focusedOption: focusedOption,
                focusedOptionId: focusedOptionId,
                focusableOptionsWithIds: focusableOptionsWithIds,
                focusedValue: focusedValue,
                clearFocusValueOnUpdate: false,
              };
            }
            // some updates should toggle the state of the input visibility
            var newInputIsHiddenState =
              inputIsHiddenAfterUpdate != null && props !== prevProps
                ? {
                    inputIsHidden: inputIsHiddenAfterUpdate,
                    inputIsHiddenAfterUpdate: undefined,
                  }
                : {};
            var newAriaSelection = ariaSelection;
            var hasKeptFocus = isFocused && prevWasFocused;
            if (isFocused && !hasKeptFocus) {
              // If `value` or `defaultValue` props are not empty then announce them
              // when the Select is initially focused
              newAriaSelection = {
                value: valueTernary(
                  isMulti,
                  selectValue,
                  selectValue[0] || null,
                ),
                options: selectValue,
                action: "initial-input-focus",
              };
              hasKeptFocus = !prevWasFocused;
            }

            // If the 'initial-input-focus' action has been set already
            // then reset the ariaSelection to null
            if (
              (ariaSelection === null || ariaSelection === void 0
                ? void 0
                : ariaSelection.action) === "initial-input-focus"
            ) {
              newAriaSelection = null;
            }
            return _objectSpread2(
              _objectSpread2(
                _objectSpread2({}, newMenuOptionsState),
                newInputIsHiddenState,
              ),
              {},
              {
                prevProps: props,
                ariaSelection: newAriaSelection,
                prevWasFocused: hasKeptFocus,
              },
            );
          },
        },
      ],
    );
    return Select;
  })(reactExports.Component);
  Select.defaultProps = defaultProps;

  var StateManagedSelect = /*#__PURE__*/ reactExports.forwardRef(
    function (props, ref) {
      var baseSelectProps = useStateManager(props);
      return /*#__PURE__*/ reactExports.createElement(
        Select,
        _extends(
          {
            ref: ref,
          },
          baseSelectProps,
        ),
      );
    },
  );
  var StateManagedSelect$1 = StateManagedSelect;

  const PhoneVerificationStep = ({
    state,
    dispatch,
    onSendOtp,
    onVerifyOtp,
    onBack,
  }) => {
    const theme = useTheme();
    const PHONE_VERIFY_STYLES = getPhoneVerifyStyles(theme);
    const BUTTON_STYLES = getButtonStyles(theme);
    const isPhoneValid =
      validatePhoneNumber(state.patientPhone) &&
      validateCountryCode(state.countryCode);
    return jsxRuntimeExports.jsxs("div", {
      style: PHONE_VERIFY_STYLES.container,
      children: [
        jsxRuntimeExports.jsx("div", {
          style: PHONE_VERIFY_STYLES.header,
          children: jsxRuntimeExports.jsx("h3", {
            style: PHONE_VERIFY_STYLES.title,
            children: "Verify Details",
          }),
        }),
        jsxRuntimeExports.jsx("div", {
          style: PHONE_VERIFY_STYLES.content,
          children: !state.otpSent
            ? jsxRuntimeExports.jsx(PhoneInputSection, {
                countryCode: state.countryCode,
                patientPhone: state.patientPhone,
                onCountryCodeChange: (code) => {
                  dispatch({ type: "SET_COUNTRY_CODE", payload: code });
                },
                onPhoneChange: (phone) =>
                  dispatch({ type: "SET_PATIENT_PHONE", payload: phone }),
              })
            : jsxRuntimeExports.jsx(OtpInputSection, {
                countryCode: state.countryCode,
                patientPhone: state.patientPhone,
                otpCode: state.otpCode,
                otpVerified: state.otpVerified,
                onOtpChange: (code) =>
                  dispatch({ type: "SET_OTP_CODE", payload: code }),
              }),
        }),
        jsxRuntimeExports.jsx("div", {
          style: PHONE_VERIFY_STYLES.footer,
          children: !state.otpSent
            ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [
                  jsxRuntimeExports.jsx("button", {
                    style: BUTTON_STYLES.secondary,
                    onClick: onBack,
                    children: "Back",
                  }),
                  jsxRuntimeExports.jsx("button", {
                    style: {
                      ...BUTTON_STYLES.primary,
                      opacity: isPhoneValid ? 1 : 0.6,
                    },
                    disabled: !isPhoneValid || state.otpSending,
                    onClick: onSendOtp,
                    children: state.otpSending ? "Sending..." : "Continue",
                  }),
                ],
              })
            : !state.otpVerified
              ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [
                    jsxRuntimeExports.jsx("button", {
                      style: BUTTON_STYLES.secondary,
                      onClick: () => {
                        dispatch({ type: "SET_OTP_SENT", payload: false });
                        dispatch({ type: "SET_OTP_CODE", payload: "" });
                      },
                      children: "Change Number",
                    }),
                    jsxRuntimeExports.jsx("button", {
                      style: {
                        ...BUTTON_STYLES.primary,
                        opacity: state.otpCode.length === 6 ? 1 : 0.6,
                      },
                      disabled:
                        state.otpCode.length !== 6 || state.otpVerifying,
                      onClick: onVerifyOtp,
                      children: state.otpVerifying
                        ? "Verifying..."
                        : "Verify OTP",
                    }),
                  ],
                })
              : null,
        }),
      ],
    });
  };
  const PhoneInputSection = ({
    countryCode,
    patientPhone,
    onCountryCodeChange,
    onPhoneChange,
  }) => {
    const theme = useTheme();
    const PHONE_VERIFY_STYLES = getPhoneVerifyStyles(theme);
    const countryOptions = COUNTRY_CODES.map((country) => ({
      value: country.code,
      label: country.label,
    }));
    const selectedOption = countryOptions.find(
      (opt) => opt.value === countryCode,
    );
    const customStyles = {
      control: (base) => ({
        ...base,
        height: "40px",
        minHeight: "40px",
        borderRadius: "6px",
        border: "1px solid #e2e8f0",
        boxShadow: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
        fontSize: "14px",
        fontFamily: "inherit",
        "&:hover": {
          borderColor: "#cbd5e1",
        },
      }),
      option: (base, state) => ({
        ...base,
        backgroundColor: state.isSelected
          ? "#3b82f6"
          : state.isFocused
            ? "#f1f5f9"
            : "#fff",
        color: state.isSelected ? "#fff" : "#1e293b",
        cursor: "pointer",
        padding: "10px 12px",
        fontSize: "14px",
        fontFamily: "inherit",
      }),
      menuList: (base) => ({
        ...base,
        maxHeight: "256px",
        padding: "4px",
      }),
      input: (base) => ({
        ...base,
        fontSize: "14px",
        fontFamily: "inherit",
      }),
    };
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: jsxRuntimeExports.jsxs("div", {
        style: { marginBottom: 20 },
        children: [
          jsxRuntimeExports.jsx("label", {
            style: PHONE_VERIFY_STYLES.label,
            children: "Enter Phone Number",
          }),
          jsxRuntimeExports.jsxs("div", {
            style: PHONE_VERIFY_STYLES.phoneInputContainer,
            children: [
              jsxRuntimeExports.jsx("div", {
                style: { width: 140 },
                children: jsxRuntimeExports.jsx(StateManagedSelect$1, {
                  options: countryOptions,
                  value: selectedOption,
                  onChange: (option) => {
                    if (option) {
                      onCountryCodeChange(option.value);
                    }
                  },
                  styles: customStyles,
                  isSearchable: true,
                  isClearable: false,
                  placeholder: "Code",
                  formatOptionLabel: (option, context) => {
                    if (context.context === "value") {
                      return option.value;
                    }
                    return option.label;
                  },
                  noOptionsMessage: () => "No countries found",
                }),
              }),
              jsxRuntimeExports.jsx("input", {
                type: "tel",
                style: PHONE_VERIFY_STYLES.phoneInput,
                placeholder: "0000 000 000",
                value: patientPhone,
                onChange: (e) => {
                  const value = e.target.value.replace(/\D/g, "");
                  onPhoneChange(value);
                },
                maxLength: 15,
              }),
            ],
          }),
        ],
      }),
    });
  };
  const OtpInputSection = ({
    countryCode,
    patientPhone,
    otpCode,
    otpVerified,
    onOtpChange,
  }) => {
    const theme = useTheme();
    const PHONE_VERIFY_STYLES = getPhoneVerifyStyles(theme);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs("div", {
          style: { marginBottom: 16 },
          children: [
            jsxRuntimeExports.jsx("label", {
              style: PHONE_VERIFY_STYLES.label,
              children: "Phone Number",
            }),
            jsxRuntimeExports.jsxs("div", {
              style: PHONE_VERIFY_STYLES.phoneDisplay,
              children: [countryCode, " ", patientPhone],
            }),
          ],
        }),
        jsxRuntimeExports.jsxs("div", {
          style: { marginBottom: 20 },
          children: [
            jsxRuntimeExports.jsx("label", {
              style: PHONE_VERIFY_STYLES.label,
              children: "Enter OTP",
            }),
            jsxRuntimeExports.jsx("input", {
              style: {
                ...PHONE_VERIFY_STYLES.otpInput,
                ...(otpVerified ? { opacity: 0.6, pointerEvents: "none" } : {}),
              },
              type: "text",
              placeholder: "Enter 6-digit OTP",
              value: otpCode,
              onChange: (e) => {
                if (!otpVerified) {
                  const value = e.target.value.replace(/\D/g, "");
                  if (value.length <= 6) {
                    onOtpChange(value);
                  }
                }
              },
              maxLength: 6,
              disabled: otpVerified,
            }),
            jsxRuntimeExports.jsx("div", {
              style: PHONE_VERIFY_STYLES.otpHint,
              children: "We've sent a 6-digit code to your phone number",
            }),
          ],
        }),
        otpVerified &&
          jsxRuntimeExports.jsxs("div", {
            style: PHONE_VERIFY_STYLES.successMessage,
            children: [
              jsxRuntimeExports.jsx("div", {
                style: PHONE_VERIFY_STYLES.successIcon,
                children: "\u2713",
              }),
              jsxRuntimeExports.jsxs("div", {
                children: [
                  jsxRuntimeExports.jsx("div", {
                    style: PHONE_VERIFY_STYLES.successTitle,
                    children: "Phone verified successfully",
                  }),
                  jsxRuntimeExports.jsx("div", {
                    style: PHONE_VERIFY_STYLES.successSubtitle,
                    children: "Your phone number has been verified",
                  }),
                ],
              }),
            ],
          }),
      ],
    });
  };

  const PAYMENT_METHODS = [
    { id: "card", name: "Credit/Debit Card", icon: "" },
    { id: "upi", name: "UPI", icon: "" },
    { id: "netbanking", name: "Net Banking", icon: "" },
    { id: "wallet", name: "Wallet", icon: "" },
  ];
  const PaymentStep = React.memo(
    ({
      amount,
      packageName,
      paymentDetails,
      onPaymentDetailsChange,
      onPay,
      onBack,
      isLoading,
    }) => {
      const theme = useTheme();
      const breakpoint = useBreakpoint(theme);
      const styles = getPaymentStyles(theme);
      const BUTTON_STYLES = getButtonStyles(theme, "medos", breakpoint);
      const isFormValid = () => {
        if (paymentDetails.method === "card") {
          return (
            paymentDetails.cardNumber &&
            paymentDetails.expiryDate &&
            paymentDetails.cvv
          );
        }
        if (paymentDetails.method === "upi") return !!paymentDetails.upiId;
        return !!paymentDetails.method;
      };
      return jsxRuntimeExports.jsxs("div", {
        style: styles.container,
        children: [
          jsxRuntimeExports.jsxs("div", {
            style: styles.summaryBox,
            children: [
              jsxRuntimeExports.jsxs("div", {
                style: styles.summaryRow,
                children: [
                  jsxRuntimeExports.jsx("span", {
                    style: styles.summaryLabel,
                    children: "Package",
                  }),
                  jsxRuntimeExports.jsx("span", {
                    style: styles.summaryValue,
                    children: packageName,
                  }),
                ],
              }),
              jsxRuntimeExports.jsxs("div", {
                style: {
                  ...styles.summaryRow,
                  borderTop: `1px solid ${theme.colors?.border || "#e5e7eb"}`,
                  paddingTop: "12px",
                  marginTop: "12px",
                },
                children: [
                  jsxRuntimeExports.jsx("span", {
                    style: styles.totalLabel,
                    children: "Total Payable",
                  }),
                  jsxRuntimeExports.jsxs("span", {
                    style: styles.totalAmount,
                    children: ["\u20B9", amount],
                  }),
                ],
              }),
            ],
          }),
          jsxRuntimeExports.jsx("h3", {
            style: styles.sectionTitle,
            children: "Select Payment Method",
          }),
          jsxRuntimeExports.jsx("div", {
            style: styles.methodGrid,
            children: PAYMENT_METHODS.map((method) => {
              const isSelected = paymentDetails.method === method.id;
              return jsxRuntimeExports.jsxs(
                "div",
                {
                  style: isSelected
                    ? styles.methodCardSelected
                    : styles.methodCard,
                  onClick: () => onPaymentDetailsChange("method", method.id),
                  children: [
                    jsxRuntimeExports.jsx("span", {
                      style: styles.methodIcon,
                      children: method.icon,
                    }),
                    jsxRuntimeExports.jsx("span", {
                      style: styles.methodName,
                      children: method.name,
                    }),
                    isSelected &&
                      jsxRuntimeExports.jsx("span", {
                        style: styles.checkIcon,
                        children: "\u2713",
                      }),
                  ],
                },
                method.id,
              );
            }),
          }),
          jsxRuntimeExports.jsxs("div", {
            style: styles.formContainer,
            children: [
              paymentDetails.method === "card" &&
                jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [
                    jsxRuntimeExports.jsxs("div", {
                      style: styles.formGroup,
                      children: [
                        jsxRuntimeExports.jsx("label", {
                          style: styles.label,
                          children: "Card Number",
                        }),
                        jsxRuntimeExports.jsx("input", {
                          type: "text",
                          placeholder: "0000 0000 0000 0000",
                          maxLength: 19,
                          style: styles.input,
                          value: paymentDetails.cardNumber,
                          onChange: (e) =>
                            onPaymentDetailsChange(
                              "cardNumber",
                              e.target.value,
                            ),
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsxs("div", {
                      style: styles.formGroup,
                      children: [
                        jsxRuntimeExports.jsx("label", {
                          style: styles.label,
                          children: "Cardholder Name",
                        }),
                        jsxRuntimeExports.jsx("input", {
                          type: "text",
                          placeholder: "Name on card",
                          style: styles.input,
                          value: paymentDetails.cardName,
                          onChange: (e) =>
                            onPaymentDetailsChange("cardName", e.target.value),
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsxs("div", {
                      style: styles.row,
                      children: [
                        jsxRuntimeExports.jsxs("div", {
                          style: { ...styles.formGroup, flex: 1 },
                          children: [
                            jsxRuntimeExports.jsx("label", {
                              style: styles.label,
                              children: "Expiry",
                            }),
                            jsxRuntimeExports.jsx("input", {
                              type: "text",
                              placeholder: "MM/YY",
                              maxLength: 5,
                              style: styles.input,
                              value: paymentDetails.expiryDate,
                              onChange: (e) =>
                                onPaymentDetailsChange(
                                  "expiryDate",
                                  e.target.value,
                                ),
                            }),
                          ],
                        }),
                        jsxRuntimeExports.jsxs("div", {
                          style: { ...styles.formGroup, flex: 1 },
                          children: [
                            jsxRuntimeExports.jsx("label", {
                              style: styles.label,
                              children: "CVV",
                            }),
                            jsxRuntimeExports.jsx("input", {
                              type: "password",
                              placeholder: "123",
                              maxLength: 3,
                              style: styles.input,
                              value: paymentDetails.cvv,
                              onChange: (e) =>
                                onPaymentDetailsChange("cvv", e.target.value),
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              paymentDetails.method === "upi" &&
                jsxRuntimeExports.jsxs("div", {
                  style: styles.formGroup,
                  children: [
                    jsxRuntimeExports.jsx("label", {
                      style: styles.label,
                      children: "UPI ID",
                    }),
                    jsxRuntimeExports.jsx("input", {
                      type: "text",
                      placeholder: "username@upi",
                      style: styles.input,
                      value: paymentDetails.upiId,
                      onChange: (e) =>
                        onPaymentDetailsChange("upiId", e.target.value),
                    }),
                  ],
                }),
            ],
          }),
          jsxRuntimeExports.jsxs("div", {
            style: styles.buttonGroup,
            children: [
              jsxRuntimeExports.jsx("button", {
                style: BUTTON_STYLES.secondary,
                onClick: onBack,
                disabled: isLoading,
                children: "Back",
              }),
              jsxRuntimeExports.jsx("button", {
                style: isFormValid()
                  ? BUTTON_STYLES.primary
                  : BUTTON_STYLES.disabled,
                onClick: onPay,
                disabled: !isFormValid() || isLoading,
                children: isLoading ? "Processing..." : `Pay ${amount}`,
              }),
            ],
          }),
        ],
      });
    },
  );
  const getPaymentStyles = (theme) => ({
    container: {
      display: "flex",
      flexDirection: "column",
    },
    sectionTitle: {
      fontSize: "16px",
      fontWeight: "600",
      marginBottom: "12px",
      color: theme.colors?.textPrimary || "#1f2937",
    },
    summaryBox: {
      backgroundColor: theme.colors?.surfaceSecondary || "#f9fafb",
      border: `1px solid ${theme.colors?.border || "#e5e7eb"}`,
      borderRadius: "8px",
      padding: "16px",
      marginBottom: "24px",
    },
    summaryRow: {
      display: "flex",
      justifyContent: "space-between",
      marginBottom: "8px",
    },
    summaryLabel: {
      fontSize: "14px",
      color: theme.colors?.textSecondary || "#6b7280",
    },
    summaryValue: {
      fontSize: "14px",
      fontWeight: "500",
      color: theme.colors?.textPrimary || "#374151",
    },
    totalLabel: {
      fontSize: "16px",
      fontWeight: "bold",
      color: theme.colors?.textPrimary || "#1f2937",
    },
    totalAmount: {
      fontSize: "20px",
      fontWeight: "bold",
      color: theme.colors?.primary || "#22c55e",
    },
    methodGrid: {
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      marginBottom: "24px",
    },
    methodCard: {
      display: "flex",
      alignItems: "center",
      padding: "14px",
      border: `1px solid ${theme.colors?.border || "#e5e7eb"}`,
      borderRadius: "8px",
      cursor: "pointer",
      backgroundColor: "white",
      transition: "all 0.2s",
    },
    methodCardSelected: {
      display: "flex",
      alignItems: "center",
      padding: "14px",
      border: `2px solid ${theme.colors?.primary || "#22c55e"}`,
      borderRadius: "8px",
      cursor: "pointer",
      backgroundColor: `${theme.colors?.primary}10` || "#f0fdf4",
    },
    methodIcon: { fontSize: "20px", marginRight: "12px" },
    methodName: { fontWeight: "500", flex: 1 },
    checkIcon: {
      color: theme.colors?.primary || "#22c55e",
      fontWeight: "bold",
    },
    formContainer: {
      marginBottom: "24px",
      animation: "fadeIn 0.3s ease-in",
    },
    formGroup: { marginBottom: "16px" },
    row: { display: "flex", gap: "16px" },
    label: {
      display: "block",
      fontSize: "13px",
      fontWeight: "500",
      color: theme.colors?.textSecondary || "#4b5563",
      marginBottom: "6px",
    },
    input: {
      width: "100%",
      padding: "12px",
      borderRadius: "6px",
      border: `1px solid ${theme.colors?.border || "#d1d5db"}`,
      fontSize: "14px",
      boxSizing: "border-box",
      outline: "none",
    },
    buttonGroup: {
      display: "flex",
      justifyContent: "space-between",
      gap: "12px",
      marginTop: "auto",
    },
  });

  const MOCK_PACKAGES = [
    {
      id: "1",
      name: "Basic Wellness",
      description: "Entry level consultation package",
      sessions: 3,
      price: 3000,
      discountedPrice: 2500,
      discount: 500,
      validityDays: 30,
      allowedConsultationModes: ["ONLINE"],
    },
    {
      id: "2",
      name: "Premium Care",
      description: "Comprehensive care with unlimited follow-ups",
      sessions: 5,
      price: 5000,
      discountedPrice: 4000,
      discount: 1000,
      validityDays: 60,
      allowedConsultationModes: ["ONLINE", "OFFLINE"],
    },
  ];
  const MOCK_USER_PACKS = [];
  const PackagePurchaseFlow = ({ onComplete }) => {
    const [step, setStep] = reactExports.useState(1);
    const [selectedPackage, setSelectedPackage] = reactExports.useState(null);
    const [selectedSessionPack, setSelectedSessionPack] =
      reactExports.useState(null);
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const [showPackageExplorer, setShowPackageExplorer] = React.useState(true);
    const [countdown, setCountdown] = reactExports.useState(5);
    const [otpSent, setOtpSent] = reactExports.useState(false);
    const [formData, setFormData] = reactExports.useState({
      name: "",
      email: "",
      countryCode: "+91",
      phone: "",
      otp: "",
      paymentMethod: "",
      cardNumber: "",
      cardName: "",
      expiryDate: "",
      cvv: "",
      upiId: "",
    });
    const updateForm = (field, value) => {
      setFormData((prev) => ({ ...prev, [field]: value }));
    };
    const handleNextStep = () => setStep((prev) => prev + 1);
    const handlePrevStep = () => setStep((prev) => prev - 1);
    const handleSelectSessionPack = (pack) => setSelectedSessionPack(pack);
    const handleSelectPackage = (pkg) => setSelectedPackage(pkg);
    const handleReset = () => {
      setStep(1);
      setCountdown(5);
      setSelectedPackage(null);
      setShowPackageExplorer(true);
    };
    const handleSendOtp = async () => {
      if (!formData.phone || formData.phone.length !== 10) {
        alert("Please enter a valid 10-digit phone number");
        return;
      }
      setIsLoading(true);
      try {
        await PatientService.sendPhoneVerificationOtp({
          countryCode: formData.countryCode,
          phoneNumber: formData.phone,
        });
        setOtpSent(true);
      } catch (error) {
        console.error("Error sending OTP:", error);
        const msg =
          error.response?.data?.message ||
          error.message ||
          "Failed to send OTP";
        alert(msg);
      } finally {
        setIsLoading(false);
      }
    };
    const handleVerifyOtp = async () => {
      if (!formData.otp || formData.otp.length !== 6) {
        return;
      }
      setIsLoading(true);
      try {
        await PatientService.verifyPhoneVerificationOtp({
          countryCode: formData.countryCode,
          phoneNumber: formData.phone,
          otpCode: formData.otp,
        });
        handleNextStep();
      } catch (error) {
        console.error("Error verifying OTP:", error);
        const msg =
          error.response?.data?.message || error.message || "Invalid OTP";
        alert(msg);
      } finally {
        setIsLoading(false);
      }
    };
    const handlePayment = () => {
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
        setStep(6);
      }, 2000);
    };
    reactExports.useEffect(() => {
      let timer;
      if (step === 6) {
        timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer);
              handleReset();
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setCountdown(5);
      }
      return () => {
        if (timer) clearInterval(timer);
      };
    }, [step]);
    const phoneComponentState = {
      countryCode: formData.countryCode,
      patientPhone: formData.phone,
      otpCode: formData.otp,
      otpSent: otpSent,
      otpVerified: false,
      otpSending: isLoading && !otpSent,
      otpVerifying: isLoading && otpSent,
      error: null,
    };
    const phoneComponentDispatch = (action) => {
      switch (action.type) {
        case "SET_COUNTRY_CODE":
          updateForm("countryCode", action.payload);
          break;
        case "SET_PATIENT_PHONE":
          const numericValue = action.payload.replace(/\D/g, "");
          if (numericValue.length <= 10) {
            updateForm("phone", numericValue);
          }
          break;
        case "SET_OTP_CODE":
          updateForm("otp", action.payload);
          break;
        case "SET_OTP_SENT":
          setOtpSent(action.payload);
          break;
      }
    };
    return jsxRuntimeExports.jsxs("div", {
      style: {
        maxWidth: "600px",
        margin: "0 auto",
        padding: "24px",
        fontFamily: "sans-serif",
      },
      children: [
        step === 1 &&
          jsxRuntimeExports.jsx(BookingOptionStep, {
            userSessionPacks: MOCK_USER_PACKS,
            availablePackages: MOCK_PACKAGES,
            showPackageExplorer: true,
            selectedSessionPack: selectedSessionPack,
            selectedNewPackage: selectedPackage,
            onSelectOption: (type, sessionPack) => {
              if (sessionPack) handleSelectSessionPack(sessionPack);
              handleNextStep();
            },
            onSelectPackage: (pkg) => {
              handleSelectPackage(pkg);
              handleNextStep();
            },
            onBack: () => {},
          }),
        step === 2 &&
          jsxRuntimeExports.jsx(PhoneVerificationStep, {
            state: phoneComponentState,
            dispatch: phoneComponentDispatch,
            onSendOtp: handleSendOtp,
            onVerifyOtp: handleVerifyOtp,
            onContinue: () => setStep(3),
            onBack: handlePrevStep,
          }),
        (step === 3 || step === 4) &&
          jsxRuntimeExports.jsx(PaymentStep, {
            amount: selectedPackage?.discountedPrice || 0,
            packageName: selectedPackage?.name || "New Appointment",
            paymentDetails: {
              method: formData.paymentMethod,
              cardNumber: formData.cardNumber,
              cardName: formData.cardName,
              expiryDate: formData.expiryDate,
              cvv: formData.cvv,
              upiId: formData.upiId,
              bankName: "",
              walletName: "",
            },
            onPaymentDetailsChange: (field, value) => {
              if (field === "method") {
                updateForm("paymentMethod", value);
                if (value) setStep(4);
              } else {
                updateForm(field, value);
              }
            },
            onPay: handlePayment,
            onBack: () => {
              if (step === 4) {
                setStep(3);
                updateForm("paymentMethod", "");
              } else {
                setStep(2);
              }
            },
            isLoading: isLoading,
          }),
        step === 6 &&
          jsxRuntimeExports.jsxs("div", {
            style: { textAlign: "center", padding: "40px 0" },
            children: [
              jsxRuntimeExports.jsx("div", {
                style: { fontSize: "64px", marginBottom: "20px" },
                children: "\u2713",
              }),
              jsxRuntimeExports.jsx("h2", {
                style: { color: "#22c55e", marginBottom: "8px" },
                children: "Payment Successful!",
              }),
              jsxRuntimeExports.jsxs("p", {
                style: { fontSize: "16px", color: "#374151" },
                children: ["You purchased ", selectedPackage?.name],
              }),
              jsxRuntimeExports.jsxs("p", {
                style: {
                  marginTop: "20px",
                  color: "#6b7280",
                  fontWeight: "500",
                },
                children: ["Redirecting to home in ", countdown, " seconds..."],
              }),
              jsxRuntimeExports.jsx("div", {
                style: {
                  marginTop: "32px",
                  display: "flex",
                  gap: "12px",
                  justifyContent: "center",
                  flexWrap: "wrap",
                },
                children: jsxRuntimeExports.jsx("button", {
                  onClick: handleReset,
                  style: {
                    padding: "10px 24px",
                    border: "1px solid #32CD32",
                    borderRadius: "8px",
                    background: "white",
                    color: "#374151",
                    cursor: "pointer",
                    fontSize: "14px",
                    fontWeight: 600,
                  },
                  children: "Close",
                }),
              }),
            ],
          }),
      ],
    });
  };

  const init = (options) => {
    const container = document.getElementById(options.containerId);
    if (!container) {
      console.error(
        `MedOS: Container with id '${options.containerId}' not found.`,
      );
      return;
    }
    const root = clientExports.createRoot(container);
    const handleComplete = () => {
      console.log("Package purchase flow completed");
      if (options.onComplete) options.onComplete();
    };
    root.render(
      jsxRuntimeExports.jsx(React.StrictMode, {
        children: jsxRuntimeExports.jsx(MedosThemeProvider, {
          children: jsxRuntimeExports.jsx(PackagePurchaseFlow, {
            onComplete: handleComplete,
          }),
        }),
      }),
    );
  };
  if (typeof window !== "undefined") {
    window.MedosPackagePurchase = {
      init,
    };
  }
})();
